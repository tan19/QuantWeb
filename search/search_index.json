{"config":{"lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"A stroll through the brambles of Quant Finance.","title":"Home"},{"location":"-Quant%20Interview%20Questions/","text":"Introduction Quant Interview Questions","title":"Introduction"},{"location":"-Quant%20Interview%20Questions/#introduction","text":"Quant Interview Questions","title":"Introduction"},{"location":"-Quant%20Interview%20Questions/0.%20Basics/Basics/","text":"Basics","title":"Basics"},{"location":"-Quant%20Interview%20Questions/0.%20Basics/Basics/#basics","text":"","title":"Basics"},{"location":"-Quant%20Interview%20Questions/0.%20Basics/1.1%20Mental%20Games/","text":"Examples OI Wiki \u6d1b\u8c37 \u7a0b\u5e8f\u8bbe\u8ba1\u7ade\u8d5b\u8fdb\u9636\u8bad\u7ec3\u6307\u5357","title":"Examples"},{"location":"-Quant%20Interview%20Questions/0.%20Basics/1.1%20Mental%20Games/#examples","text":"OI Wiki \u6d1b\u8c37 \u7a0b\u5e8f\u8bbe\u8ba1\u7ade\u8d5b\u8fdb\u9636\u8bad\u7ec3\u6307\u5357","title":"Examples"},{"location":"-Quant%20Interview%20Questions/0.%20Basics/1.1%20Mental%20Games/Logic%20Brainteasers/","text":"Logic Brainteasers","title":"Logic Brainteasers"},{"location":"-Quant%20Interview%20Questions/0.%20Basics/1.1%20Mental%20Games/Logic%20Brainteasers/#logic-brainteasers","text":"","title":"Logic Brainteasers"},{"location":"-Quant%20Interview%20Questions/0.%20Basics/1.1%20Mental%20Games/Math%20Brainteasers/","text":"Math Brainteasers","title":"Math Brainteasers"},{"location":"-Quant%20Interview%20Questions/0.%20Basics/1.1%20Mental%20Games/Math%20Brainteasers/#math-brainteasers","text":"","title":"Math Brainteasers"},{"location":"-Quant%20Interview%20Questions/0.%20Basics/1.1%20Mental%20Games/Mental%20Math/","text":"Mental Math","title":"Mental Math"},{"location":"-Quant%20Interview%20Questions/0.%20Basics/1.1%20Mental%20Games/Mental%20Math/#mental-math","text":"","title":"Mental Math"},{"location":"-Quant%20Interview%20Questions/0.%20Basics/1.2%20Calculus/","text":"Index","title":"Index"},{"location":"-Quant%20Interview%20Questions/0.%20Basics/1.2%20Calculus/#index","text":"","title":"Index"},{"location":"-Quant%20Interview%20Questions/0.%20Basics/1.2%20Calculus/Analytic%20Geometry/","text":"Index","title":"Index"},{"location":"-Quant%20Interview%20Questions/0.%20Basics/1.2%20Calculus/Analytic%20Geometry/#index","text":"","title":"Index"},{"location":"-Quant%20Interview%20Questions/0.%20Basics/1.3%20Differential%20Equations/","text":"Index","title":"Index"},{"location":"-Quant%20Interview%20Questions/0.%20Basics/1.3%20Differential%20Equations/#index","text":"","title":"Index"},{"location":"-Quant%20Interview%20Questions/0.%20Basics/1.4%20Linear%20Algebra/","text":"Index","title":"Index"},{"location":"-Quant%20Interview%20Questions/0.%20Basics/1.4%20Linear%20Algebra/#index","text":"","title":"Index"},{"location":"-Quant%20Interview%20Questions/0.%20Basics/1.4%20Statistics/","text":"Examples OI Wiki \u6d1b\u8c37 \u7a0b\u5e8f\u8bbe\u8ba1\u7ade\u8d5b\u8fdb\u9636\u8bad\u7ec3\u6307\u5357","title":"Examples"},{"location":"-Quant%20Interview%20Questions/0.%20Basics/1.4%20Statistics/#examples","text":"OI Wiki \u6d1b\u8c37 \u7a0b\u5e8f\u8bbe\u8ba1\u7ade\u8d5b\u8fdb\u9636\u8bad\u7ec3\u6307\u5357","title":"Examples"},{"location":"-Quant%20Interview%20Questions/0.%20Basics/1.5%20Probability/","text":"Examples OI Wiki \u6d1b\u8c37 \u7a0b\u5e8f\u8bbe\u8ba1\u7ade\u8d5b\u8fdb\u9636\u8bad\u7ec3\u6307\u5357","title":"Examples"},{"location":"-Quant%20Interview%20Questions/0.%20Basics/1.5%20Probability/#examples","text":"OI Wiki \u6d1b\u8c37 \u7a0b\u5e8f\u8bbe\u8ba1\u7ade\u8d5b\u8fdb\u9636\u8bad\u7ec3\u6307\u5357","title":"Examples"},{"location":"-Quant%20Interview%20Questions/0.%20Basics/1.6%20Linear%20Algebra/","text":"Index","title":"Index"},{"location":"-Quant%20Interview%20Questions/0.%20Basics/1.6%20Linear%20Algebra/#index","text":"","title":"Index"},{"location":"-Quant%20Interview%20Questions/1.%20Quant%20Developer/Index/","text":"Quant Developer","title":"Quant Developer"},{"location":"-Quant%20Interview%20Questions/1.%20Quant%20Developer/Index/#quant-developer","text":"","title":"Quant Developer"},{"location":"-Quant%20Interview%20Questions/1.%20Quant%20Developer/2.2%20Data%20Structures%20and%20Algorithms/","text":"Index","title":"Index"},{"location":"-Quant%20Interview%20Questions/1.%20Quant%20Developer/2.2%20Data%20Structures%20and%20Algorithms/#index","text":"","title":"Index"},{"location":"-Quant%20Interview%20Questions/1.%20Quant%20Developer/2.3%20Software%20Engineering/","text":"Design Patterns Interceptor 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 from functools import wraps def iterceptor ( func ): print ( 'this is executed at function definition time (def my_func)' ) @wraps ( func ) def wrapper ( * args , ** kwargs ): print ( 'this is executed before function call' ) result = func ( * args , ** kwargs ) print ( 'this is executed after function call' ) return result return wrapper @iterceptor def my_func ( n ): print ( 'this is my_func' ) print ( 'n =' , n ) my_func ( 4 ) Facade","title":"Design Patterns"},{"location":"-Quant%20Interview%20Questions/1.%20Quant%20Developer/2.3%20Software%20Engineering/#design-patterns","text":"","title":"Design Patterns"},{"location":"-Quant%20Interview%20Questions/1.%20Quant%20Developer/2.3%20Software%20Engineering/#interceptor","text":"1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 from functools import wraps def iterceptor ( func ): print ( 'this is executed at function definition time (def my_func)' ) @wraps ( func ) def wrapper ( * args , ** kwargs ): print ( 'this is executed before function call' ) result = func ( * args , ** kwargs ) print ( 'this is executed after function call' ) return result return wrapper @iterceptor def my_func ( n ): print ( 'this is my_func' ) print ( 'n =' , n ) my_func ( 4 )","title":"Interceptor"},{"location":"-Quant%20Interview%20Questions/1.%20Quant%20Developer/2.3%20Software%20Engineering/#facade","text":"","title":"Facade"},{"location":"-Quant%20Interview%20Questions/1.%20Quant%20Developer/2.3%20Software%20Engineering/SOLID/","text":"SOLID First introduced by Robert C. Martin in 2000, SOLID stands for: Single-responsibility principle: Every class should have only one responsibility. Open-closed principle: \"Software entitles should be open for extension, but closed for modification.\" Liskov substitution principle: \"Functions that use pointers or references to base classes must be able to use objects of derived classes without knowing it.\" Interface segregation principle: \"Many client-specific interfaces are better than one general-purpose interface.\" Dependency inversion principle: \"Depend upon abstractions, [not] concretions.\"","title":"SOLID"},{"location":"-Quant%20Interview%20Questions/1.%20Quant%20Developer/2.3%20Software%20Engineering/SOLID/#solid","text":"First introduced by Robert C. Martin in 2000, SOLID stands for: Single-responsibility principle: Every class should have only one responsibility. Open-closed principle: \"Software entitles should be open for extension, but closed for modification.\" Liskov substitution principle: \"Functions that use pointers or references to base classes must be able to use objects of derived classes without knowing it.\" Interface segregation principle: \"Many client-specific interfaces are better than one general-purpose interface.\" Dependency inversion principle: \"Depend upon abstractions, [not] concretions.\"","title":"SOLID"},{"location":"-Quant%20Interview%20Questions/1.%20Quant%20Developer/2.4%20Computer%20Systems/","text":"Index","title":"Index"},{"location":"-Quant%20Interview%20Questions/1.%20Quant%20Developer/2.4%20Computer%20Systems/#index","text":"","title":"Index"},{"location":"-Quant%20Interview%20Questions/2.%20Quant%20Researcher/Examples/","text":"Basic Concepts Bias-Variance Tradeoff A model can be thought of as a statistic (i.e., a function of samples), hence it has a sampling distribution with its mean and variance. The error between the mean (i.e., average model prediction) and the ground truth is called bias , while the average variability in the model prediction is called variance , which tells you how much the model changes as the data are sampled repeatedly. Mathematically, \\[\\begin{align} \\mbox{Bias} &= \\EEE[\\hat{f}(x)] - f(x)\\\\ \\mbox{Variance} &= \\mbox{Var}[\\hat{f}(x)] \\end{align}\\] The mean square error can then be decomposed into three terms: \\[\\begin{align} \\mbox{Error} &\\equiv \\EEE[(\\hat{f}(x) - f(x))^2] \\\\ \\nonumber &= (\\EEE[\\hat{f}(x)-f(x)])^2 + \\mbox{Var}[\\hat{f}(x) - f(x)]\\\\ \\nonumber &= (\\EEE[\\hat{f}(x)-f(x)])^2 + \\mbox{Var}[\\hat{f}(x)] + \\mbox{Var}[f(x)] \\\\ \\nonumber &= \\mbox{Bias}^2 + \\mbox{Variance} + \\mbox{Ground Truth Error} \\end{align}\\] The immediate consequences of the above are that: Increased data size does not help the bias term. But it does help the variance term. The ground truth error, which comes from the population, is irreducible. One way to resolve this issue is to use mixture models and/or ensemble methods (read Section \\ref{sec:Ensemble_Methods} for more details). See Questions (e.g., \\ref{q:Bias-Variance Tradeoff}) for the topic of this section.","title":"Basic Concepts"},{"location":"-Quant%20Interview%20Questions/2.%20Quant%20Researcher/Examples/#basic-concepts","text":"","title":"Basic Concepts"},{"location":"-Quant%20Interview%20Questions/2.%20Quant%20Researcher/Examples/#bias-variance-tradeoff","text":"A model can be thought of as a statistic (i.e., a function of samples), hence it has a sampling distribution with its mean and variance. The error between the mean (i.e., average model prediction) and the ground truth is called bias , while the average variability in the model prediction is called variance , which tells you how much the model changes as the data are sampled repeatedly. Mathematically, \\[\\begin{align} \\mbox{Bias} &= \\EEE[\\hat{f}(x)] - f(x)\\\\ \\mbox{Variance} &= \\mbox{Var}[\\hat{f}(x)] \\end{align}\\] The mean square error can then be decomposed into three terms: \\[\\begin{align} \\mbox{Error} &\\equiv \\EEE[(\\hat{f}(x) - f(x))^2] \\\\ \\nonumber &= (\\EEE[\\hat{f}(x)-f(x)])^2 + \\mbox{Var}[\\hat{f}(x) - f(x)]\\\\ \\nonumber &= (\\EEE[\\hat{f}(x)-f(x)])^2 + \\mbox{Var}[\\hat{f}(x)] + \\mbox{Var}[f(x)] \\\\ \\nonumber &= \\mbox{Bias}^2 + \\mbox{Variance} + \\mbox{Ground Truth Error} \\end{align}\\] The immediate consequences of the above are that: Increased data size does not help the bias term. But it does help the variance term. The ground truth error, which comes from the population, is irreducible. One way to resolve this issue is to use mixture models and/or ensemble methods (read Section \\ref{sec:Ensemble_Methods} for more details). See Questions (e.g., \\ref{q:Bias-Variance Tradeoff}) for the topic of this section.","title":"Bias-Variance Tradeoff"},{"location":"-Quant%20Interview%20Questions/2.%20Quant%20Researcher/3.1%20Numerical%20Methods%20and%20Optimization/","text":"Index","title":"Index"},{"location":"-Quant%20Interview%20Questions/2.%20Quant%20Researcher/3.1%20Numerical%20Methods%20and%20Optimization/#index","text":"","title":"Index"},{"location":"-Quant%20Interview%20Questions/2.%20Quant%20Researcher/3.2%20Machine%20Learning/","text":"Index","title":"Index"},{"location":"-Quant%20Interview%20Questions/2.%20Quant%20Researcher/3.2%20Machine%20Learning/#index","text":"","title":"Index"},{"location":"-Quant%20Interview%20Questions/2.%20Quant%20Researcher/3.3%20Quantitative%20Finance/","text":"Index","title":"Index"},{"location":"-Quant%20Interview%20Questions/2.%20Quant%20Researcher/3.3%20Quantitative%20Finance/#index","text":"","title":"Index"},{"location":"-Quant%20Interview%20Questions/2.%20Quant%20Researcher/3.3%20Quantitative%20Finance/3.3.1%20Brownian%20Motion/BM/","text":"Brownian Motion Q: Brownian Motion Hitting Time Probability Suppose \\(dX_t = rdt + dW_t\\) , what is the probability that \\(X_t\\) hits 3 before hitting -5? A: Brownian Motion Hitting Time Probability Notice that the exponential martingale is defined as: \\[\\begin{align} e^{-\\frac{\\sigma^2}{2}t + \\sigma W_t} \\end{align}\\] Plug in \\(W_t = X_t - rt\\) , we have \\[\\begin{align} e^{-\\frac{\\sigma^2}{2}t + \\sigma (X_t - rt)} \\end{align}\\] Let \\(\\sigma = -2r\\) , we have \\[\\begin{align} e^{-\\frac{\\sigma^2}{2}t + \\sigma (X_t - rt)} = e^{-\\frac{(-2r)^2}{2}t - 2r (X_t - rt)} = e^{-2rX_t} \\end{align}\\] and \\(e^{-2rX_t}\\) is a martingale. Now, \\[\\begin{align} 1 = E[e^{-2rX_t}] = P_3 e^{-2r(3)} + (1-P_3) e^{-2r(-5)} \\implies P_3 = \\frac{e^{10r} - 1}{e^{10r} - e^{-6r}} \\end{align}\\] Q: Brownian Bridge What is a Brownian bridge? What is the distribution of a Brownian Bridge? Why and how do we use it? A: Brownian Bridge In a Brownian motion the state variable, i.e. the stock price, FX rate, interest rate, is stochastic and evolves over a period of time in a random manner. The randomness is tied to the volatility of the asset and the drift is deterministic. In the short run, the volatility dominates the process and the asset price path is truly stochastic, i.e. random. However, over the long period of time the drift will dominate the volatility and therefore, if there are small errors in estimation of the drift it will lead to large fluctuations in the future price distribution. This is one of the drawbacks of a Brownian motion (as applied to the pricing of financial assets). Over longer horizons the drift of the stochastic process (Brownian motion) becomes a complicating factor. Therefore, a Brownian motion may not be very suitable for modelling an asset which has a longer maturity period, say, 5 years, 10 years, etc. and where the final state of the asset is known. Like a discount bond (Treasury bonds). A government bond can have maturities of 5 years, 10 years, 30 years and the final value of the bond is known, i.e. the par (face) value. And, a bond will always redeem at par. Besides Treasury and discount bonds, Brownian Bridges are also used to model Barrier options and other exotic options where the terminal value is known in advance. Monte Carlo pricing of continuous barrier options with Heston .","title":"Brownian Motion"},{"location":"-Quant%20Interview%20Questions/2.%20Quant%20Researcher/3.3%20Quantitative%20Finance/3.3.1%20Brownian%20Motion/BM/#brownian-motion","text":"Q: Brownian Motion Hitting Time Probability Suppose \\(dX_t = rdt + dW_t\\) , what is the probability that \\(X_t\\) hits 3 before hitting -5? A: Brownian Motion Hitting Time Probability Notice that the exponential martingale is defined as: \\[\\begin{align} e^{-\\frac{\\sigma^2}{2}t + \\sigma W_t} \\end{align}\\] Plug in \\(W_t = X_t - rt\\) , we have \\[\\begin{align} e^{-\\frac{\\sigma^2}{2}t + \\sigma (X_t - rt)} \\end{align}\\] Let \\(\\sigma = -2r\\) , we have \\[\\begin{align} e^{-\\frac{\\sigma^2}{2}t + \\sigma (X_t - rt)} = e^{-\\frac{(-2r)^2}{2}t - 2r (X_t - rt)} = e^{-2rX_t} \\end{align}\\] and \\(e^{-2rX_t}\\) is a martingale. Now, \\[\\begin{align} 1 = E[e^{-2rX_t}] = P_3 e^{-2r(3)} + (1-P_3) e^{-2r(-5)} \\implies P_3 = \\frac{e^{10r} - 1}{e^{10r} - e^{-6r}} \\end{align}\\] Q: Brownian Bridge What is a Brownian bridge? What is the distribution of a Brownian Bridge? Why and how do we use it? A: Brownian Bridge In a Brownian motion the state variable, i.e. the stock price, FX rate, interest rate, is stochastic and evolves over a period of time in a random manner. The randomness is tied to the volatility of the asset and the drift is deterministic. In the short run, the volatility dominates the process and the asset price path is truly stochastic, i.e. random. However, over the long period of time the drift will dominate the volatility and therefore, if there are small errors in estimation of the drift it will lead to large fluctuations in the future price distribution. This is one of the drawbacks of a Brownian motion (as applied to the pricing of financial assets). Over longer horizons the drift of the stochastic process (Brownian motion) becomes a complicating factor. Therefore, a Brownian motion may not be very suitable for modelling an asset which has a longer maturity period, say, 5 years, 10 years, etc. and where the final state of the asset is known. Like a discount bond (Treasury bonds). A government bond can have maturities of 5 years, 10 years, 30 years and the final value of the bond is known, i.e. the par (face) value. And, a bond will always redeem at par. Besides Treasury and discount bonds, Brownian Bridges are also used to model Barrier options and other exotic options where the terminal value is known in advance. Monte Carlo pricing of continuous barrier options with Heston .","title":"Brownian Motion"},{"location":"-Quant%20Interview%20Questions/2.%20Quant%20Researcher/3.3%20Quantitative%20Finance/3.3.1%20Brownian%20Motion/Brownian%20Bridge/","text":"Brownian Bridge Q: Brownian Motion Hitting Time Probability Suppose \\(dX_t = rdt + dW_t\\) , what is the probability that \\(X_t\\) hits 3 before hitting -5? A: Brownian Motion Hitting Time Probability Notice that the exponential martingale is defined as: \\[\\begin{align} e^{-\\frac{\\sigma^2}{2}t + \\sigma W_t} \\end{align}\\] Plug in \\(W_t = X_t - rt\\) , we have \\[\\begin{align} e^{-\\frac{\\sigma^2}{2}t + \\sigma (X_t - rt)} \\end{align}\\] Let \\(\\sigma = -2r\\) , we have \\[\\begin{align} e^{-\\frac{\\sigma^2}{2}t + \\sigma (X_t - rt)} = e^{-\\frac{(-2r)^2}{2}t - 2r (X_t - rt)} = e^{-2rX_t} \\end{align}\\] and \\(e^{-2rX_t}\\) is a martingale. Now, \\[\\begin{align} 1 = E[e^{-2rX_t}] = P_3 e^{-2r(3)} + (1-P_3) e^{-2r(-5)} \\implies P_3 = \\frac{e^{10r} - 1}{e^{10r} - e^{-6r}} \\end{align}\\] Q: Brownian Bridge What is a Brownian bridge? What is the distribution of a Brownian Bridge? Why and how do we use it? A: Brownian Bridge In a Brownian motion the state variable, i.e. the stock price, FX rate, interest rate, is stochastic and evolves over a period of time in a random manner. The randomness is tied to the volatility of the asset and the drift is deterministic. In the short run, the volatility dominates the process and the asset price path is truly stochastic, i.e. random. However, over the long period of time the drift will dominate the volatility and therefore, if there are small errors in estimation of the drift it will lead to large fluctuations in the future price distribution. This is one of the drawbacks of a Brownian motion (as applied to the pricing of financial assets). Over longer horizons the drift of the stochastic process (Brownian motion) becomes a complicating factor. Therefore, a Brownian motion may not be very suitable for modelling an asset which has a longer maturity period, say, 5 years, 10 years, etc. and where the final state of the asset is known. Like a discount bond (Treasury bonds). A government bond can have maturities of 5 years, 10 years, 30 years and the final value of the bond is known, i.e. the par (face) value. And, a bond will always redeem at par. Besides Treasury and discount bonds, Brownian Bridges are also used to model Barrier options and other exotic options where the terminal value is known in advance. Monte Carlo pricing of continuous barrier options with Heston .","title":"Brownian Bridge"},{"location":"-Quant%20Interview%20Questions/2.%20Quant%20Researcher/3.3%20Quantitative%20Finance/3.3.1%20Brownian%20Motion/Brownian%20Bridge/#brownian-bridge","text":"Q: Brownian Motion Hitting Time Probability Suppose \\(dX_t = rdt + dW_t\\) , what is the probability that \\(X_t\\) hits 3 before hitting -5? A: Brownian Motion Hitting Time Probability Notice that the exponential martingale is defined as: \\[\\begin{align} e^{-\\frac{\\sigma^2}{2}t + \\sigma W_t} \\end{align}\\] Plug in \\(W_t = X_t - rt\\) , we have \\[\\begin{align} e^{-\\frac{\\sigma^2}{2}t + \\sigma (X_t - rt)} \\end{align}\\] Let \\(\\sigma = -2r\\) , we have \\[\\begin{align} e^{-\\frac{\\sigma^2}{2}t + \\sigma (X_t - rt)} = e^{-\\frac{(-2r)^2}{2}t - 2r (X_t - rt)} = e^{-2rX_t} \\end{align}\\] and \\(e^{-2rX_t}\\) is a martingale. Now, \\[\\begin{align} 1 = E[e^{-2rX_t}] = P_3 e^{-2r(3)} + (1-P_3) e^{-2r(-5)} \\implies P_3 = \\frac{e^{10r} - 1}{e^{10r} - e^{-6r}} \\end{align}\\] Q: Brownian Bridge What is a Brownian bridge? What is the distribution of a Brownian Bridge? Why and how do we use it? A: Brownian Bridge In a Brownian motion the state variable, i.e. the stock price, FX rate, interest rate, is stochastic and evolves over a period of time in a random manner. The randomness is tied to the volatility of the asset and the drift is deterministic. In the short run, the volatility dominates the process and the asset price path is truly stochastic, i.e. random. However, over the long period of time the drift will dominate the volatility and therefore, if there are small errors in estimation of the drift it will lead to large fluctuations in the future price distribution. This is one of the drawbacks of a Brownian motion (as applied to the pricing of financial assets). Over longer horizons the drift of the stochastic process (Brownian motion) becomes a complicating factor. Therefore, a Brownian motion may not be very suitable for modelling an asset which has a longer maturity period, say, 5 years, 10 years, etc. and where the final state of the asset is known. Like a discount bond (Treasury bonds). A government bond can have maturities of 5 years, 10 years, 30 years and the final value of the bond is known, i.e. the par (face) value. And, a bond will always redeem at par. Besides Treasury and discount bonds, Brownian Bridges are also used to model Barrier options and other exotic options where the terminal value is known in advance. Monte Carlo pricing of continuous barrier options with Heston .","title":"Brownian Bridge"},{"location":"-Quant%20Interview%20Questions/2.%20Quant%20Researcher/3.3%20Quantitative%20Finance/3.3.1%20Brownian%20Motion/Martingale/","text":"Martingale Q: Brownian Motion Hitting Time Probability Suppose \\(dX_t = rdt + dW_t\\) , what is the probability that \\(X_t\\) hits 3 before hitting -5? A: Brownian Motion Hitting Time Probability Notice that the exponential martingale is defined as: \\[\\begin{align} e^{-\\frac{\\sigma^2}{2}t + \\sigma W_t} \\end{align}\\] Plug in \\(W_t = X_t - rt\\) , we have \\[\\begin{align} e^{-\\frac{\\sigma^2}{2}t + \\sigma (X_t - rt)} \\end{align}\\] Let \\(\\sigma = -2r\\) , we have \\[\\begin{align} e^{-\\frac{\\sigma^2}{2}t + \\sigma (X_t - rt)} = e^{-\\frac{(-2r)^2}{2}t - 2r (X_t - rt)} = e^{-2rX_t} \\end{align}\\] and \\(e^{-2rX_t}\\) is a martingale. Now, \\[\\begin{align} 1 = E[e^{-2rX_t}] = P_3 e^{-2r(3)} + (1-P_3) e^{-2r(-5)} \\implies P_3 = \\frac{e^{10r} - 1}{e^{10r} - e^{-6r}} \\end{align}\\] Q: Brownian Bridge What is a Brownian bridge? What is the distribution of a Brownian Bridge? Why and how do we use it? A: Brownian Bridge In a Brownian motion the state variable, i.e. the stock price, FX rate, interest rate, is stochastic and evolves over a period of time in a random manner. The randomness is tied to the volatility of the asset and the drift is deterministic. In the short run, the volatility dominates the process and the asset price path is truly stochastic, i.e. random. However, over the long period of time the drift will dominate the volatility and therefore, if there are small errors in estimation of the drift it will lead to large fluctuations in the future price distribution. This is one of the drawbacks of a Brownian motion (as applied to the pricing of financial assets). Over longer horizons the drift of the stochastic process (Brownian motion) becomes a complicating factor. Therefore, a Brownian motion may not be very suitable for modelling an asset which has a longer maturity period, say, 5 years, 10 years, etc. and where the final state of the asset is known. Like a discount bond (Treasury bonds). A government bond can have maturities of 5 years, 10 years, 30 years and the final value of the bond is known, i.e. the par (face) value. And, a bond will always redeem at par. Besides Treasury and discount bonds, Brownian Bridges are also used to model Barrier options and other exotic options where the terminal value is known in advance. Monte Carlo pricing of continuous barrier options with Heston .","title":"Martingale"},{"location":"-Quant%20Interview%20Questions/2.%20Quant%20Researcher/3.3%20Quantitative%20Finance/3.3.1%20Brownian%20Motion/Martingale/#martingale","text":"Q: Brownian Motion Hitting Time Probability Suppose \\(dX_t = rdt + dW_t\\) , what is the probability that \\(X_t\\) hits 3 before hitting -5? A: Brownian Motion Hitting Time Probability Notice that the exponential martingale is defined as: \\[\\begin{align} e^{-\\frac{\\sigma^2}{2}t + \\sigma W_t} \\end{align}\\] Plug in \\(W_t = X_t - rt\\) , we have \\[\\begin{align} e^{-\\frac{\\sigma^2}{2}t + \\sigma (X_t - rt)} \\end{align}\\] Let \\(\\sigma = -2r\\) , we have \\[\\begin{align} e^{-\\frac{\\sigma^2}{2}t + \\sigma (X_t - rt)} = e^{-\\frac{(-2r)^2}{2}t - 2r (X_t - rt)} = e^{-2rX_t} \\end{align}\\] and \\(e^{-2rX_t}\\) is a martingale. Now, \\[\\begin{align} 1 = E[e^{-2rX_t}] = P_3 e^{-2r(3)} + (1-P_3) e^{-2r(-5)} \\implies P_3 = \\frac{e^{10r} - 1}{e^{10r} - e^{-6r}} \\end{align}\\] Q: Brownian Bridge What is a Brownian bridge? What is the distribution of a Brownian Bridge? Why and how do we use it? A: Brownian Bridge In a Brownian motion the state variable, i.e. the stock price, FX rate, interest rate, is stochastic and evolves over a period of time in a random manner. The randomness is tied to the volatility of the asset and the drift is deterministic. In the short run, the volatility dominates the process and the asset price path is truly stochastic, i.e. random. However, over the long period of time the drift will dominate the volatility and therefore, if there are small errors in estimation of the drift it will lead to large fluctuations in the future price distribution. This is one of the drawbacks of a Brownian motion (as applied to the pricing of financial assets). Over longer horizons the drift of the stochastic process (Brownian motion) becomes a complicating factor. Therefore, a Brownian motion may not be very suitable for modelling an asset which has a longer maturity period, say, 5 years, 10 years, etc. and where the final state of the asset is known. Like a discount bond (Treasury bonds). A government bond can have maturities of 5 years, 10 years, 30 years and the final value of the bond is known, i.e. the par (face) value. And, a bond will always redeem at par. Besides Treasury and discount bonds, Brownian Bridges are also used to model Barrier options and other exotic options where the terminal value is known in advance. Monte Carlo pricing of continuous barrier options with Heston .","title":"Martingale"},{"location":"-Quant%20Interview%20Questions/3.%20Quant%20Trader%20%26%20Portfolio%20Manager/Examples/","text":"Examples Python 1 2 3 4 5 def bubble_sort ( items ): for i in range ( len ( items )): for j in range ( len ( items ) - 1 - i ): if items [ j ] > items [ j + 1 ]: items [ j ], items [ j + 1 ] = items [ j + 1 ], items [ j ] C++ 1 2 3 void f () { } The range () function is highlighted. Ex. 2.1 Suppose each of \\(K\\) -classes has associated target \\(t_k\\) , which is a vector of all zeros, except a one in the \\(k\\) -th position. Show that classifying to the largest of \\(\\hat y\\) amounts to choosing the closet target, \\(\\min_k\\|t_k-\\hat y\\|\\) , if the elements of \\(\\hat y\\) sum to one. asdfasd asdfasd Soln. 2.1 We need to prove: \\[\\begin{equation} \\underset{k}{\\operatorname{argmax}} \\hat y_k = \\underset{k}{\\operatorname{argmin}} \\|t_k-\\hat y\\|^2 \\label{eq:2-1a} \\end{equation}\\] By definition of \\(t_k\\) , we have \\[\\begin{align} \\|t_k-\\hat y\\|^2 &= (1-\\hat y_k)^2 + \\sum_{l \\neq k }(0 - \\hat y_l)^2\\nonumber\\\\ &= (1-\\hat y_k)^2 + \\sum_{l \\neq k }\\hat y_l^2 \\label{eq:2-1b} \\end{align}\\] Given \\(\\eqref{eq:2-1b}\\) , it's straightforward to see that \\(\\eqref{eq:2-1a}\\) indeed holds. Info The assumption \\(\\sum_{k=1}^K\\hat y_k=1\\) is actually not required. [CAPM]: Capital Asset Pricing Model asdfasdfasdfa asdfasd asdfasd adddasdfasdfasdfa asdfasd asdfasd adddasdfasdfasdfa asdfasd asdfasd addd asdfasdfasdfa asdfasd asdfasd addd asdfasdfasdfa asdfasd asdfasd addd Info The assumption \\(\\sum_{k=1}^K\\hat y_k=1\\) is actually not required. [CAPM]: Capital Asset Pricing Model Unordered list Sed sagittis eleifend rutrum Donec vitae suscipit est Nulla tempor lobortis orci Ordered list Sed sagittis eleifend rutrum Donec vitae suscipit est Nulla tempor lobortis orci Example Unordered List Example : 1 2 3 * Sed sagittis eleifend rutrum * Donec vitae suscipit est * Nulla tempor lobortis orci Result : Sed sagittis eleifend rutrum Donec vitae suscipit est Nulla tempor lobortis orci Ordered List Example : 1 2 3 1. Sed sagittis eleifend rutrum 2. Donec vitae suscipit est 3. Nulla tempor lobortis orci Result : Sed sagittis eleifend rutrum Donec vitae suscipit est Nulla tempor lobortis orci Method Description GET :material-check: Fetch resource PUT :material-check-all: Update resource DELETE :material-close: Delete resource Lorem ipsum 1 dolor sit amet, consectetur adipiscing elit. 2 Image caption Lorem ipsum dolor sit amet, consectetur adipiscing elit. \u21a9 Lorem ipsum dolor sit amet, consectetur adipiscing elit. Nulla et euismod nulla. Curabitur feugiat, tortor non consequat finibus, justo purus auctor massa, nec semper lorem quam in massa. \u21a9","title":"Examples"},{"location":"-Quant%20Interview%20Questions/3.%20Quant%20Trader%20%26%20Portfolio%20Manager/Examples/#examples","text":"Python 1 2 3 4 5 def bubble_sort ( items ): for i in range ( len ( items )): for j in range ( len ( items ) - 1 - i ): if items [ j ] > items [ j + 1 ]: items [ j ], items [ j + 1 ] = items [ j + 1 ], items [ j ] C++ 1 2 3 void f () { } The range () function is highlighted. Ex. 2.1 Suppose each of \\(K\\) -classes has associated target \\(t_k\\) , which is a vector of all zeros, except a one in the \\(k\\) -th position. Show that classifying to the largest of \\(\\hat y\\) amounts to choosing the closet target, \\(\\min_k\\|t_k-\\hat y\\|\\) , if the elements of \\(\\hat y\\) sum to one. asdfasd asdfasd Soln. 2.1 We need to prove: \\[\\begin{equation} \\underset{k}{\\operatorname{argmax}} \\hat y_k = \\underset{k}{\\operatorname{argmin}} \\|t_k-\\hat y\\|^2 \\label{eq:2-1a} \\end{equation}\\] By definition of \\(t_k\\) , we have \\[\\begin{align} \\|t_k-\\hat y\\|^2 &= (1-\\hat y_k)^2 + \\sum_{l \\neq k }(0 - \\hat y_l)^2\\nonumber\\\\ &= (1-\\hat y_k)^2 + \\sum_{l \\neq k }\\hat y_l^2 \\label{eq:2-1b} \\end{align}\\] Given \\(\\eqref{eq:2-1b}\\) , it's straightforward to see that \\(\\eqref{eq:2-1a}\\) indeed holds. Info The assumption \\(\\sum_{k=1}^K\\hat y_k=1\\) is actually not required. [CAPM]: Capital Asset Pricing Model asdfasdfasdfa asdfasd asdfasd adddasdfasdfasdfa asdfasd asdfasd adddasdfasdfasdfa asdfasd asdfasd addd asdfasdfasdfa asdfasd asdfasd addd asdfasdfasdfa asdfasd asdfasd addd Info The assumption \\(\\sum_{k=1}^K\\hat y_k=1\\) is actually not required. [CAPM]: Capital Asset Pricing Model Unordered list Sed sagittis eleifend rutrum Donec vitae suscipit est Nulla tempor lobortis orci Ordered list Sed sagittis eleifend rutrum Donec vitae suscipit est Nulla tempor lobortis orci Example Unordered List Example : 1 2 3 * Sed sagittis eleifend rutrum * Donec vitae suscipit est * Nulla tempor lobortis orci Result : Sed sagittis eleifend rutrum Donec vitae suscipit est Nulla tempor lobortis orci Ordered List Example : 1 2 3 1. Sed sagittis eleifend rutrum 2. Donec vitae suscipit est 3. Nulla tempor lobortis orci Result : Sed sagittis eleifend rutrum Donec vitae suscipit est Nulla tempor lobortis orci Method Description GET :material-check: Fetch resource PUT :material-check-all: Update resource DELETE :material-close: Delete resource Lorem ipsum 1 dolor sit amet, consectetur adipiscing elit. 2 Image caption Lorem ipsum dolor sit amet, consectetur adipiscing elit. \u21a9 Lorem ipsum dolor sit amet, consectetur adipiscing elit. Nulla et euismod nulla. Curabitur feugiat, tortor non consequat finibus, justo purus auctor massa, nec semper lorem quam in massa. \u21a9","title":"Examples"},{"location":"-Quant%20Interview%20Questions/3.%20Quant%20Trader%20%26%20Portfolio%20Manager/4.1%20Black-Scholes%20and%20Vanilla%20Options/","text":"Index","title":"Index"},{"location":"-Quant%20Interview%20Questions/3.%20Quant%20Trader%20%26%20Portfolio%20Manager/4.1%20Black-Scholes%20and%20Vanilla%20Options/#index","text":"","title":"Index"},{"location":"-Quant%20Interview%20Questions/3.%20Quant%20Trader%20%26%20Portfolio%20Manager/4.2%20Trading%20Strategies/","text":"Index","title":"Index"},{"location":"-Quant%20Interview%20Questions/3.%20Quant%20Trader%20%26%20Portfolio%20Manager/4.2%20Trading%20Strategies/#index","text":"","title":"Index"},{"location":"-Quant%20Interview%20Questions/3.%20Quant%20Trader%20%26%20Portfolio%20Manager/4.3%20Markets%20and%20Execution/","text":"Index","title":"Index"},{"location":"-Quant%20Interview%20Questions/3.%20Quant%20Trader%20%26%20Portfolio%20Manager/4.3%20Markets%20and%20Execution/#index","text":"","title":"Index"},{"location":"-Quant%20Interview%20Questions/3.%20Quant%20Trader%20%26%20Portfolio%20Manager/5.1%20Portfolio%20Optimization/","text":"Index","title":"Index"},{"location":"-Quant%20Interview%20Questions/3.%20Quant%20Trader%20%26%20Portfolio%20Manager/5.1%20Portfolio%20Optimization/#index","text":"","title":"Index"},{"location":"-Quant%20Interview%20Questions/3.%20Quant%20Trader%20%26%20Portfolio%20Manager/5.2%20Running%20the%20Business/","text":"Index","title":"Index"},{"location":"-Quant%20Interview%20Questions/3.%20Quant%20Trader%20%26%20Portfolio%20Manager/5.2%20Running%20the%20Business/#index","text":"","title":"Index"},{"location":"0.%20Basics/","text":"Introduction Software Engineering","title":"Introduction"},{"location":"0.%20Basics/#introduction","text":"Software Engineering","title":"Introduction"},{"location":"1.%20Quant%20Developer/","text":"Introduction Software Engineering","title":"Introduction"},{"location":"1.%20Quant%20Developer/#introduction","text":"Software Engineering","title":"Introduction"},{"location":"1.%20Quant%20Developer/1.%20C%2B%2B/Index/","text":"C++","title":"C++"},{"location":"1.%20Quant%20Developer/1.%20C%2B%2B/Index/#c","text":"","title":"C++"},{"location":"1.%20Quant%20Developer/2.%20Java/Index/","text":"Java","title":"Java"},{"location":"1.%20Quant%20Developer/2.%20Java/Index/#java","text":"","title":"Java"},{"location":"1.%20Quant%20Developer/3.%20Python/Meta%20Programming/","text":"Python Meta Programming There are five main meta programming techniques in Python: At load-time: - Operator overloading - Decorator - Metaclass - Descriptor and Property - Import hook At run-time: - compile - Monkey Patch and Hot Patch Import Hooks Whenever you use an import statement, it is equivalent to: 1 os = __import__ ( \"os\" ) First, it check sys.modules , a dict containing already-loaded modules, just in case we've already imported the requested module. Next, if sys.meta_path list is not empty, then every meta importer hook in it will be queried. Finally, it checks sys.path , a list containing filesystem paths for Python to search for potential modules. It is at the second step that we will be able to intercept. To do this, we'll need to crate a meta path finder , which has a single public method find_spec , and add it to sys.meta_path . 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 import importlib.abc import importlib.machinery class DependencyInjectorFinder ( importlib . abc . MetaPathFinder ): def __init__ ( self , loader ): # we'll write the loader in a minute, hang tight self . _loader = loader def find_spec ( self , fullname , path , target = None ): \"\"\"Attempt to locate the requested module fullname is the fully-qualified name of the module, path is set to __path__ for sub-modules/packages, or None otherwise. target can be a module object, but is unused in this example. \"\"\" if self . _loader . provides ( fullname ): return self . _gen_spec ( fullname ) def _gen_spec ( self , fullname ): spec = importlib . machinery . ModuleSpec ( fullname , self . _loader ) return spec # we'll also add it to sys.meta_path later If a meta path finder provides the requested module, then it should return an instance of the importlib.machinery.ModuleSpec class, which is a fairly simple affair with a small handful of attributes that lets Python's import machinery know what it needs to know to take the next steps in importing the module the user requested. For our purposes, we're interested in two attributes (the only required ones): ModuleSpec.name, which is the name of the requested module, and ModuleSpec.loader, which is the loader object that Python should use to actually load the module - you'll notice the self._loader lines above that reference a loader object, as well. A loader object is a very simple class with two required methods in Python: create_module , which takes a ModuleSpec as its sole argument and returns an object that Python will consider to be the new module, and exec_module , which takes the new module as its sole argument and executes it. 1 2 3 4 5 class Loader ( importlib . abc . Loader ): def create_module ( self , spec ): raise NotImplementedError def exec_module ( self , module ): raise NotImplementedError","title":"Python Meta Programming"},{"location":"1.%20Quant%20Developer/3.%20Python/Meta%20Programming/#python-meta-programming","text":"There are five main meta programming techniques in Python: At load-time: - Operator overloading - Decorator - Metaclass - Descriptor and Property - Import hook At run-time: - compile - Monkey Patch and Hot Patch","title":"Python Meta Programming"},{"location":"1.%20Quant%20Developer/3.%20Python/Meta%20Programming/#import-hooks","text":"Whenever you use an import statement, it is equivalent to: 1 os = __import__ ( \"os\" ) First, it check sys.modules , a dict containing already-loaded modules, just in case we've already imported the requested module. Next, if sys.meta_path list is not empty, then every meta importer hook in it will be queried. Finally, it checks sys.path , a list containing filesystem paths for Python to search for potential modules. It is at the second step that we will be able to intercept. To do this, we'll need to crate a meta path finder , which has a single public method find_spec , and add it to sys.meta_path . 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 import importlib.abc import importlib.machinery class DependencyInjectorFinder ( importlib . abc . MetaPathFinder ): def __init__ ( self , loader ): # we'll write the loader in a minute, hang tight self . _loader = loader def find_spec ( self , fullname , path , target = None ): \"\"\"Attempt to locate the requested module fullname is the fully-qualified name of the module, path is set to __path__ for sub-modules/packages, or None otherwise. target can be a module object, but is unused in this example. \"\"\" if self . _loader . provides ( fullname ): return self . _gen_spec ( fullname ) def _gen_spec ( self , fullname ): spec = importlib . machinery . ModuleSpec ( fullname , self . _loader ) return spec # we'll also add it to sys.meta_path later If a meta path finder provides the requested module, then it should return an instance of the importlib.machinery.ModuleSpec class, which is a fairly simple affair with a small handful of attributes that lets Python's import machinery know what it needs to know to take the next steps in importing the module the user requested. For our purposes, we're interested in two attributes (the only required ones): ModuleSpec.name, which is the name of the requested module, and ModuleSpec.loader, which is the loader object that Python should use to actually load the module - you'll notice the self._loader lines above that reference a loader object, as well. A loader object is a very simple class with two required methods in Python: create_module , which takes a ModuleSpec as its sole argument and returns an object that Python will consider to be the new module, and exec_module , which takes the new module as its sole argument and executes it. 1 2 3 4 5 class Loader ( importlib . abc . Loader ): def create_module ( self , spec ): raise NotImplementedError def exec_module ( self , module ): raise NotImplementedError","title":"Import Hooks"},{"location":"1.%20Quant%20Developer/Design%20Patterns/","text":"Design Patterns","title":"Design Patterns"},{"location":"1.%20Quant%20Developer/Design%20Patterns/#design-patterns","text":"","title":"Design Patterns"},{"location":"2.%20Quant%20Researcher/Index/","text":"Kaggle","title":"Kaggle"},{"location":"2.%20Quant%20Researcher/Index/#kaggle","text":"","title":"Kaggle"},{"location":"2.%20Quant%20Researcher/Optimization/","text":"Introduction Software Engineering","title":"Introduction"},{"location":"2.%20Quant%20Researcher/Optimization/#introduction","text":"Software Engineering","title":"Introduction"},{"location":"3.%20Quant%20Trader%20%26%20Portfolio%20Manager/","text":"Introduction Software Engineering","title":"Introduction"},{"location":"3.%20Quant%20Trader%20%26%20Portfolio%20Manager/#introduction","text":"Software Engineering","title":"Introduction"},{"location":"LeetCode%20%26%20Kaggle/0.%20Index/","text":"Introduction Google C++ Style Guide OI Wiki \u6d1b\u8c37 \u7a0b\u5e8f\u8bbe\u8ba1\u7ade\u8d5b\u8fdb\u9636\u8bad\u7ec3\u6307\u5357 labuladong\u7b97\u6cd5\u5c0f\u6284","title":"Introduction"},{"location":"LeetCode%20%26%20Kaggle/0.%20Index/#introduction","text":"Google C++ Style Guide OI Wiki \u6d1b\u8c37 \u7a0b\u5e8f\u8bbe\u8ba1\u7ade\u8d5b\u8fdb\u9636\u8bad\u7ec3\u6307\u5357 labuladong\u7b97\u6cd5\u5c0f\u6284","title":"Introduction"},{"location":"LeetCode%20%26%20Kaggle/LeetCode/Adhoc/","text":"Adhoc (1) Introduction Adhoc problems. Problems (0, 1, 0) LC73. Set Matrix Zeroes (Medium) LC73. Set Matrix Zeroes (Medium) Info LC73. Set Matrix Zeroes (Medium) Algorithm: Adhoc Time Complexity: \\(O(n^2)\\) Space Complexity: \\(O(1)\\) Solution This is an Adhoc problem. Adhoc \\(O(n^2)\\) Python 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 class Solution : def setZeroes ( self , matrix : List [ List [ int ]]) -> None : \"\"\" Do not return anything, modify matrix in-place instead. \"\"\" # pre-processing to check the first row and the first column firstRowHasZero = any ([ matrix [ 0 ][ j ] == 0 for j in range ( len ( matrix [ 0 ]))]) firstColHasZero = any ([ matrix [ i ][ 0 ] == 0 for i in range ( len ( matrix ))]) # KEY: check each element and record the results in the first row and the first column for i in range ( len ( matrix )): for j in range ( len ( matrix [ 0 ])): if matrix [ i ][ j ] == 0 : matrix [ i ][ 0 ] = matrix [ 0 ][ j ] = 0 # sweep for i in range ( 1 , len ( matrix )): # starts from 1, not 0 if matrix [ i ][ 0 ] == 0 : for j in range ( len ( matrix [ 0 ])): matrix [ i ][ j ] = 0 for j in range ( 1 , len ( matrix [ 0 ])): # starts from 1, not 0 if matrix [ 0 ][ j ] == 0 : for i in range ( len ( matrix )): matrix [ i ][ j ] = 0 # post-processing if firstColHasZero : for i in range ( len ( matrix )): matrix [ i ][ 0 ] = 0 if firstRowHasZero : for j in range ( len ( matrix [ 0 ])): matrix [ 0 ][ j ] = 0","title":"Adhoc (1)"},{"location":"LeetCode%20%26%20Kaggle/LeetCode/Adhoc/#adhoc-1","text":"","title":"Adhoc (1)"},{"location":"LeetCode%20%26%20Kaggle/LeetCode/Adhoc/#introduction","text":"Adhoc problems.","title":"Introduction"},{"location":"LeetCode%20%26%20Kaggle/LeetCode/Adhoc/#problems-0-1-0","text":"","title":"Problems (0, 1, 0)"},{"location":"LeetCode%20%26%20Kaggle/LeetCode/Adhoc/#lc73-set-matrix-zeroes-medium","text":"LC73. Set Matrix Zeroes (Medium) Info LC73. Set Matrix Zeroes (Medium) Algorithm: Adhoc Time Complexity: \\(O(n^2)\\) Space Complexity: \\(O(1)\\) Solution This is an Adhoc problem. Adhoc \\(O(n^2)\\) Python 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 class Solution : def setZeroes ( self , matrix : List [ List [ int ]]) -> None : \"\"\" Do not return anything, modify matrix in-place instead. \"\"\" # pre-processing to check the first row and the first column firstRowHasZero = any ([ matrix [ 0 ][ j ] == 0 for j in range ( len ( matrix [ 0 ]))]) firstColHasZero = any ([ matrix [ i ][ 0 ] == 0 for i in range ( len ( matrix ))]) # KEY: check each element and record the results in the first row and the first column for i in range ( len ( matrix )): for j in range ( len ( matrix [ 0 ])): if matrix [ i ][ j ] == 0 : matrix [ i ][ 0 ] = matrix [ 0 ][ j ] = 0 # sweep for i in range ( 1 , len ( matrix )): # starts from 1, not 0 if matrix [ i ][ 0 ] == 0 : for j in range ( len ( matrix [ 0 ])): matrix [ i ][ j ] = 0 for j in range ( 1 , len ( matrix [ 0 ])): # starts from 1, not 0 if matrix [ 0 ][ j ] == 0 : for i in range ( len ( matrix )): matrix [ i ][ j ] = 0 # post-processing if firstColHasZero : for i in range ( len ( matrix )): matrix [ i ][ 0 ] = 0 if firstRowHasZero : for j in range ( len ( matrix [ 0 ])): matrix [ 0 ][ j ] = 0","title":"LC73. Set Matrix Zeroes (Medium)"},{"location":"LeetCode%20%26%20Kaggle/LeetCode/Binary%20Search/","text":"Binary Search (3) Introduction Binary search is an algorithm that finds a target number in a sorted array in \\(O(\\log n)\\) time. Python 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 def binarySearch ( arr , target ): left , right = 0 , len ( arr ) - 1 while left <= right : mid = ( left + right ) // 2 if target == arr [ mid ]: return mid elif target < arr [ mid ]: right = mid - 1 else : left = mid + 1 return - 1 arr = [ 1 , 2 , 3 , 4 , 5 ] for n in range ( 0 , 7 ): print ( f ' { n } : { binarySearch ( arr , n ) } ' ) C++ 1 2 3 int binarySearch () { } Java 1 Problems (0, 3, 0) LC704. Binary Search (Easy) LC704. Binary Search (Easy) Info LC704. Binary Search (Easy) Algorithm: Binary Search Time Complexity: \\(O(\\log n)\\) Space Complexity: \\(O(1)\\) Solution This is a standard binary search problem. Binary Search O(n) Python 1 2 3 4 5 6 7 8 9 10 11 12 13 class Solution : def search ( self , nums : List [ int ], target : int ) -> int : left , right = 0 , len ( nums ) - 1 while left <= right : mid = ( left + right ) // 2 if target == nums [ mid ]: return mid elif target < nums [ mid ]: right = mid - 1 else : left = mid + 1 return - 1 LC1011. Capacity To Ship Packages Within D Days (Medium) LC1011. Capacity To Ship Packages Within D Days (Medium) Info LC1011. Capacity To Ship Packages Within D Days (Medium) Algorithm: Binary Search Time Complexity: \\(O(n\\log(S))\\) , where \\(S\\) is the sum of all weights. Space Complexity: \\(O(1)\\) Solution Binary search for the \\(\\mbox{capacity} \\in [max(weights), sum(weights)]\\) . For each of these \\(O(\\log n)\\) capacity, it costs \\(O(n)\\) to check if the plan can be delivered. Total cost is thus \\(O(n \\log n)\\) . Binary Search \\(O(n\\log(S))\\) Python 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 class Solution : def canDeliver ( self , weights , capacity , days ) -> bool : i = 0 for d in range ( days ): load = 0 while load <= capacity and i < len ( weights ): load += weights [ i ] i += 1 if load > capacity : load -= weights [ i - 1 ] i -= 1 elif i >= len ( weights ): return True return False def shipWithinDays ( self , weights : List [ int ], days : int ) -> int : minCap , maxCap = max ( weights ), sum ( weights ) while minCap <= maxCap : capacity = ( minCap + maxCap ) // 2 if self . canDeliver ( weights , capacity , days ): maxCap = capacity - 1 else : minCap = capacity + 1 return minCap LC1642. Furthest Building You Can Reach (Medium) LC1642. Furthest Building You Can Reach (Medium) Info 1642. Furthest Building You Can Reach (Medium) Algorithm: Binary Search Time Complexity: \\(O(n\\log n)\\) Space Complexity: \\(O(1)\\) Solution Binary search to propose the furthest building you try to reach, which costs \\(O(\\log n)\\) . Within each proposal, it takes \\(O(n)\\) to check if you are indeed able to finish. Total cost is thus \\(O(n \\log n)\\) . Binary Search \\(O(n\\log n)\\) Python 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 class Solution : def canFinish ( self , heights , bricks , ladders ) -> bool : steps = sorted ([ heights [ i ] - heights [ i - 1 ] for i in range ( 1 , len ( heights )) if heights [ i ] - heights [ i - 1 ] > 0 ]) if not steps : return True if ladders == 0 : return bricks >= sum ( steps ) return bricks >= sum ( steps [: - ladders ]) def furthestBuilding ( self , heights : List [ int ], bricks : int , ladders : int ) -> int : left , right = 0 , len ( heights ) - 1 while left <= right : mid = ( left + right ) // 2 if self . canFinish ( heights [: mid + 1 ], bricks , ladders ): left = mid + 1 else : right = mid - 1 return max ( 0 , right ) LC34. Find First and Last Position of Element in Sorted Array (Medium) LC34. Find First and Last Position of Element in Sorted Array (Medium) Info LC34. Find First and Last Position of Element in Sorted Array (Medium) Algorithm: Binary Search Time Complexity: \\(O(\\log n)\\) Space Complexity: \\(O(1)\\) Solution Main Method O(n) Python 1","title":"Binary Search (3)"},{"location":"LeetCode%20%26%20Kaggle/LeetCode/Binary%20Search/#binary-search-3","text":"","title":"Binary Search (3)"},{"location":"LeetCode%20%26%20Kaggle/LeetCode/Binary%20Search/#introduction","text":"Binary search is an algorithm that finds a target number in a sorted array in \\(O(\\log n)\\) time. Python 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 def binarySearch ( arr , target ): left , right = 0 , len ( arr ) - 1 while left <= right : mid = ( left + right ) // 2 if target == arr [ mid ]: return mid elif target < arr [ mid ]: right = mid - 1 else : left = mid + 1 return - 1 arr = [ 1 , 2 , 3 , 4 , 5 ] for n in range ( 0 , 7 ): print ( f ' { n } : { binarySearch ( arr , n ) } ' ) C++ 1 2 3 int binarySearch () { } Java 1","title":"Introduction"},{"location":"LeetCode%20%26%20Kaggle/LeetCode/Binary%20Search/#problems-0-3-0","text":"","title":"Problems (0, 3, 0)"},{"location":"LeetCode%20%26%20Kaggle/LeetCode/Binary%20Search/#lc704-binary-search-easy","text":"LC704. Binary Search (Easy) Info LC704. Binary Search (Easy) Algorithm: Binary Search Time Complexity: \\(O(\\log n)\\) Space Complexity: \\(O(1)\\) Solution This is a standard binary search problem. Binary Search O(n) Python 1 2 3 4 5 6 7 8 9 10 11 12 13 class Solution : def search ( self , nums : List [ int ], target : int ) -> int : left , right = 0 , len ( nums ) - 1 while left <= right : mid = ( left + right ) // 2 if target == nums [ mid ]: return mid elif target < nums [ mid ]: right = mid - 1 else : left = mid + 1 return - 1","title":"LC704. Binary Search (Easy)"},{"location":"LeetCode%20%26%20Kaggle/LeetCode/Binary%20Search/#lc1011-capacity-to-ship-packages-within-d-days-medium","text":"LC1011. Capacity To Ship Packages Within D Days (Medium) Info LC1011. Capacity To Ship Packages Within D Days (Medium) Algorithm: Binary Search Time Complexity: \\(O(n\\log(S))\\) , where \\(S\\) is the sum of all weights. Space Complexity: \\(O(1)\\) Solution Binary search for the \\(\\mbox{capacity} \\in [max(weights), sum(weights)]\\) . For each of these \\(O(\\log n)\\) capacity, it costs \\(O(n)\\) to check if the plan can be delivered. Total cost is thus \\(O(n \\log n)\\) . Binary Search \\(O(n\\log(S))\\) Python 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 class Solution : def canDeliver ( self , weights , capacity , days ) -> bool : i = 0 for d in range ( days ): load = 0 while load <= capacity and i < len ( weights ): load += weights [ i ] i += 1 if load > capacity : load -= weights [ i - 1 ] i -= 1 elif i >= len ( weights ): return True return False def shipWithinDays ( self , weights : List [ int ], days : int ) -> int : minCap , maxCap = max ( weights ), sum ( weights ) while minCap <= maxCap : capacity = ( minCap + maxCap ) // 2 if self . canDeliver ( weights , capacity , days ): maxCap = capacity - 1 else : minCap = capacity + 1 return minCap","title":"LC1011. Capacity To Ship Packages Within D Days (Medium)"},{"location":"LeetCode%20%26%20Kaggle/LeetCode/Binary%20Search/#lc1642-furthest-building-you-can-reach-medium","text":"LC1642. Furthest Building You Can Reach (Medium) Info 1642. Furthest Building You Can Reach (Medium) Algorithm: Binary Search Time Complexity: \\(O(n\\log n)\\) Space Complexity: \\(O(1)\\) Solution Binary search to propose the furthest building you try to reach, which costs \\(O(\\log n)\\) . Within each proposal, it takes \\(O(n)\\) to check if you are indeed able to finish. Total cost is thus \\(O(n \\log n)\\) . Binary Search \\(O(n\\log n)\\) Python 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 class Solution : def canFinish ( self , heights , bricks , ladders ) -> bool : steps = sorted ([ heights [ i ] - heights [ i - 1 ] for i in range ( 1 , len ( heights )) if heights [ i ] - heights [ i - 1 ] > 0 ]) if not steps : return True if ladders == 0 : return bricks >= sum ( steps ) return bricks >= sum ( steps [: - ladders ]) def furthestBuilding ( self , heights : List [ int ], bricks : int , ladders : int ) -> int : left , right = 0 , len ( heights ) - 1 while left <= right : mid = ( left + right ) // 2 if self . canFinish ( heights [: mid + 1 ], bricks , ladders ): left = mid + 1 else : right = mid - 1 return max ( 0 , right )","title":"LC1642. Furthest Building You Can Reach (Medium)"},{"location":"LeetCode%20%26%20Kaggle/LeetCode/Binary%20Search/#lc34-find-first-and-last-position-of-element-in-sorted-array-medium","text":"LC34. Find First and Last Position of Element in Sorted Array (Medium) Info LC34. Find First and Last Position of Element in Sorted Array (Medium) Algorithm: Binary Search Time Complexity: \\(O(\\log n)\\) Space Complexity: \\(O(1)\\) Solution Main Method O(n) Python 1","title":"LC34. Find First and Last Position of Element in Sorted Array (Medium)"},{"location":"LeetCode%20%26%20Kaggle/LeetCode/Heap/","text":"Heap (1) Introduction Heap. Problems (0, 1, 0) LC659. Split Array into Consecutive Subsequences (Medium) LC659. Split Array into Consecutive Subsequences (Medium) Info LC659. Split Array into Consecutive Subsequences (Medium) Algorithm: Heap Time Complexity: Space Complexity: Solution Adhoc \\(O(n^2)\\) Python 1","title":"Heap (1)"},{"location":"LeetCode%20%26%20Kaggle/LeetCode/Heap/#heap-1","text":"","title":"Heap (1)"},{"location":"LeetCode%20%26%20Kaggle/LeetCode/Heap/#introduction","text":"Heap.","title":"Introduction"},{"location":"LeetCode%20%26%20Kaggle/LeetCode/Heap/#problems-0-1-0","text":"","title":"Problems (0, 1, 0)"},{"location":"LeetCode%20%26%20Kaggle/LeetCode/Heap/#lc659-split-array-into-consecutive-subsequences-medium","text":"LC659. Split Array into Consecutive Subsequences (Medium) Info LC659. Split Array into Consecutive Subsequences (Medium) Algorithm: Heap Time Complexity: Space Complexity: Solution Adhoc \\(O(n^2)\\) Python 1","title":"LC659. Split Array into Consecutive Subsequences (Medium)"},{"location":"LeetCode%20%26%20Kaggle/LeetCode/Monotonic%20Stack/","text":"Monotonic Stack (0) Introduction Monotonic stack is a data structure that is able to find the nearest event (not the furthest ) for each of the \\(n\\) elements in an array of size \\(n\\) in \\(O(n)\\) time and \\(O(1)\\) space. Python 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 # # Monotonic stack to find the next bigger number. # def monotonicStack ( arr ): firstHigherValue = [ '#' ] * len ( arr ) stack = [] for i , n in enumerate ( arr ): while stack and n > stack [ - 1 ][ 1 ]: idx , value = stack . pop () # do something with (idx, value) firstHigherValue [ idx ] = n stack . append (( i , n )) return firstHigherValue arr = [ 1 , 3 , 4 , 6 , 2 , 1 , 4 , 5 ] print ( monotonicStack ( arr )) C++ 1 2 3 int binarySearch () { } Java 1 Problems (0, 0, 0)","title":"Monotonic Stack (0)"},{"location":"LeetCode%20%26%20Kaggle/LeetCode/Monotonic%20Stack/#monotonic-stack-0","text":"","title":"Monotonic Stack (0)"},{"location":"LeetCode%20%26%20Kaggle/LeetCode/Monotonic%20Stack/#introduction","text":"Monotonic stack is a data structure that is able to find the nearest event (not the furthest ) for each of the \\(n\\) elements in an array of size \\(n\\) in \\(O(n)\\) time and \\(O(1)\\) space. Python 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 # # Monotonic stack to find the next bigger number. # def monotonicStack ( arr ): firstHigherValue = [ '#' ] * len ( arr ) stack = [] for i , n in enumerate ( arr ): while stack and n > stack [ - 1 ][ 1 ]: idx , value = stack . pop () # do something with (idx, value) firstHigherValue [ idx ] = n stack . append (( i , n )) return firstHigherValue arr = [ 1 , 3 , 4 , 6 , 2 , 1 , 4 , 5 ] print ( monotonicStack ( arr )) C++ 1 2 3 int binarySearch () { } Java 1","title":"Introduction"},{"location":"LeetCode%20%26%20Kaggle/LeetCode/Monotonic%20Stack/#problems-0-0-0","text":"","title":"Problems (0, 0, 0)"},{"location":"LeetCode%20%26%20Kaggle/LeetCode/Tree/","text":"Tree (2) Introduction Problems (0, 2, 0) LC654. Maximum Binary Tree (Medium) LC654. Maximum Binary Tree (Medium) Info LC654. Maximum Binary Tree (Medium) Algorithm: DFS (Recursion) Time Complexity: \\(O(n)\\) Space Complexity: \\(O(1)\\) Solution This is a standard DFS (Recursion) problem. DFS O(n) Python 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 class Solution : def constructMaximumBinaryTree ( self , nums : List [ int ]) -> TreeNode : if not len ( nums ): return None maxIdx , maxN = 0 , nums [ 0 ] for i , n in enumerate ( nums ): if n > maxN : maxIdx = i maxN = n left = self . constructMaximumBinaryTree ( nums [: maxIdx ]) right = self . constructMaximumBinaryTree ( nums [ maxIdx + 1 :]) return TreeNode ( maxN , left , right ) LC1519. Number of Nodes in the Sub-Tree With the Same Label (Medium) LC1519. Number of Nodes in the Sub-Tree With the Same Label (Medium) Info LC1519. Number of Nodes in the Sub-Tree With the Same Label (Medium) Algorithm: Time Complexity: Space Complexity: Solution DFS O(n) Python 1","title":"Tree (2)"},{"location":"LeetCode%20%26%20Kaggle/LeetCode/Tree/#tree-2","text":"","title":"Tree (2)"},{"location":"LeetCode%20%26%20Kaggle/LeetCode/Tree/#introduction","text":"","title":"Introduction"},{"location":"LeetCode%20%26%20Kaggle/LeetCode/Tree/#problems-0-2-0","text":"","title":"Problems (0, 2, 0)"},{"location":"LeetCode%20%26%20Kaggle/LeetCode/Tree/#lc654-maximum-binary-tree-medium","text":"LC654. Maximum Binary Tree (Medium) Info LC654. Maximum Binary Tree (Medium) Algorithm: DFS (Recursion) Time Complexity: \\(O(n)\\) Space Complexity: \\(O(1)\\) Solution This is a standard DFS (Recursion) problem. DFS O(n) Python 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 class Solution : def constructMaximumBinaryTree ( self , nums : List [ int ]) -> TreeNode : if not len ( nums ): return None maxIdx , maxN = 0 , nums [ 0 ] for i , n in enumerate ( nums ): if n > maxN : maxIdx = i maxN = n left = self . constructMaximumBinaryTree ( nums [: maxIdx ]) right = self . constructMaximumBinaryTree ( nums [ maxIdx + 1 :]) return TreeNode ( maxN , left , right )","title":"LC654. Maximum Binary Tree (Medium)"},{"location":"LeetCode%20%26%20Kaggle/LeetCode/Tree/#lc1519-number-of-nodes-in-the-sub-tree-with-the-same-label-medium","text":"LC1519. Number of Nodes in the Sub-Tree With the Same Label (Medium) Info LC1519. Number of Nodes in the Sub-Tree With the Same Label (Medium) Algorithm: Time Complexity: Space Complexity: Solution DFS O(n) Python 1","title":"LC1519. Number of Nodes in the Sub-Tree With the Same Label (Medium)"},{"location":"Trading%20Strategies/Algorithmic%20Trading/","text":"Algorithmic Trading In 1971, the Financial Industry Regulatory Authority (FINRA), created a revolutionary exchange called the National Association of Securities Dealers Automated Quotations (NASDAQ), which was the world's first electronic stock market. Today, algorithmic trading represents over two thirds of all market transactions. There are two main strategies in algorithmic trading: statistical arbitrage and latency arbitrage . Statistical arbitrage derives its advantage from the strength of its models while latency arbitrage derives its advantage from its speed . Statistical arbitrage is generally justified to be able to correct market mispricings and make the market more efficient. On the contrary, latency arbitrage is ethically questionable and debateable as it essentially is to forerun other market participants. For example, there are three well-known malicious strategies: Predatory Trading Predatory trading is the HFT equivalent of the illegal practice of front-running. For example, if a broker receives an order from a client to buy 100,000 shares of security S at $20.00, he may 1) buy security S at $20.00 and keep it in his personal account, 2) execute his client's order, and 3) sell the shares in his personal account after the price has been driven up. This is unethical because, first, the trader is trading using non-public information; and secondly, he is negatively impacting his client's order via slippage. For example, there are four nearby exchanges in New York: BATS, Diret Edge, NASDAQ, and the NYSE. The difference between arriving at the first exchange, BATS, and the last exchange, NYSE, is about 2 milliseconds. However, HFT firms can travel among all these exchanges in as little as 476 microseconds. Thus, the HFT firm can buy all the shares in the market and sell it at a higher price to the buyer. Stop-Loss Tripping Suppose the HFT firm pays its broker to have access to their order books. In particular, if we know that there are stop loss orders at $40.00, $37.50, and $36.00. We can short the stock to trigger $40, can pressure the stock to a flash-crash, then we cover our short positions possibly at $36.00 and take the profit. Order Spoofing This strategy involves submitting disingenuous orders to trick other traders. The HFT firm places a large amount of overpriced buying orders, and at the same time has had bullish option positions. When other slower participants have created illustrations for themselves that the stock prices are going up and followed by placing large amounts of reasonablely higher buying orders, the HFT firm would withdraw their buying orders and gain profit through the bullish option positions. In September 2016, a new exchange called Investors Exchange (IEX) received approval from the SEC and will be the first transparent exchange where malicious latency arbitrage strategies are no longer possible.","title":"Algorithmic Trading"},{"location":"Trading%20Strategies/Algorithmic%20Trading/#algorithmic-trading","text":"In 1971, the Financial Industry Regulatory Authority (FINRA), created a revolutionary exchange called the National Association of Securities Dealers Automated Quotations (NASDAQ), which was the world's first electronic stock market. Today, algorithmic trading represents over two thirds of all market transactions. There are two main strategies in algorithmic trading: statistical arbitrage and latency arbitrage . Statistical arbitrage derives its advantage from the strength of its models while latency arbitrage derives its advantage from its speed . Statistical arbitrage is generally justified to be able to correct market mispricings and make the market more efficient. On the contrary, latency arbitrage is ethically questionable and debateable as it essentially is to forerun other market participants. For example, there are three well-known malicious strategies:","title":"Algorithmic Trading"},{"location":"Trading%20Strategies/Algorithmic%20Trading/#predatory-trading","text":"Predatory trading is the HFT equivalent of the illegal practice of front-running. For example, if a broker receives an order from a client to buy 100,000 shares of security S at $20.00, he may 1) buy security S at $20.00 and keep it in his personal account, 2) execute his client's order, and 3) sell the shares in his personal account after the price has been driven up. This is unethical because, first, the trader is trading using non-public information; and secondly, he is negatively impacting his client's order via slippage. For example, there are four nearby exchanges in New York: BATS, Diret Edge, NASDAQ, and the NYSE. The difference between arriving at the first exchange, BATS, and the last exchange, NYSE, is about 2 milliseconds. However, HFT firms can travel among all these exchanges in as little as 476 microseconds. Thus, the HFT firm can buy all the shares in the market and sell it at a higher price to the buyer.","title":"Predatory Trading"},{"location":"Trading%20Strategies/Algorithmic%20Trading/#stop-loss-tripping","text":"Suppose the HFT firm pays its broker to have access to their order books. In particular, if we know that there are stop loss orders at $40.00, $37.50, and $36.00. We can short the stock to trigger $40, can pressure the stock to a flash-crash, then we cover our short positions possibly at $36.00 and take the profit.","title":"Stop-Loss Tripping"},{"location":"Trading%20Strategies/Algorithmic%20Trading/#order-spoofing","text":"This strategy involves submitting disingenuous orders to trick other traders. The HFT firm places a large amount of overpriced buying orders, and at the same time has had bullish option positions. When other slower participants have created illustrations for themselves that the stock prices are going up and followed by placing large amounts of reasonablely higher buying orders, the HFT firm would withdraw their buying orders and gain profit through the bullish option positions. In September 2016, a new exchange called Investors Exchange (IEX) received approval from the SEC and will be the first transparent exchange where malicious latency arbitrage strategies are no longer possible.","title":"Order Spoofing"},{"location":"_About/","text":"Markdown Examples \\[ \\underbrace{\\bA}_{=0} = 0 \\] Python 1 2 3 4 5 def bubble_sort ( items ): for i in range ( len ( items )): for j in range ( len ( items ) - 1 - i ): if items [ j ] > items [ j + 1 ]: items [ j ], items [ j + 1 ] = items [ j + 1 ], items [ j ] C++ 1 2 3 void f () { } The range () function is highlighted. Ex. 2.1 Suppose each of \\(K\\) -classes has associated target \\(t_k\\) , which is a vector of all zeros, except a one in the \\(k\\) -th position. Show that classifying to the largest of \\(\\hat y\\) amounts to choosing the closet target, \\(\\min_k\\|t_k-\\hat y\\|\\) , if the elements of \\(\\hat y\\) sum to one. Soln. 2.1 We need to prove: \\[\\begin{equation} \\underset{k}{\\operatorname{argmax}} \\hat y_k = \\underset{k}{\\operatorname{argmin}} \\|t_k-\\hat y\\|^2 \\label{eq:2-1a} \\end{equation}\\] By definition of \\(t_k\\) , we have \\[\\begin{align} \\|t_k-\\hat y\\|^2 &= (1-\\hat y_k)^2 + \\sum_{l \\neq k }(0 - \\hat y_l)^2\\nonumber\\\\ &= (1-\\hat y_k)^2 + \\sum_{l \\neq k }\\hat y_l^2 \\label{eq:2-1b} \\end{align}\\] Given \\(\\eqref{eq:2-1b}\\) , it's straightforward to see that \\(\\eqref{eq:2-1a}\\) indeed holds. Python 1 2 3 4 5 def bubble_sort ( items ): for i in range ( len ( items )): for j in range ( len ( items ) - 1 - i ): if items [ j ] > items [ j + 1 ]: items [ j ], items [ j + 1 ] = items [ j + 1 ], items [ j ] C++ 1 2 3 void f () { } The range () function is highlighted. Info The assumption \\(\\sum_{k=1}^K\\hat y_k=1\\) is actually not required. [ CAPM ]: Capital Asset Pricing Model asdfasdfasdfa asdfasd asdfasd adddasdfasdfasdfa asdfasd asdfasd adddasdfasdfasdfa asdfasd asdfasd addd asdfasdfasdfa asdfasd asdfasd addd asdfasdfasdfa asdfasd asdfasd addd Info The assumption \\(\\sum_{k=1}^K\\hat y_k=1\\) is actually not required. [ CAPM ]: Capital Asset Pricing Model Unordered list Sed sagittis eleifend rutrum Donec vitae suscipit est Nulla tempor lobortis orci Ordered list Sed sagittis eleifend rutrum Donec vitae suscipit est Nulla tempor lobortis orci Example Unordered List Example : 1 2 3 * Sed sagittis eleifend rutrum * Donec vitae suscipit est * Nulla tempor lobortis orci Result : Sed sagittis eleifend rutrum Donec vitae suscipit est Nulla tempor lobortis orci Ordered List Example : 1 2 3 1. Sed sagittis eleifend rutrum 2. Donec vitae suscipit est 3. Nulla tempor lobortis orci Result : Sed sagittis eleifend rutrum Donec vitae suscipit est Nulla tempor lobortis orci Method Description GET :material-check: Fetch resource PUT :material-check-all: Update resource DELETE :material-close: Delete resource Lorem ipsum 1 dolor sit amet, consectetur adipiscing elit. 2 Image caption Lorem ipsum dolor sit amet, consectetur adipiscing elit. \u21a9 Lorem ipsum dolor sit amet, consectetur adipiscing elit. Nulla et euismod nulla. Curabitur feugiat, tortor non consequat finibus, justo purus auctor massa, nec semper lorem quam in massa. \u21a9","title":"Markdown Examples"},{"location":"_About/#markdown-examples","text":"\\[ \\underbrace{\\bA}_{=0} = 0 \\] Python 1 2 3 4 5 def bubble_sort ( items ): for i in range ( len ( items )): for j in range ( len ( items ) - 1 - i ): if items [ j ] > items [ j + 1 ]: items [ j ], items [ j + 1 ] = items [ j + 1 ], items [ j ] C++ 1 2 3 void f () { } The range () function is highlighted. Ex. 2.1 Suppose each of \\(K\\) -classes has associated target \\(t_k\\) , which is a vector of all zeros, except a one in the \\(k\\) -th position. Show that classifying to the largest of \\(\\hat y\\) amounts to choosing the closet target, \\(\\min_k\\|t_k-\\hat y\\|\\) , if the elements of \\(\\hat y\\) sum to one. Soln. 2.1 We need to prove: \\[\\begin{equation} \\underset{k}{\\operatorname{argmax}} \\hat y_k = \\underset{k}{\\operatorname{argmin}} \\|t_k-\\hat y\\|^2 \\label{eq:2-1a} \\end{equation}\\] By definition of \\(t_k\\) , we have \\[\\begin{align} \\|t_k-\\hat y\\|^2 &= (1-\\hat y_k)^2 + \\sum_{l \\neq k }(0 - \\hat y_l)^2\\nonumber\\\\ &= (1-\\hat y_k)^2 + \\sum_{l \\neq k }\\hat y_l^2 \\label{eq:2-1b} \\end{align}\\] Given \\(\\eqref{eq:2-1b}\\) , it's straightforward to see that \\(\\eqref{eq:2-1a}\\) indeed holds. Python 1 2 3 4 5 def bubble_sort ( items ): for i in range ( len ( items )): for j in range ( len ( items ) - 1 - i ): if items [ j ] > items [ j + 1 ]: items [ j ], items [ j + 1 ] = items [ j + 1 ], items [ j ] C++ 1 2 3 void f () { } The range () function is highlighted. Info The assumption \\(\\sum_{k=1}^K\\hat y_k=1\\) is actually not required. [ CAPM ]: Capital Asset Pricing Model asdfasdfasdfa asdfasd asdfasd adddasdfasdfasdfa asdfasd asdfasd adddasdfasdfasdfa asdfasd asdfasd addd asdfasdfasdfa asdfasd asdfasd addd asdfasdfasdfa asdfasd asdfasd addd Info The assumption \\(\\sum_{k=1}^K\\hat y_k=1\\) is actually not required. [ CAPM ]: Capital Asset Pricing Model Unordered list Sed sagittis eleifend rutrum Donec vitae suscipit est Nulla tempor lobortis orci Ordered list Sed sagittis eleifend rutrum Donec vitae suscipit est Nulla tempor lobortis orci Example Unordered List Example : 1 2 3 * Sed sagittis eleifend rutrum * Donec vitae suscipit est * Nulla tempor lobortis orci Result : Sed sagittis eleifend rutrum Donec vitae suscipit est Nulla tempor lobortis orci Ordered List Example : 1 2 3 1. Sed sagittis eleifend rutrum 2. Donec vitae suscipit est 3. Nulla tempor lobortis orci Result : Sed sagittis eleifend rutrum Donec vitae suscipit est Nulla tempor lobortis orci Method Description GET :material-check: Fetch resource PUT :material-check-all: Update resource DELETE :material-close: Delete resource Lorem ipsum 1 dolor sit amet, consectetur adipiscing elit. 2 Image caption Lorem ipsum dolor sit amet, consectetur adipiscing elit. \u21a9 Lorem ipsum dolor sit amet, consectetur adipiscing elit. Nulla et euismod nulla. Curabitur feugiat, tortor non consequat finibus, justo purus auctor massa, nec semper lorem quam in massa. \u21a9","title":"Markdown Examples"}]}