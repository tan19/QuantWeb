{"config":{"indexing":"full","lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"Apollo and Daphne by Gian Lorenzo Bernini, circa 1625. Preface Apollo, the Greek god of music, poetry, art, the sun, and a great warrior, mocked the god of love, Eros, for his use of bow and arrow, as Apollo is also patron of archery. \u201cWhat are you doing with powerful weapons, naughty boy?\u201d He said. \"That equipment of yours is fitting of our shoulders, which are able to give certain wounds to wild animals, and to enemies, I who recently killed the swollen Python, who was pressing down so many acres with his disease-bearing belly, with countless arrows! You will be content to provoke some loves by your fire, not to lay claim to my honors.\u201d This is the context behind the story. The insulted Eros then prepared two arrows: one of gold and one of lead. He shot Apollo with the gold arrow, instilling in the god a passionate love for the river nymph Daphne. He shot Daphne with the lead arrow, instilling in her a hatred for Apollo. Having taken after Apollo\u2019s sister, Artemis (Diana), Daphne had spurned her many potential lovers, preferring instead woodland sports and exploring the forest. Due to her identity as an \u201caemula Phoebes\u201d (female rival or emulator of Artemis), she had dedicated herself to perpetual virginity. Her father, the river god Peneus, demanded that she get married and give him grandchildren. She, however, begged her father to let her remain unmarried; he eventually complied. Apollo continually followed her, begging her to stay, but the nymph continued to reject him. They were evenly matched in the race until Eros intervened, helping Apollo catch up to Daphne. Seeing that Apollo was bound to reach her, she called upon her father, \"Help me, Peneus! Open the earth to enclose me, or change my form, which has brought me into this danger! Let me be free of this man from this moment forward!\" And with that, Peneus answered her plea, and \u201ca heavy numbness seizes her limbs; her soft breasts are surrounded by a thin bark, her hair changes into foliage, her arms change into branches; her foot, just now swift, now clings to sluggish roots.\u201d She turned into a laurel tree. In spite of Daphne's terror and fervent insistence that he leaves her alone, Apollo vowed to honor her forever: \u201cAlways my hair will have you, my lyres will have you, my quivers will have you, laurel tree. You will be present for the Latin leaders when a happy voice will sing a triumph and the Capitoline Hill will see long processions.\u201d Apollo also used his powers of eternal youth and immortality to render Daphne evergreen (\"you also, wear always the perpetual honors of your foliage!\"). For this reason, the leaves of the Bay laurel tree do not decay.","title":"Home"},{"location":"#preface","text":"Apollo, the Greek god of music, poetry, art, the sun, and a great warrior, mocked the god of love, Eros, for his use of bow and arrow, as Apollo is also patron of archery. \u201cWhat are you doing with powerful weapons, naughty boy?\u201d He said. \"That equipment of yours is fitting of our shoulders, which are able to give certain wounds to wild animals, and to enemies, I who recently killed the swollen Python, who was pressing down so many acres with his disease-bearing belly, with countless arrows! You will be content to provoke some loves by your fire, not to lay claim to my honors.\u201d This is the context behind the story. The insulted Eros then prepared two arrows: one of gold and one of lead. He shot Apollo with the gold arrow, instilling in the god a passionate love for the river nymph Daphne. He shot Daphne with the lead arrow, instilling in her a hatred for Apollo. Having taken after Apollo\u2019s sister, Artemis (Diana), Daphne had spurned her many potential lovers, preferring instead woodland sports and exploring the forest. Due to her identity as an \u201caemula Phoebes\u201d (female rival or emulator of Artemis), she had dedicated herself to perpetual virginity. Her father, the river god Peneus, demanded that she get married and give him grandchildren. She, however, begged her father to let her remain unmarried; he eventually complied. Apollo continually followed her, begging her to stay, but the nymph continued to reject him. They were evenly matched in the race until Eros intervened, helping Apollo catch up to Daphne. Seeing that Apollo was bound to reach her, she called upon her father, \"Help me, Peneus! Open the earth to enclose me, or change my form, which has brought me into this danger! Let me be free of this man from this moment forward!\" And with that, Peneus answered her plea, and \u201ca heavy numbness seizes her limbs; her soft breasts are surrounded by a thin bark, her hair changes into foliage, her arms change into branches; her foot, just now swift, now clings to sluggish roots.\u201d She turned into a laurel tree. In spite of Daphne's terror and fervent insistence that he leaves her alone, Apollo vowed to honor her forever: \u201cAlways my hair will have you, my lyres will have you, my quivers will have you, laurel tree. You will be present for the Latin leaders when a happy voice will sing a triumph and the Capitoline Hill will see long processions.\u201d Apollo also used his powers of eternal youth and immortality to render Daphne evergreen (\"you also, wear always the perpetual honors of your foliage!\"). For this reason, the leaves of the Bay laurel tree do not decay.","title":"Preface"},{"location":"1.%20Programming%20Languages/FAQ/","text":"C++ FAQ0001. Compare Procedural vs OOP Question Compare procedual and OOP. Answer Procedual programming has two distinct features: 1) data and operations are seperated; 2) only two types of data local and global . The drawback of the first is that it is not a good approximation of the real world. For the second, global data design makes it everything is related to everything else , which is overly complex and hard to maintain and extend. Comment FAQ0002. Discuss C++ Memory Areas Question Discuss C++ memory areas. Answer There are five distinct memory areas in C++: Const Data: The const data area stores string literals and other data whose values are known at compile-time. Do not assume the memory layout of this area, because compilers may optimize it, e.g, two overlap strings. Stack: The stack stores automatic/local variables. Free Store: The free store is used by new/delete . Heap: The heap is used by malloc/free . Global/Static: Global or static variables and objects have their storage allocated at program startup, but may not be initialized until after the program has begun executing. Comment This is Item 35 from Exceptional C++ . FAQ0003. What is a reference? How is it different from a pointer? Question What is a reference? How is it different from a pointer? Answer A pointer is a separate variable; a reference is an alias to its target. Reference cannot be reassigned. A reference may or may not be implemented as a pointer. Usually in a local scope, no storage is allocated; while in class/struct, storage is allocated. For example, the following will print 4 and 8. 1 2 3 4 5 6 7 8 9 10 11 12 #include <iostream> #include <algorithm> using namespace std ; int main (){ struct s { int & x ; }; const int & x = 1 ; std :: cout << sizeof ( x ) << std :: endl ; std :: cout << sizeof ( s ) << std :: endl ; } Also, a reference can point to null as well, although the behavior is undefined. For example, int &x = *(int*)0; in some compilers, this compiles. Also, References cannot be put into an array. It's neither possible to get the address of a reference - the address operator will return the address of the referenced value instead - nor is it possible to do arithmetics on references. Comment From the book \"Elements of Programming Interviews\". FAQ0004. Why is it preferable to pass-by-reference rather than pass-by-value? Question Why is it preferable to pass-by-reference rather than pass-by-value? Answer Pass by value is expensive and sometimes impossible (when copy constructor is unavailable); so people usually pass a constant reference to a function. Moreover, we can use reference to prevent unwanted casting. Consider the following code: 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 #include <iostream> #include <algorithm> using namespace std ; class Base { public : virtual string msg (){ return \"I am base\" ; } }; class Child : public Base { public : virtual string msg (){ return \"I am child\" ; } }; void cast ( Base x ){ cout << x . msg () << endl ; } int main (){ Base f ; Child b ; cast ( f ); cast ( b ); } The output is two \"I am base\". If we change cast(Base x) to cast(Base& x) , the output will be \"I am base\" and \"I am child\". Comment From the book \"Elements of Programming Interviews\". Python FAQ0005. How to merge two dictionaries in Python? Question How to merge two dictionaries in Python Answer 1 2 3 d1 = {'1':1, '2':3} d2 = {'2':2, '3':3} d = {**d1, **d2} The output is {'1':1, '2':2, '3':3} . Comment https://stackoverflow.com/questions/38987/how-do-i-merge-two-dictionaries-in-a-single-expression-take-union-of-dictionari","title":"FAQ"},{"location":"1.%20Programming%20Languages/FAQ/#c","text":"FAQ0001. Compare Procedural vs OOP Question Compare procedual and OOP. Answer Procedual programming has two distinct features: 1) data and operations are seperated; 2) only two types of data local and global . The drawback of the first is that it is not a good approximation of the real world. For the second, global data design makes it everything is related to everything else , which is overly complex and hard to maintain and extend. Comment FAQ0002. Discuss C++ Memory Areas Question Discuss C++ memory areas. Answer There are five distinct memory areas in C++: Const Data: The const data area stores string literals and other data whose values are known at compile-time. Do not assume the memory layout of this area, because compilers may optimize it, e.g, two overlap strings. Stack: The stack stores automatic/local variables. Free Store: The free store is used by new/delete . Heap: The heap is used by malloc/free . Global/Static: Global or static variables and objects have their storage allocated at program startup, but may not be initialized until after the program has begun executing. Comment This is Item 35 from Exceptional C++ . FAQ0003. What is a reference? How is it different from a pointer? Question What is a reference? How is it different from a pointer? Answer A pointer is a separate variable; a reference is an alias to its target. Reference cannot be reassigned. A reference may or may not be implemented as a pointer. Usually in a local scope, no storage is allocated; while in class/struct, storage is allocated. For example, the following will print 4 and 8. 1 2 3 4 5 6 7 8 9 10 11 12 #include <iostream> #include <algorithm> using namespace std ; int main (){ struct s { int & x ; }; const int & x = 1 ; std :: cout << sizeof ( x ) << std :: endl ; std :: cout << sizeof ( s ) << std :: endl ; } Also, a reference can point to null as well, although the behavior is undefined. For example, int &x = *(int*)0; in some compilers, this compiles. Also, References cannot be put into an array. It's neither possible to get the address of a reference - the address operator will return the address of the referenced value instead - nor is it possible to do arithmetics on references. Comment From the book \"Elements of Programming Interviews\". FAQ0004. Why is it preferable to pass-by-reference rather than pass-by-value? Question Why is it preferable to pass-by-reference rather than pass-by-value? Answer Pass by value is expensive and sometimes impossible (when copy constructor is unavailable); so people usually pass a constant reference to a function. Moreover, we can use reference to prevent unwanted casting. Consider the following code: 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 #include <iostream> #include <algorithm> using namespace std ; class Base { public : virtual string msg (){ return \"I am base\" ; } }; class Child : public Base { public : virtual string msg (){ return \"I am child\" ; } }; void cast ( Base x ){ cout << x . msg () << endl ; } int main (){ Base f ; Child b ; cast ( f ); cast ( b ); } The output is two \"I am base\". If we change cast(Base x) to cast(Base& x) , the output will be \"I am base\" and \"I am child\". Comment From the book \"Elements of Programming Interviews\".","title":"C++"},{"location":"1.%20Programming%20Languages/FAQ/#python","text":"FAQ0005. How to merge two dictionaries in Python? Question How to merge two dictionaries in Python Answer 1 2 3 d1 = {'1':1, '2':3} d2 = {'2':2, '3':3} d = {**d1, **d2} The output is {'1':1, '2':2, '3':3} . Comment https://stackoverflow.com/questions/38987/how-do-i-merge-two-dictionaries-in-a-single-expression-take-union-of-dictionari","title":"Python"},{"location":"1.%20Programming%20Languages/1.%20C%2B%2B/","text":"Index Objects can be created in the stack or heap, depending on whether or not it involves pointer usage. Java usually places objects directly into heaps, while C++ compiler often check and try to optimize. global \\emph{and static} variables are allocated into data segment. functions are compiled into code segment. Data is allocated into stack frame. Stack allocation is much faster since all it really does is move the stack pointer. Using memory pools, you can get comparable performance out of heap allocation, but that comes with a slight added complexity and its own headaches. Also, stack vs. heap is not only a performance consideration; it also tells you a lot about the expected lifetime of objects. Books The Definitive C++ Book Guide and List C++ Standard 2017 Clean Code CPP Reference cpp4u Tutorials The major difference between Java and C++ lies in multiple inheritance, which Java has replaced with a simpler concept of interfaces. The single biggest difference between Java and C/C++ is that Java has a pointer model that eliminates the possibility of overwriting memory and corrupting data. Tutorials Programming Languages C++ 1 , 2 3 Bash tricks 1 , 2 , 3 C/C++\u9762\u8bd5\u77e5\u8bc6\u603b\u7ed3 \u6280\u672f\u9762\u8bd5\u5fc5\u5907\u57fa\u7840\u77e5\u8bc6 \u8fd9\u53ef\u80fd\u662f\u4e1c\u534a\u7403\u6700\u4fdd\u59c6\u7ea7\u7684\u540e\u53f0\u670d\u52a1\u5668\u5f00\u53d1\u5b66\u4e60\u8def\u7ebf AI education materials Programming Programming Languages Types and programming languages Software Foundations C The C Programming Language Pointers on C C Traps and Pitfalls Expert C Programming C++ C++ Primer, Accelerated C++, The C++ Programming Language C++ Templates Effective C++, More Effective C++, Exceptional C++, More Exceptional C++, Effective STL C++ Coding Standards, Exceptional C++ Style Inside the C++ Object Model The Definitive C++ Book Guide and List C++ Standard 2017 Clean Code CPP Reference cpp4u","title":"Index"},{"location":"1.%20Programming%20Languages/1.%20C%2B%2B/#index","text":"Objects can be created in the stack or heap, depending on whether or not it involves pointer usage. Java usually places objects directly into heaps, while C++ compiler often check and try to optimize. global \\emph{and static} variables are allocated into data segment. functions are compiled into code segment. Data is allocated into stack frame. Stack allocation is much faster since all it really does is move the stack pointer. Using memory pools, you can get comparable performance out of heap allocation, but that comes with a slight added complexity and its own headaches. Also, stack vs. heap is not only a performance consideration; it also tells you a lot about the expected lifetime of objects.","title":"Index"},{"location":"1.%20Programming%20Languages/1.%20C%2B%2B/#books","text":"The Definitive C++ Book Guide and List C++ Standard 2017 Clean Code CPP Reference cpp4u","title":"Books"},{"location":"1.%20Programming%20Languages/1.%20C%2B%2B/#tutorials","text":"The major difference between Java and C++ lies in multiple inheritance, which Java has replaced with a simpler concept of interfaces. The single biggest difference between Java and C/C++ is that Java has a pointer model that eliminates the possibility of overwriting memory and corrupting data. Tutorials Programming Languages C++ 1 , 2 3 Bash tricks 1 , 2 , 3 C/C++\u9762\u8bd5\u77e5\u8bc6\u603b\u7ed3 \u6280\u672f\u9762\u8bd5\u5fc5\u5907\u57fa\u7840\u77e5\u8bc6 \u8fd9\u53ef\u80fd\u662f\u4e1c\u534a\u7403\u6700\u4fdd\u59c6\u7ea7\u7684\u540e\u53f0\u670d\u52a1\u5668\u5f00\u53d1\u5b66\u4e60\u8def\u7ebf AI education materials","title":"Tutorials"},{"location":"1.%20Programming%20Languages/1.%20C%2B%2B/#programming","text":"","title":"Programming"},{"location":"1.%20Programming%20Languages/1.%20C%2B%2B/#programming-languages","text":"Types and programming languages Software Foundations","title":"Programming Languages"},{"location":"1.%20Programming%20Languages/1.%20C%2B%2B/#c","text":"The C Programming Language Pointers on C C Traps and Pitfalls Expert C Programming","title":"C"},{"location":"1.%20Programming%20Languages/1.%20C%2B%2B/#c_1","text":"C++ Primer, Accelerated C++, The C++ Programming Language C++ Templates Effective C++, More Effective C++, Exceptional C++, More Exceptional C++, Effective STL C++ Coding Standards, Exceptional C++ Style Inside the C++ Object Model The Definitive C++ Book Guide and List C++ Standard 2017 Clean Code CPP Reference cpp4u","title":"C++"},{"location":"1.%20Programming%20Languages/1.%20C%2B%2B/0.%20Basics/","text":"0. Basics Definitions A program consists of one or more files . A name is an identifier which consists an arbitrarily long sequence of letters and digits. A type defines a set of possible values and a set of operations. A declaration introduces one or more names into a program. An object is some memory that holds a value of some type. Also, an object is a region of storage. A named object has a storage class that determines its lifetime. A value is a set of bits interpreted according to a type. A variable is a named object. Variable is generally used to refer to instances of scalar data types, whereas instances of other types are usually called objects. A translation unit is a file after preprocessing. Preprocessing is controlled by directives introduced by lines having # as the first character. Scope, Type, Storage, and Linkage Scope (local, global, namespace) + Type (const) + Storage(automatic, dynamic, static-internal, static-external) + Linkage(No linkage, internal, external). For example, 1 2 3 // i is a `global` `const int` that has // `static storage` and `external linkage`. extern const int i ; Rules: A header file only contains extern declarations of variables \u2014 never static or unqualified variable definitions. A source file never contains extern declarations of variables \u2014 source files always include the (sole) header that declares them. The source file that defines the variable also includes the header to ensure that the definition and the declaration are consistent. Internal and external linkage in C++: http://www.goldsborough.me/c/c++/linker/2016/03/30/19-34-25-internal_and_external_linkage_in_c++/ Clockwise/Spiral Rule: http://c-faq.com/decl/spiral.anderson.html C++ FAQ: https://isocpp.org/faq Conversions Narrowing conversions lose information when you use = , but not with {} . Function Type The type of a function consists of its return type and the sequence of its argument types. 1 2 // type: double(const vector<double>&, int) double get ( const vector < double >& vec , int index ); For a member function, the name of the class is also part of the function type: 1 2 // type: char& String::(int) char & String :: operator []( int index );","title":"0. Basics"},{"location":"1.%20Programming%20Languages/1.%20C%2B%2B/0.%20Basics/#0-basics","text":"","title":"0. Basics"},{"location":"1.%20Programming%20Languages/1.%20C%2B%2B/0.%20Basics/#definitions","text":"A program consists of one or more files . A name is an identifier which consists an arbitrarily long sequence of letters and digits. A type defines a set of possible values and a set of operations. A declaration introduces one or more names into a program. An object is some memory that holds a value of some type. Also, an object is a region of storage. A named object has a storage class that determines its lifetime. A value is a set of bits interpreted according to a type. A variable is a named object. Variable is generally used to refer to instances of scalar data types, whereas instances of other types are usually called objects. A translation unit is a file after preprocessing. Preprocessing is controlled by directives introduced by lines having # as the first character.","title":"Definitions"},{"location":"1.%20Programming%20Languages/1.%20C%2B%2B/0.%20Basics/#scope-type-storage-and-linkage","text":"Scope (local, global, namespace) + Type (const) + Storage(automatic, dynamic, static-internal, static-external) + Linkage(No linkage, internal, external). For example, 1 2 3 // i is a `global` `const int` that has // `static storage` and `external linkage`. extern const int i ; Rules: A header file only contains extern declarations of variables \u2014 never static or unqualified variable definitions. A source file never contains extern declarations of variables \u2014 source files always include the (sole) header that declares them. The source file that defines the variable also includes the header to ensure that the definition and the declaration are consistent. Internal and external linkage in C++: http://www.goldsborough.me/c/c++/linker/2016/03/30/19-34-25-internal_and_external_linkage_in_c++/ Clockwise/Spiral Rule: http://c-faq.com/decl/spiral.anderson.html C++ FAQ: https://isocpp.org/faq","title":"Scope, Type, Storage, and Linkage"},{"location":"1.%20Programming%20Languages/1.%20C%2B%2B/0.%20Basics/#conversions","text":"Narrowing conversions lose information when you use = , but not with {} .","title":"Conversions"},{"location":"1.%20Programming%20Languages/1.%20C%2B%2B/0.%20Basics/#function-type","text":"The type of a function consists of its return type and the sequence of its argument types. 1 2 // type: double(const vector<double>&, int) double get ( const vector < double >& vec , int index ); For a member function, the name of the class is also part of the function type: 1 2 // type: char& String::(int) char & String :: operator []( int index );","title":"Function Type"},{"location":"1.%20Programming%20Languages/1.%20C%2B%2B/1.%20Preprocessing/","text":"1. Preprocessing Preprocessing provides macro substituting , conditional compilation , and source file inclusion . In addition, directives are provided to control line numbering in diagnostics and for symbolic debugging, to generate a diagnostic message with a given token sequence, and to perform implementation-dependent actions (the #proagma directive).","title":"1. Preprocessing"},{"location":"1.%20Programming%20Languages/1.%20C%2B%2B/1.%20Preprocessing/#1-preprocessing","text":"Preprocessing provides macro substituting , conditional compilation , and source file inclusion . In addition, directives are provided to control line numbering in diagnostics and for symbolic debugging, to generate a diagnostic message with a given token sequence, and to perform implementation-dependent actions (the #proagma directive).","title":"1. Preprocessing"},{"location":"1.%20Programming%20Languages/1.%20C%2B%2B/2.%20Pointers/","text":"2. Pointers Note that the following two are different: \\begin{lstlisting} void pf(int &, int &); // pf is a function of type \"void (int &, int &)\" void (*pf)(int &, int &); // pf is a pointer to a function of type \"void (int &, int &)\" \\end{lstlisting}","title":"2. Pointers"},{"location":"1.%20Programming%20Languages/1.%20C%2B%2B/2.%20Pointers/#2-pointers","text":"Note that the following two are different: \\begin{lstlisting} void pf(int &, int &); // pf is a function of type \"void (int &, int &)\" void (*pf)(int &, int &); // pf is a pointer to a function of type \"void (int &, int &)\" \\end{lstlisting}","title":"2. Pointers"},{"location":"1.%20Programming%20Languages/1.%20C%2B%2B/Class%20Functions/","text":"There are seven special class functions. C++ Class Functions 1 2 3 4 5 6 7 8 9 10 11 12 13 14 class X { public : X ( SomeType ); // \"ordinary constructor\": create an object X (); // default constructor X ( const X & ); // copy constructor X ( X && ); // move constructor X & operator = ( const X & ); // copy assignment: clean up target and copy X & operator = ( X && ); // move assignment: clean up target and move ~ X (); // destructor: clean up // ... };","title":"Index"},{"location":"1.%20Programming%20Languages/1.%20C%2B%2B/Class%20Functions/assignment_operator/","text":"","title":"Assignment operator"},{"location":"1.%20Programming%20Languages/1.%20C%2B%2B/Class%20Functions/constructor/","text":"","title":"Constructor"},{"location":"1.%20Programming%20Languages/1.%20C%2B%2B/Class%20Functions/destructor/","text":"","title":"Destructor"},{"location":"1.%20Programming%20Languages/2.%20Java/","text":"Index","title":"Index"},{"location":"1.%20Programming%20Languages/2.%20Java/#index","text":"","title":"Index"},{"location":"1.%20Programming%20Languages/2.%20Java/1.%20Objects%20and%20Classes/1.%20Objects%20and%20Classes/","text":"Objects and Classes","title":"Objects and Classes"},{"location":"1.%20Programming%20Languages/2.%20Java/1.%20Objects%20and%20Classes/1.%20Objects%20and%20Classes/#objects-and-classes","text":"","title":"Objects and Classes"},{"location":"1.%20Programming%20Languages/2.%20Java/2.%20Inheritance/2.%20Inheritance/","text":"Objects and Classes","title":"Objects and Classes"},{"location":"1.%20Programming%20Languages/2.%20Java/2.%20Inheritance/2.%20Inheritance/#objects-and-classes","text":"","title":"Objects and Classes"},{"location":"1.%20Programming%20Languages/2.%20Java/3.%20Interfaces%2C%20Lambda%20Expressions%2C%20and%20Inner%20Classes/3.%20Interfaces%2C%20Lambda%20Expressions%2C%20and%20Inner%20Classes/","text":"Chapter 6. Interfaces, Lambda Expressions, and Inner Classes Anonymous Inner Class If you want to make only a single object of this class, you don't even need to give the class a name. Such a class is called an anonymous inner class . Anonymous classes cannot have a constructor (in C++ and Java) but can have a destructor (this is for C++; there's no destructor in Java, instead we have Garbage Collector in Java). Anonymous Inner Class Java 1 2 3 4 5 6 var obj = new SuperType ( construction parameters ) { // even though an anonymous class cannot have constructors, // you can provide an object initialization block { initialization } ... } The SuperType can be an interface, then the inner class implements that interface. It can also be a class, then the inner class extends that class. C++ There is no equivalent such a concept in C++, although the concept of anonymous class exists. To declare an anonymous class and its variables, just ignore the class name, as in: 1 2 3 4 5 6 class { public : void f () { std :: cout << \"I am an object of an anonymous class.\" << std :: endl ; } } obj1 , obj2 ; The closest equivalent to Java anonymous inner classes in C++ is to use a private class which implements the corresponding interface (but if the interface is a functional interface, then the closest equivalent is to replace the functional interface with a function pointer and the anonymous inner class with a lambda). See more here . Python In Python, you can use the type(name, bases, dict) builtin function to crate on the fly. For example: 1 2 3 4 5 class ParentClass : pass op = type ( \"ChildClass\" , ( ParentClass , object ), { \"foo\" : lambda self : print ( \"foo\" )}) op () . foo ()","title":"Chapter 6. Interfaces, Lambda Expressions, and Inner Classes"},{"location":"1.%20Programming%20Languages/2.%20Java/3.%20Interfaces%2C%20Lambda%20Expressions%2C%20and%20Inner%20Classes/3.%20Interfaces%2C%20Lambda%20Expressions%2C%20and%20Inner%20Classes/#chapter-6-interfaces-lambda-expressions-and-inner-classes","text":"","title":"Chapter 6. Interfaces, Lambda Expressions, and Inner Classes"},{"location":"1.%20Programming%20Languages/2.%20Java/3.%20Interfaces%2C%20Lambda%20Expressions%2C%20and%20Inner%20Classes/3.%20Interfaces%2C%20Lambda%20Expressions%2C%20and%20Inner%20Classes/#anonymous-inner-class","text":"If you want to make only a single object of this class, you don't even need to give the class a name. Such a class is called an anonymous inner class . Anonymous classes cannot have a constructor (in C++ and Java) but can have a destructor (this is for C++; there's no destructor in Java, instead we have Garbage Collector in Java). Anonymous Inner Class Java 1 2 3 4 5 6 var obj = new SuperType ( construction parameters ) { // even though an anonymous class cannot have constructors, // you can provide an object initialization block { initialization } ... } The SuperType can be an interface, then the inner class implements that interface. It can also be a class, then the inner class extends that class. C++ There is no equivalent such a concept in C++, although the concept of anonymous class exists. To declare an anonymous class and its variables, just ignore the class name, as in: 1 2 3 4 5 6 class { public : void f () { std :: cout << \"I am an object of an anonymous class.\" << std :: endl ; } } obj1 , obj2 ; The closest equivalent to Java anonymous inner classes in C++ is to use a private class which implements the corresponding interface (but if the interface is a functional interface, then the closest equivalent is to replace the functional interface with a function pointer and the anonymous inner class with a lambda). See more here . Python In Python, you can use the type(name, bases, dict) builtin function to crate on the fly. For example: 1 2 3 4 5 class ParentClass : pass op = type ( \"ChildClass\" , ( ParentClass , object ), { \"foo\" : lambda self : print ( \"foo\" )}) op () . foo ()","title":"Anonymous Inner Class"},{"location":"1.%20Programming%20Languages/2.%20Java/4.%20Exceptions%2C%20Assertions%2C%20and%20Logging/4.%20Exceptions%2C%20Assertions%2C%20and%20Logging/","text":"Chapter 6. Interfaces, Lambda Expressions, and Inner Classes Anonymous Inner Class If you want to make only a single object of this class, you don't even need to give the class a name. Such a class is called an anonymous inner class . Anonymous classes cannot have a constructor (in C++ and Java) but can have a destructor (this is for C++; there's no destructor in Java, instead we have Garbage Collector in Java). Anonymous Inner Class Java 1 2 3 4 5 6 var obj = new SuperType ( construction parameters ) { // even though an anonymous class cannot have constructors, // you can provide an object initialization block { initialization } ... } The SuperType can be an interface, then the inner class implements that interface. It can also be a class, then the inner class extends that class. C++ There is no equivalent such a concept in C++, although the concept of anonymous class exists. To declare an anonymous class and its variables, just ignore the class name, as in: 1 2 3 4 5 6 class { public : void f () { std :: cout << \"I am an object of an anonymous class.\" << std :: endl ; } } obj1 , obj2 ; The closest equivalent to Java anonymous inner classes in C++ is to use a private class which implements the corresponding interface (but if the interface is a functional interface, then the closest equivalent is to replace the functional interface with a function pointer and the anonymous inner class with a lambda). See more here . Python In Python, you can use the type(name, bases, dict) builtin function to crate on the fly. For example: 1 2 3 4 5 class ParentClass : pass op = type ( \"ChildClass\" , ( ParentClass , object ), { \"foo\" : lambda self : print ( \"foo\" )}) op () . foo ()","title":"Chapter 6. Interfaces, Lambda Expressions, and Inner Classes"},{"location":"1.%20Programming%20Languages/2.%20Java/4.%20Exceptions%2C%20Assertions%2C%20and%20Logging/4.%20Exceptions%2C%20Assertions%2C%20and%20Logging/#chapter-6-interfaces-lambda-expressions-and-inner-classes","text":"","title":"Chapter 6. Interfaces, Lambda Expressions, and Inner Classes"},{"location":"1.%20Programming%20Languages/2.%20Java/4.%20Exceptions%2C%20Assertions%2C%20and%20Logging/4.%20Exceptions%2C%20Assertions%2C%20and%20Logging/#anonymous-inner-class","text":"If you want to make only a single object of this class, you don't even need to give the class a name. Such a class is called an anonymous inner class . Anonymous classes cannot have a constructor (in C++ and Java) but can have a destructor (this is for C++; there's no destructor in Java, instead we have Garbage Collector in Java). Anonymous Inner Class Java 1 2 3 4 5 6 var obj = new SuperType ( construction parameters ) { // even though an anonymous class cannot have constructors, // you can provide an object initialization block { initialization } ... } The SuperType can be an interface, then the inner class implements that interface. It can also be a class, then the inner class extends that class. C++ There is no equivalent such a concept in C++, although the concept of anonymous class exists. To declare an anonymous class and its variables, just ignore the class name, as in: 1 2 3 4 5 6 class { public : void f () { std :: cout << \"I am an object of an anonymous class.\" << std :: endl ; } } obj1 , obj2 ; The closest equivalent to Java anonymous inner classes in C++ is to use a private class which implements the corresponding interface (but if the interface is a functional interface, then the closest equivalent is to replace the functional interface with a function pointer and the anonymous inner class with a lambda). See more here . Python In Python, you can use the type(name, bases, dict) builtin function to crate on the fly. For example: 1 2 3 4 5 class ParentClass : pass op = type ( \"ChildClass\" , ( ParentClass , object ), { \"foo\" : lambda self : print ( \"foo\" )}) op () . foo ()","title":"Anonymous Inner Class"},{"location":"1.%20Programming%20Languages/2.%20Java/5.%20Genereic%20Programming/5.%20Genereic%20Programming/","text":"Chapter 6. Interfaces, Lambda Expressions, and Inner Classes Anonymous Inner Class If you want to make only a single object of this class, you don't even need to give the class a name. Such a class is called an anonymous inner class . Anonymous classes cannot have a constructor (in C++ and Java) but can have a destructor (this is for C++; there's no destructor in Java, instead we have Garbage Collector in Java). Anonymous Inner Class Java 1 2 3 4 5 6 var obj = new SuperType ( construction parameters ) { // even though an anonymous class cannot have constructors, // you can provide an object initialization block { initialization } ... } The SuperType can be an interface, then the inner class implements that interface. It can also be a class, then the inner class extends that class. C++ There is no equivalent such a concept in C++, although the concept of anonymous class exists. To declare an anonymous class and its variables, just ignore the class name, as in: 1 2 3 4 5 6 class { public : void f () { std :: cout << \"I am an object of an anonymous class.\" << std :: endl ; } } obj1 , obj2 ; The closest equivalent to Java anonymous inner classes in C++ is to use a private class which implements the corresponding interface (but if the interface is a functional interface, then the closest equivalent is to replace the functional interface with a function pointer and the anonymous inner class with a lambda). See more here . Python In Python, you can use the type(name, bases, dict) builtin function to crate on the fly. For example: 1 2 3 4 5 class ParentClass : pass op = type ( \"ChildClass\" , ( ParentClass , object ), { \"foo\" : lambda self : print ( \"foo\" )}) op () . foo ()","title":"Chapter 6. Interfaces, Lambda Expressions, and Inner Classes"},{"location":"1.%20Programming%20Languages/2.%20Java/5.%20Genereic%20Programming/5.%20Genereic%20Programming/#chapter-6-interfaces-lambda-expressions-and-inner-classes","text":"","title":"Chapter 6. Interfaces, Lambda Expressions, and Inner Classes"},{"location":"1.%20Programming%20Languages/2.%20Java/5.%20Genereic%20Programming/5.%20Genereic%20Programming/#anonymous-inner-class","text":"If you want to make only a single object of this class, you don't even need to give the class a name. Such a class is called an anonymous inner class . Anonymous classes cannot have a constructor (in C++ and Java) but can have a destructor (this is for C++; there's no destructor in Java, instead we have Garbage Collector in Java). Anonymous Inner Class Java 1 2 3 4 5 6 var obj = new SuperType ( construction parameters ) { // even though an anonymous class cannot have constructors, // you can provide an object initialization block { initialization } ... } The SuperType can be an interface, then the inner class implements that interface. It can also be a class, then the inner class extends that class. C++ There is no equivalent such a concept in C++, although the concept of anonymous class exists. To declare an anonymous class and its variables, just ignore the class name, as in: 1 2 3 4 5 6 class { public : void f () { std :: cout << \"I am an object of an anonymous class.\" << std :: endl ; } } obj1 , obj2 ; The closest equivalent to Java anonymous inner classes in C++ is to use a private class which implements the corresponding interface (but if the interface is a functional interface, then the closest equivalent is to replace the functional interface with a function pointer and the anonymous inner class with a lambda). See more here . Python In Python, you can use the type(name, bases, dict) builtin function to crate on the fly. For example: 1 2 3 4 5 class ParentClass : pass op = type ( \"ChildClass\" , ( ParentClass , object ), { \"foo\" : lambda self : print ( \"foo\" )}) op () . foo ()","title":"Anonymous Inner Class"},{"location":"1.%20Programming%20Languages/2.%20Java/6.%20Collections/6.%20Collections/","text":"Chapter 6. Interfaces, Lambda Expressions, and Inner Classes Anonymous Inner Class If you want to make only a single object of this class, you don't even need to give the class a name. Such a class is called an anonymous inner class . Anonymous classes cannot have a constructor (in C++ and Java) but can have a destructor (this is for C++; there's no destructor in Java, instead we have Garbage Collector in Java). Anonymous Inner Class Java 1 2 3 4 5 6 var obj = new SuperType ( construction parameters ) { // even though an anonymous class cannot have constructors, // you can provide an object initialization block { initialization } ... } The SuperType can be an interface, then the inner class implements that interface. It can also be a class, then the inner class extends that class. C++ There is no equivalent such a concept in C++, although the concept of anonymous class exists. To declare an anonymous class and its variables, just ignore the class name, as in: 1 2 3 4 5 6 class { public : void f () { std :: cout << \"I am an object of an anonymous class.\" << std :: endl ; } } obj1 , obj2 ; The closest equivalent to Java anonymous inner classes in C++ is to use a private class which implements the corresponding interface (but if the interface is a functional interface, then the closest equivalent is to replace the functional interface with a function pointer and the anonymous inner class with a lambda). See more here . Python In Python, you can use the type(name, bases, dict) builtin function to crate on the fly. For example: 1 2 3 4 5 class ParentClass : pass op = type ( \"ChildClass\" , ( ParentClass , object ), { \"foo\" : lambda self : print ( \"foo\" )}) op () . foo ()","title":"Chapter 6. Interfaces, Lambda Expressions, and Inner Classes"},{"location":"1.%20Programming%20Languages/2.%20Java/6.%20Collections/6.%20Collections/#chapter-6-interfaces-lambda-expressions-and-inner-classes","text":"","title":"Chapter 6. Interfaces, Lambda Expressions, and Inner Classes"},{"location":"1.%20Programming%20Languages/2.%20Java/6.%20Collections/6.%20Collections/#anonymous-inner-class","text":"If you want to make only a single object of this class, you don't even need to give the class a name. Such a class is called an anonymous inner class . Anonymous classes cannot have a constructor (in C++ and Java) but can have a destructor (this is for C++; there's no destructor in Java, instead we have Garbage Collector in Java). Anonymous Inner Class Java 1 2 3 4 5 6 var obj = new SuperType ( construction parameters ) { // even though an anonymous class cannot have constructors, // you can provide an object initialization block { initialization } ... } The SuperType can be an interface, then the inner class implements that interface. It can also be a class, then the inner class extends that class. C++ There is no equivalent such a concept in C++, although the concept of anonymous class exists. To declare an anonymous class and its variables, just ignore the class name, as in: 1 2 3 4 5 6 class { public : void f () { std :: cout << \"I am an object of an anonymous class.\" << std :: endl ; } } obj1 , obj2 ; The closest equivalent to Java anonymous inner classes in C++ is to use a private class which implements the corresponding interface (but if the interface is a functional interface, then the closest equivalent is to replace the functional interface with a function pointer and the anonymous inner class with a lambda). See more here . Python In Python, you can use the type(name, bases, dict) builtin function to crate on the fly. For example: 1 2 3 4 5 class ParentClass : pass op = type ( \"ChildClass\" , ( ParentClass , object ), { \"foo\" : lambda self : print ( \"foo\" )}) op () . foo ()","title":"Anonymous Inner Class"},{"location":"1.%20Programming%20Languages/2.%20Java/7.%20Concurrency/7.%20Concurrency/","text":"Chapter 6. Interfaces, Lambda Expressions, and Inner Classes Anonymous Inner Class If you want to make only a single object of this class, you don't even need to give the class a name. Such a class is called an anonymous inner class . Anonymous classes cannot have a constructor (in C++ and Java) but can have a destructor (this is for C++; there's no destructor in Java, instead we have Garbage Collector in Java). Anonymous Inner Class Java 1 2 3 4 5 6 var obj = new SuperType ( construction parameters ) { // even though an anonymous class cannot have constructors, // you can provide an object initialization block { initialization } ... } The SuperType can be an interface, then the inner class implements that interface. It can also be a class, then the inner class extends that class. C++ There is no equivalent such a concept in C++, although the concept of anonymous class exists. To declare an anonymous class and its variables, just ignore the class name, as in: 1 2 3 4 5 6 class { public : void f () { std :: cout << \"I am an object of an anonymous class.\" << std :: endl ; } } obj1 , obj2 ; The closest equivalent to Java anonymous inner classes in C++ is to use a private class which implements the corresponding interface (but if the interface is a functional interface, then the closest equivalent is to replace the functional interface with a function pointer and the anonymous inner class with a lambda). See more here . Python In Python, you can use the type(name, bases, dict) builtin function to crate on the fly. For example: 1 2 3 4 5 class ParentClass : pass op = type ( \"ChildClass\" , ( ParentClass , object ), { \"foo\" : lambda self : print ( \"foo\" )}) op () . foo ()","title":"Chapter 6. Interfaces, Lambda Expressions, and Inner Classes"},{"location":"1.%20Programming%20Languages/2.%20Java/7.%20Concurrency/7.%20Concurrency/#chapter-6-interfaces-lambda-expressions-and-inner-classes","text":"","title":"Chapter 6. Interfaces, Lambda Expressions, and Inner Classes"},{"location":"1.%20Programming%20Languages/2.%20Java/7.%20Concurrency/7.%20Concurrency/#anonymous-inner-class","text":"If you want to make only a single object of this class, you don't even need to give the class a name. Such a class is called an anonymous inner class . Anonymous classes cannot have a constructor (in C++ and Java) but can have a destructor (this is for C++; there's no destructor in Java, instead we have Garbage Collector in Java). Anonymous Inner Class Java 1 2 3 4 5 6 var obj = new SuperType ( construction parameters ) { // even though an anonymous class cannot have constructors, // you can provide an object initialization block { initialization } ... } The SuperType can be an interface, then the inner class implements that interface. It can also be a class, then the inner class extends that class. C++ There is no equivalent such a concept in C++, although the concept of anonymous class exists. To declare an anonymous class and its variables, just ignore the class name, as in: 1 2 3 4 5 6 class { public : void f () { std :: cout << \"I am an object of an anonymous class.\" << std :: endl ; } } obj1 , obj2 ; The closest equivalent to Java anonymous inner classes in C++ is to use a private class which implements the corresponding interface (but if the interface is a functional interface, then the closest equivalent is to replace the functional interface with a function pointer and the anonymous inner class with a lambda). See more here . Python In Python, you can use the type(name, bases, dict) builtin function to crate on the fly. For example: 1 2 3 4 5 class ParentClass : pass op = type ( \"ChildClass\" , ( ParentClass , object ), { \"foo\" : lambda self : print ( \"foo\" )}) op () . foo ()","title":"Anonymous Inner Class"},{"location":"1.%20Programming%20Languages/2.%20Java/8.%20Meta%20Programming/8.%20Meta%20Programming/","text":"Python Meta Programming There are five main meta programming techniques in Python: At load-time: - Operator overloading - Decorator - Metaclass - Descriptor and Property - Import hook At run-time: - compile - Monkey Patch and Hot Patch Import Hooks Whenever you use an import statement, it is equivalent to: 1 os = __import__ ( \"os\" ) First, it check sys.modules , a dict containing already-loaded modules, just in case we've already imported the requested module. Next, if sys.meta_path list is not empty, then every meta importer hook in it will be queried. Finally, it checks sys.path , a list containing filesystem paths for Python to search for potential modules. It is at the second step that we will be able to intercept. To do this, we'll need to crate a meta path finder , which has a single public method find_spec , and add it to sys.meta_path . 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 import importlib.abc import importlib.machinery class DependencyInjectorFinder ( importlib . abc . MetaPathFinder ): def __init__ ( self , loader ): # we'll write the loader in a minute, hang tight self . _loader = loader def find_spec ( self , fullname , path , target = None ): \"\"\"Attempt to locate the requested module fullname is the fully-qualified name of the module, path is set to __path__ for sub-modules/packages, or None otherwise. target can be a module object, but is unused in this example. \"\"\" if self . _loader . provides ( fullname ): return self . _gen_spec ( fullname ) def _gen_spec ( self , fullname ): spec = importlib . machinery . ModuleSpec ( fullname , self . _loader ) return spec # we'll also add it to sys.meta_path later If a meta path finder provides the requested module, then it should return an instance of the importlib.machinery.ModuleSpec class, which is a fairly simple affair with a small handful of attributes that lets Python's import machinery know what it needs to know to take the next steps in importing the module the user requested. For our purposes, we're interested in two attributes (the only required ones): ModuleSpec.name, which is the name of the requested module, and ModuleSpec.loader, which is the loader object that Python should use to actually load the module - you'll notice the self._loader lines above that reference a loader object, as well. A loader object is a very simple class with two required methods in Python: create_module , which takes a ModuleSpec as its sole argument and returns an object that Python will consider to be the new module, and exec_module , which takes the new module as its sole argument and executes it. 1 2 3 4 5 class Loader ( importlib . abc . Loader ): def create_module ( self , spec ): raise NotImplementedError def exec_module ( self , module ): raise NotImplementedError","title":"Python Meta Programming"},{"location":"1.%20Programming%20Languages/2.%20Java/8.%20Meta%20Programming/8.%20Meta%20Programming/#python-meta-programming","text":"There are five main meta programming techniques in Python: At load-time: - Operator overloading - Decorator - Metaclass - Descriptor and Property - Import hook At run-time: - compile - Monkey Patch and Hot Patch","title":"Python Meta Programming"},{"location":"1.%20Programming%20Languages/2.%20Java/8.%20Meta%20Programming/8.%20Meta%20Programming/#import-hooks","text":"Whenever you use an import statement, it is equivalent to: 1 os = __import__ ( \"os\" ) First, it check sys.modules , a dict containing already-loaded modules, just in case we've already imported the requested module. Next, if sys.meta_path list is not empty, then every meta importer hook in it will be queried. Finally, it checks sys.path , a list containing filesystem paths for Python to search for potential modules. It is at the second step that we will be able to intercept. To do this, we'll need to crate a meta path finder , which has a single public method find_spec , and add it to sys.meta_path . 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 import importlib.abc import importlib.machinery class DependencyInjectorFinder ( importlib . abc . MetaPathFinder ): def __init__ ( self , loader ): # we'll write the loader in a minute, hang tight self . _loader = loader def find_spec ( self , fullname , path , target = None ): \"\"\"Attempt to locate the requested module fullname is the fully-qualified name of the module, path is set to __path__ for sub-modules/packages, or None otherwise. target can be a module object, but is unused in this example. \"\"\" if self . _loader . provides ( fullname ): return self . _gen_spec ( fullname ) def _gen_spec ( self , fullname ): spec = importlib . machinery . ModuleSpec ( fullname , self . _loader ) return spec # we'll also add it to sys.meta_path later If a meta path finder provides the requested module, then it should return an instance of the importlib.machinery.ModuleSpec class, which is a fairly simple affair with a small handful of attributes that lets Python's import machinery know what it needs to know to take the next steps in importing the module the user requested. For our purposes, we're interested in two attributes (the only required ones): ModuleSpec.name, which is the name of the requested module, and ModuleSpec.loader, which is the loader object that Python should use to actually load the module - you'll notice the self._loader lines above that reference a loader object, as well. A loader object is a very simple class with two required methods in Python: create_module , which takes a ModuleSpec as its sole argument and returns an object that Python will consider to be the new module, and exec_module , which takes the new module as its sole argument and executes it. 1 2 3 4 5 class Loader ( importlib . abc . Loader ): def create_module ( self , spec ): raise NotImplementedError def exec_module ( self , module ): raise NotImplementedError","title":"Import Hooks"},{"location":"1.%20Programming%20Languages/3.%20Python/","text":"Index Bound, Unbound, and Static Methods in Python Question In Python, what are bound, unbound, and static methods? Answer pass Python: Python + Ipython (\u5ed6\u96ea\u5cf0\uff0cLearning Python, Python\u6e90\u7801\u5256\u6790) Data Science: NumPy + SciPy + Pandas + Matplotlib (Python for Data Analysis) Machine Learning: Scikit-learn Deep Learning: Tensorflow + NLTK [https://see.stanford.edu/Course/CS107 Progamming Paradigms] [https://www.amazon.com/Computer-Systems-Programmers-Perspective-3rd/dp/013409266X CSAPP] Learning Python Python Cookbook Effective Python Fluent Python [http://www.liaoxuefeng.com/wiki/0014316089557264a6b348958f449949df42a6d3a2e542c000 Python\u6559\u7a0b] Include this in the first line of the python code: #! \\/usr\\/bin\\/env python Every file of Python source code whose name ends in a /.py/ extension is a /module/. An /attribute/ is simply a variable name that is attached to a specific object (like a module). The build-in /dir/ function can be used to list all the names available inside a module. Everything in Python is an object, and almost everything has attributes and methods. Six main build-in data types: numbers, strings, lists, dictionaries, tuples, and sets. /Literals/ are the expressions that generate objects, e.g., 'spam' is a literal that generates a string object. Both lists and dictionaries may be nested, can grow and shrink on demand, and may contain objects of any type. Difference between lists and tuples: lists are /mutable/ while tuples are /immutable/. Python is /dynamically/ and /strongly/ typed: dynamic typing is a model that tracks the type automatically instead of requiring declaration code, and strongly typed is a constraint that you can perform only the operations that are valid for its type. Reference acts like pointers. math, random,","title":"Index"},{"location":"1.%20Programming%20Languages/3.%20Python/#index","text":"Bound, Unbound, and Static Methods in Python Question In Python, what are bound, unbound, and static methods? Answer pass Python: Python + Ipython (\u5ed6\u96ea\u5cf0\uff0cLearning Python, Python\u6e90\u7801\u5256\u6790) Data Science: NumPy + SciPy + Pandas + Matplotlib (Python for Data Analysis) Machine Learning: Scikit-learn Deep Learning: Tensorflow + NLTK [https://see.stanford.edu/Course/CS107 Progamming Paradigms] [https://www.amazon.com/Computer-Systems-Programmers-Perspective-3rd/dp/013409266X CSAPP] Learning Python Python Cookbook Effective Python Fluent Python [http://www.liaoxuefeng.com/wiki/0014316089557264a6b348958f449949df42a6d3a2e542c000 Python\u6559\u7a0b] Include this in the first line of the python code: #! \\/usr\\/bin\\/env python Every file of Python source code whose name ends in a /.py/ extension is a /module/. An /attribute/ is simply a variable name that is attached to a specific object (like a module). The build-in /dir/ function can be used to list all the names available inside a module. Everything in Python is an object, and almost everything has attributes and methods. Six main build-in data types: numbers, strings, lists, dictionaries, tuples, and sets. /Literals/ are the expressions that generate objects, e.g., 'spam' is a literal that generates a string object. Both lists and dictionaries may be nested, can grow and shrink on demand, and may contain objects of any type. Difference between lists and tuples: lists are /mutable/ while tuples are /immutable/. Python is /dynamically/ and /strongly/ typed: dynamic typing is a model that tracks the type automatically instead of requiring declaration code, and strongly typed is a constraint that you can perform only the operations that are valid for its type. Reference acts like pointers. math, random,","title":"Index"},{"location":"1.%20Programming%20Languages/3.%20Python/Class/","text":"Python Classes classmethod vs staticmethod Q: What's the difference between classmethod and staticmethod? A: classmethod is for the class while staticmethod is just like a plain function that happens to live within a class body.","title":"Python Classes"},{"location":"1.%20Programming%20Languages/3.%20Python/Class/#python-classes","text":"classmethod vs staticmethod Q: What's the difference between classmethod and staticmethod? A: classmethod is for the class while staticmethod is just like a plain function that happens to live within a class body.","title":"Python Classes"},{"location":"1.%20Programming%20Languages/3.%20Python/Metaprogramming/","text":"Metaprogramming Metaprogramming is writing programs that operate on programs. If a program simply looks at and reports itself, we call it introspection . If the program also modifies itself, we call it reflection .","title":"Metaprogramming"},{"location":"1.%20Programming%20Languages/3.%20Python/Metaprogramming/#metaprogramming","text":"Metaprogramming is writing programs that operate on programs. If a program simply looks at and reports itself, we call it introspection . If the program also modifies itself, we call it reflection .","title":"Metaprogramming"},{"location":"2.%20Operating%20System/","text":"Operating System","title":"Index"},{"location":"3.%20Computer%20Network/","text":"Computer Network","title":"Index"},{"location":"4.%20System%20Design/","text":"System Design","title":"Index"},{"location":"A.%20LeetCode/","text":"Index Solution = Data Structure + Algorithm Do I need to change the input, e.g., change it to another data structure or simply sort it? Do I need to (on-the-fly or batch) build an auxiliary data structure? How do I search? [https://www.cs.usfca.edu/~galles/visualization/Algorithms.html] VisuAlgo OI Wiki \u6d1b\u8c37 \u7a0b\u5e8f\u8bbe\u8ba1\u7ade\u8d5b\u8fdb\u9636\u8bad\u7ec3\u6307\u5357 Tricks: Change input Binary Search solution space Dictionary of alphabet","title":"Index"},{"location":"A.%20LeetCode/#index","text":"Solution = Data Structure + Algorithm Do I need to change the input, e.g., change it to another data structure or simply sort it? Do I need to (on-the-fly or batch) build an auxiliary data structure? How do I search? [https://www.cs.usfca.edu/~galles/visualization/Algorithms.html] VisuAlgo OI Wiki \u6d1b\u8c37 \u7a0b\u5e8f\u8bbe\u8ba1\u7ade\u8d5b\u8fdb\u9636\u8bad\u7ec3\u6307\u5357 Tricks: Change input Binary Search solution space Dictionary of alphabet","title":"Index"},{"location":"A.%20LeetCode/1.%20Data%20Structures/1.%20Auxilary%20Data%20Structures/1.1%20Bit/Bitset/","text":"= Bit \u9898\u76ee\u5206\u7c7b \u9898\u76ee\u7f16\u53f7 \u6570\u5b57\u7684\u4f4d\u64cd\u4f5c 7\u30019\u3001479\u3001564\u3001231\u3001342\u3001326\u3001504\u3001263\u3001190\u3001191\u3001476\u3001461\u3001477\u3001693\u3001393\u3001172\u3001458\u3001258\u3001319\u3001405\u3001171\u3001168\u3001670\u3001233\u3001357\u3001400 \u9898\u76ee\u5206\u7c7b \u9898\u76ee\u7f16\u53f7 \u5f02\u6216\u7684\u5e94\u7528 89\u3001136\u3001137\u3001260\u3001268 \u4e0e\u6216\u975e\u7684\u5e94\u7528 371\u3001318\u3001201","title":"Bitset"},{"location":"A.%20LeetCode/1.%20Data%20Structures/1.%20Auxilary%20Data%20Structures/1.2%20Set/Disjoint_Set/","text":"Disjoint Set (5) Introduction \u5982\u679c\u6570\u636e\u4e0d\u662f\u5b9e\u65f6\u53d8\u5316\uff0c\u672c\u7c7b\u95ee\u9898\u53ef\u4ee5\u7528BFS\u6216\u8005DFS\u7684\u65b9\u5f0f\u904d\u5386\uff0c\u5982\u679c\u6570\u636e\u5b9e\u65f6\u53d8\u5316\uff08data stream\uff09\u5219\u5e76\u67e5\u96c6\u6bcf\u6b21\u7684\u65f6\u95f4\u590d\u6742\u5ea6\u53ef\u4ee5\u89c6\u4e3aO\uff081\uff09\uff1b\u9700\u8981\u7262\u8bb0\u5408\u5e76\u4e0e\u67e5\u627e\u4e24\u4e2a\u64cd\u4f5c\u7684\u6a21\u677f \u5e38\u89c1\u9898\u76ee\uff1a Leetcode 721 Accounts Merge Leetcode 737 Sentence Similarity II Leetcode 434 Number of Islands II Problems ID Title Difficulty LC547 Number of Provinces Medium LC684 Capacity To Ship Packages Within D Days Medium JZ116 \u670b\u53cb\u5708 Medium LC990 Satisfiability of Equality Equations Medium LC1361 Validate Binary Tree Nodes Medium LC547. Number of Provinces (Medium) Info LC547. Number of Provinces (Medium) Algorithm: Union Find Time Complexity: \\(O(n\\log n)\\) Space Complexity: \\(O(n)\\) Solution Union Find \\(O(n \\log n)\\) Python 1 class UnionFind: def init (self, n): self.parent = [i for i in range(n)] 1 2 3 4 5 6 7 8 9 10 11 12 def find(self, x): if(self.parent[x] != x): self.parent[x] = self.find(self.parent[x]) # path compression return self.parent[x] def union(self, x, y): rootX = self.find(x) rootY = self.find(y) if(rootX != rootY): self.parent[rootY] = rootX class Solution: def findCircleNum(self, M: List[List[int]]) -> int: n = len(M) 1 2 3 4 5 6 7 8 9 10 11 12 13 UF = UnionFind(n) for i in range(n): for j in range(n): if(M[i][j] == 1): UF.union(i, j) res = 0 for i in range(len(UF.parent)): if(UF.parent[i] == i): res += 1 return res LC684. Redundant Connection (Medium) Info LC684. Redundant Connection (Medium) Algorithm: Union Find Time Complexity: \\(O(n\\log n)\\) Space Complexity: \\(O(n)\\) Solution Union Find \\(O(n \\log n)\\) Python 1 class UnionFind: def init (self, n): self.parent = [i for i in range(n + 1)] 1 2 3 4 5 6 7 8 9 10 def find(self, x): if self.parent[x] != x: self.parent[x] = self.find(self.parent[x]) # path compression return self.parent[x] def union(self, x, y): parentX = self.find(x) parentY = self.find(y) self.parent[parentX] = parentY class Solution: def findRedundantConnection(self, edges: List[List[int]]) -> List[int]: n = max(max(i, j) for i, j in edges) 1 2 3 4 5 6 7 8 9 10 UF = UnionFind(n) ans = [] for i, j in edges: if UF.find(i) == UF.find(j): ans = [i, j] else: UF.union(i, j) return ans JZ116. \u670b\u53cb\u5708 (Medium) Info JZ116. \u670b\u53cb\u5708 (Medium) Algorithm: Union Find Time Complexity: \\(O(n)\\) Space Complexity: \\(O(n)\\) Solution Union Find \\(O(n)\\) Python 1 class Solution: def findCircleNum(self, isConnected: List[List[int]]) -> int: def find(x): if x != parent[x]: parent[x] = find(parent[x]) return parent[x] 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 def union(x, y): parentX = find(x) parentY = find(y) if parentX != parentY: parent[parentX] = parentY parent = [i for i in range(len(isConnected))] for i in range(len(isConnected)): for j in range(i + 1, len(isConnected[0])): if isConnected[i][j]: union(i, j) ans = 0 for i in range(len(parent)): if parent[i] == i: ans += 1 return ans LC990. Satisfiability of Equality Equations (Medium) Info LC990. Satisfiability of Equality Equations (Medium) Algorithm: Union Find Time Complexity: \\(O(n)\\) Space Complexity: \\(O(n)\\) Solution Union Find \\(O(n)\\) Python 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 class Solution : def equationsPossible ( self , equations : List [ str ]) -> bool : parent = {} def find ( x ): if x != parent [ x ]: parent [ x ] = find ( parent [ x ]) return parent [ x ] def union ( x , y ): parentX = find ( x ) parentY = find ( y ) if parentX != parentY : parent [ parentX ] = parentY for e in equations : x , op , y = e [ 0 ], e [ 1 : - 1 ], e [ - 1 ] if x not in parent : parent [ x ] = x if y not in parent : parent [ y ] = y if op == \"==\" : union ( x , y ) for e in equations : x , op , y = e [ 0 ], e [ 1 : - 1 ], e [ - 1 ] if op == \"!=\" and find ( x ) == find ( y ): return False return True LC1361. Validate Binary Tree Nodes (Medium) Info LC1361. Validate Binary Tree Nodes (Medium) Algorithm: Union Find Time Complexity: \\(O(n)\\) Space Complexity: \\(O(n)\\) Solution Union Find \\(O(n)\\) Python 1 class Solution: def validateBinaryTreeNodes(self, n: int, leftChild: List[int], rightChild: List[int]) -> bool: def find(x): if x != parent[x]: parent[x] = find(parent[x]) return parent[x] def union(x, y): parentX = find(x) parentY = find(y) if parentX != parentY: parent[parentX] = parentY 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 parent = [i for i in range(n)] for i in range(len(leftChild)): if leftChild[i] != -1: if find(leftChild[i]) != leftChild[i] or find(i) == find(leftChild[i]): return False else: union(leftChild[i], i) if rightChild[i] != -1: if find(rightChild[i]) != rightChild[i] or find(i) == find(rightChild[i]): return False else: union(rightChild[i], i) connectedComponents = 0 for i in range(len(parent)): if parent[i] == i: connectedComponents += 1 return connectedComponents == 1","title":"Disjoint Set (5)"},{"location":"A.%20LeetCode/1.%20Data%20Structures/1.%20Auxilary%20Data%20Structures/1.2%20Set/Disjoint_Set/#disjoint-set-5","text":"","title":"Disjoint Set (5)"},{"location":"A.%20LeetCode/1.%20Data%20Structures/1.%20Auxilary%20Data%20Structures/1.2%20Set/Disjoint_Set/#introduction","text":"\u5982\u679c\u6570\u636e\u4e0d\u662f\u5b9e\u65f6\u53d8\u5316\uff0c\u672c\u7c7b\u95ee\u9898\u53ef\u4ee5\u7528BFS\u6216\u8005DFS\u7684\u65b9\u5f0f\u904d\u5386\uff0c\u5982\u679c\u6570\u636e\u5b9e\u65f6\u53d8\u5316\uff08data stream\uff09\u5219\u5e76\u67e5\u96c6\u6bcf\u6b21\u7684\u65f6\u95f4\u590d\u6742\u5ea6\u53ef\u4ee5\u89c6\u4e3aO\uff081\uff09\uff1b\u9700\u8981\u7262\u8bb0\u5408\u5e76\u4e0e\u67e5\u627e\u4e24\u4e2a\u64cd\u4f5c\u7684\u6a21\u677f \u5e38\u89c1\u9898\u76ee\uff1a Leetcode 721 Accounts Merge Leetcode 737 Sentence Similarity II Leetcode 434 Number of Islands II","title":"Introduction"},{"location":"A.%20LeetCode/1.%20Data%20Structures/1.%20Auxilary%20Data%20Structures/1.2%20Set/Disjoint_Set/#problems","text":"ID Title Difficulty LC547 Number of Provinces Medium LC684 Capacity To Ship Packages Within D Days Medium JZ116 \u670b\u53cb\u5708 Medium LC990 Satisfiability of Equality Equations Medium LC1361 Validate Binary Tree Nodes Medium LC547. Number of Provinces (Medium) Info LC547. Number of Provinces (Medium) Algorithm: Union Find Time Complexity: \\(O(n\\log n)\\) Space Complexity: \\(O(n)\\) Solution Union Find \\(O(n \\log n)\\) Python 1 class UnionFind: def init (self, n): self.parent = [i for i in range(n)] 1 2 3 4 5 6 7 8 9 10 11 12 def find(self, x): if(self.parent[x] != x): self.parent[x] = self.find(self.parent[x]) # path compression return self.parent[x] def union(self, x, y): rootX = self.find(x) rootY = self.find(y) if(rootX != rootY): self.parent[rootY] = rootX class Solution: def findCircleNum(self, M: List[List[int]]) -> int: n = len(M) 1 2 3 4 5 6 7 8 9 10 11 12 13 UF = UnionFind(n) for i in range(n): for j in range(n): if(M[i][j] == 1): UF.union(i, j) res = 0 for i in range(len(UF.parent)): if(UF.parent[i] == i): res += 1 return res LC684. Redundant Connection (Medium) Info LC684. Redundant Connection (Medium) Algorithm: Union Find Time Complexity: \\(O(n\\log n)\\) Space Complexity: \\(O(n)\\) Solution Union Find \\(O(n \\log n)\\) Python 1 class UnionFind: def init (self, n): self.parent = [i for i in range(n + 1)] 1 2 3 4 5 6 7 8 9 10 def find(self, x): if self.parent[x] != x: self.parent[x] = self.find(self.parent[x]) # path compression return self.parent[x] def union(self, x, y): parentX = self.find(x) parentY = self.find(y) self.parent[parentX] = parentY class Solution: def findRedundantConnection(self, edges: List[List[int]]) -> List[int]: n = max(max(i, j) for i, j in edges) 1 2 3 4 5 6 7 8 9 10 UF = UnionFind(n) ans = [] for i, j in edges: if UF.find(i) == UF.find(j): ans = [i, j] else: UF.union(i, j) return ans JZ116. \u670b\u53cb\u5708 (Medium) Info JZ116. \u670b\u53cb\u5708 (Medium) Algorithm: Union Find Time Complexity: \\(O(n)\\) Space Complexity: \\(O(n)\\) Solution Union Find \\(O(n)\\) Python 1 class Solution: def findCircleNum(self, isConnected: List[List[int]]) -> int: def find(x): if x != parent[x]: parent[x] = find(parent[x]) return parent[x] 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 def union(x, y): parentX = find(x) parentY = find(y) if parentX != parentY: parent[parentX] = parentY parent = [i for i in range(len(isConnected))] for i in range(len(isConnected)): for j in range(i + 1, len(isConnected[0])): if isConnected[i][j]: union(i, j) ans = 0 for i in range(len(parent)): if parent[i] == i: ans += 1 return ans LC990. Satisfiability of Equality Equations (Medium) Info LC990. Satisfiability of Equality Equations (Medium) Algorithm: Union Find Time Complexity: \\(O(n)\\) Space Complexity: \\(O(n)\\) Solution Union Find \\(O(n)\\) Python 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 class Solution : def equationsPossible ( self , equations : List [ str ]) -> bool : parent = {} def find ( x ): if x != parent [ x ]: parent [ x ] = find ( parent [ x ]) return parent [ x ] def union ( x , y ): parentX = find ( x ) parentY = find ( y ) if parentX != parentY : parent [ parentX ] = parentY for e in equations : x , op , y = e [ 0 ], e [ 1 : - 1 ], e [ - 1 ] if x not in parent : parent [ x ] = x if y not in parent : parent [ y ] = y if op == \"==\" : union ( x , y ) for e in equations : x , op , y = e [ 0 ], e [ 1 : - 1 ], e [ - 1 ] if op == \"!=\" and find ( x ) == find ( y ): return False return True LC1361. Validate Binary Tree Nodes (Medium) Info LC1361. Validate Binary Tree Nodes (Medium) Algorithm: Union Find Time Complexity: \\(O(n)\\) Space Complexity: \\(O(n)\\) Solution Union Find \\(O(n)\\) Python 1 class Solution: def validateBinaryTreeNodes(self, n: int, leftChild: List[int], rightChild: List[int]) -> bool: def find(x): if x != parent[x]: parent[x] = find(parent[x]) return parent[x] def union(x, y): parentX = find(x) parentY = find(y) if parentX != parentY: parent[parentX] = parentY 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 parent = [i for i in range(n)] for i in range(len(leftChild)): if leftChild[i] != -1: if find(leftChild[i]) != leftChild[i] or find(i) == find(leftChild[i]): return False else: union(leftChild[i], i) if rightChild[i] != -1: if find(rightChild[i]) != rightChild[i] or find(i) == find(rightChild[i]): return False else: union(rightChild[i], i) connectedComponents = 0 for i in range(len(parent)): if parent[i] == i: connectedComponents += 1 return connectedComponents == 1","title":"Problems"},{"location":"A.%20LeetCode/1.%20Data%20Structures/1.%20Auxilary%20Data%20Structures/1.2%20Set/Ordered_Set/","text":"Disjoint Set (5) Introduction \u5982\u679c\u6570\u636e\u4e0d\u662f\u5b9e\u65f6\u53d8\u5316\uff0c\u672c\u7c7b\u95ee\u9898\u53ef\u4ee5\u7528BFS\u6216\u8005DFS\u7684\u65b9\u5f0f\u904d\u5386\uff0c\u5982\u679c\u6570\u636e\u5b9e\u65f6\u53d8\u5316\uff08data stream\uff09\u5219\u5e76\u67e5\u96c6\u6bcf\u6b21\u7684\u65f6\u95f4\u590d\u6742\u5ea6\u53ef\u4ee5\u89c6\u4e3aO\uff081\uff09\uff1b\u9700\u8981\u7262\u8bb0\u5408\u5e76\u4e0e\u67e5\u627e\u4e24\u4e2a\u64cd\u4f5c\u7684\u6a21\u677f \u5e38\u89c1\u9898\u76ee\uff1a Leetcode 721 Accounts Merge Leetcode 737 Sentence Similarity II Leetcode 434 Number of Islands II Problems ID Title Difficulty LC547 Number of Provinces Medium LC684 Capacity To Ship Packages Within D Days Medium JZ116 \u670b\u53cb\u5708 Medium LC990 Satisfiability of Equality Equations Medium LC1361 Validate Binary Tree Nodes Medium LC547. Number of Provinces (Medium) Info LC547. Number of Provinces (Medium) Algorithm: Union Find Time Complexity: \\(O(n\\log n)\\) Space Complexity: \\(O(n)\\) Solution Union Find \\(O(n \\log n)\\) Python 1 class UnionFind: def init (self, n): self.parent = [i for i in range(n)] 1 2 3 4 5 6 7 8 9 10 11 12 def find(self, x): if(self.parent[x] != x): self.parent[x] = self.find(self.parent[x]) # path compression return self.parent[x] def union(self, x, y): rootX = self.find(x) rootY = self.find(y) if(rootX != rootY): self.parent[rootY] = rootX class Solution: def findCircleNum(self, M: List[List[int]]) -> int: n = len(M) 1 2 3 4 5 6 7 8 9 10 11 12 13 UF = UnionFind(n) for i in range(n): for j in range(n): if(M[i][j] == 1): UF.union(i, j) res = 0 for i in range(len(UF.parent)): if(UF.parent[i] == i): res += 1 return res LC684. Redundant Connection (Medium) Info LC684. Redundant Connection (Medium) Algorithm: Union Find Time Complexity: \\(O(n\\log n)\\) Space Complexity: \\(O(n)\\) Solution Union Find \\(O(n \\log n)\\) Python 1 class UnionFind: def init (self, n): self.parent = [i for i in range(n + 1)] 1 2 3 4 5 6 7 8 9 10 def find(self, x): if self.parent[x] != x: self.parent[x] = self.find(self.parent[x]) # path compression return self.parent[x] def union(self, x, y): parentX = self.find(x) parentY = self.find(y) self.parent[parentX] = parentY class Solution: def findRedundantConnection(self, edges: List[List[int]]) -> List[int]: n = max(max(i, j) for i, j in edges) 1 2 3 4 5 6 7 8 9 10 UF = UnionFind(n) ans = [] for i, j in edges: if UF.find(i) == UF.find(j): ans = [i, j] else: UF.union(i, j) return ans JZ116. \u670b\u53cb\u5708 (Medium) Info JZ116. \u670b\u53cb\u5708 (Medium) Algorithm: Union Find Time Complexity: \\(O(n)\\) Space Complexity: \\(O(n)\\) Solution Union Find \\(O(n)\\) Python 1 class Solution: def findCircleNum(self, isConnected: List[List[int]]) -> int: def find(x): if x != parent[x]: parent[x] = find(parent[x]) return parent[x] 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 def union(x, y): parentX = find(x) parentY = find(y) if parentX != parentY: parent[parentX] = parentY parent = [i for i in range(len(isConnected))] for i in range(len(isConnected)): for j in range(i + 1, len(isConnected[0])): if isConnected[i][j]: union(i, j) ans = 0 for i in range(len(parent)): if parent[i] == i: ans += 1 return ans LC990. Satisfiability of Equality Equations (Medium) Info LC990. Satisfiability of Equality Equations (Medium) Algorithm: Union Find Time Complexity: \\(O(n)\\) Space Complexity: \\(O(n)\\) Solution Union Find \\(O(n)\\) Python 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 class Solution : def equationsPossible ( self , equations : List [ str ]) -> bool : parent = {} def find ( x ): if x != parent [ x ]: parent [ x ] = find ( parent [ x ]) return parent [ x ] def union ( x , y ): parentX = find ( x ) parentY = find ( y ) if parentX != parentY : parent [ parentX ] = parentY for e in equations : x , op , y = e [ 0 ], e [ 1 : - 1 ], e [ - 1 ] if x not in parent : parent [ x ] = x if y not in parent : parent [ y ] = y if op == \"==\" : union ( x , y ) for e in equations : x , op , y = e [ 0 ], e [ 1 : - 1 ], e [ - 1 ] if op == \"!=\" and find ( x ) == find ( y ): return False return True LC1361. Validate Binary Tree Nodes (Medium) Info LC1361. Validate Binary Tree Nodes (Medium) Algorithm: Union Find Time Complexity: \\(O(n)\\) Space Complexity: \\(O(n)\\) Solution Union Find \\(O(n)\\) Python 1 class Solution: def validateBinaryTreeNodes(self, n: int, leftChild: List[int], rightChild: List[int]) -> bool: def find(x): if x != parent[x]: parent[x] = find(parent[x]) return parent[x] def union(x, y): parentX = find(x) parentY = find(y) if parentX != parentY: parent[parentX] = parentY 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 parent = [i for i in range(n)] for i in range(len(leftChild)): if leftChild[i] != -1: if find(leftChild[i]) != leftChild[i] or find(i) == find(leftChild[i]): return False else: union(leftChild[i], i) if rightChild[i] != -1: if find(rightChild[i]) != rightChild[i] or find(i) == find(rightChild[i]): return False else: union(rightChild[i], i) connectedComponents = 0 for i in range(len(parent)): if parent[i] == i: connectedComponents += 1 return connectedComponents == 1","title":"Disjoint Set (5)"},{"location":"A.%20LeetCode/1.%20Data%20Structures/1.%20Auxilary%20Data%20Structures/1.2%20Set/Ordered_Set/#disjoint-set-5","text":"","title":"Disjoint Set (5)"},{"location":"A.%20LeetCode/1.%20Data%20Structures/1.%20Auxilary%20Data%20Structures/1.2%20Set/Ordered_Set/#introduction","text":"\u5982\u679c\u6570\u636e\u4e0d\u662f\u5b9e\u65f6\u53d8\u5316\uff0c\u672c\u7c7b\u95ee\u9898\u53ef\u4ee5\u7528BFS\u6216\u8005DFS\u7684\u65b9\u5f0f\u904d\u5386\uff0c\u5982\u679c\u6570\u636e\u5b9e\u65f6\u53d8\u5316\uff08data stream\uff09\u5219\u5e76\u67e5\u96c6\u6bcf\u6b21\u7684\u65f6\u95f4\u590d\u6742\u5ea6\u53ef\u4ee5\u89c6\u4e3aO\uff081\uff09\uff1b\u9700\u8981\u7262\u8bb0\u5408\u5e76\u4e0e\u67e5\u627e\u4e24\u4e2a\u64cd\u4f5c\u7684\u6a21\u677f \u5e38\u89c1\u9898\u76ee\uff1a Leetcode 721 Accounts Merge Leetcode 737 Sentence Similarity II Leetcode 434 Number of Islands II","title":"Introduction"},{"location":"A.%20LeetCode/1.%20Data%20Structures/1.%20Auxilary%20Data%20Structures/1.2%20Set/Ordered_Set/#problems","text":"ID Title Difficulty LC547 Number of Provinces Medium LC684 Capacity To Ship Packages Within D Days Medium JZ116 \u670b\u53cb\u5708 Medium LC990 Satisfiability of Equality Equations Medium LC1361 Validate Binary Tree Nodes Medium LC547. Number of Provinces (Medium) Info LC547. Number of Provinces (Medium) Algorithm: Union Find Time Complexity: \\(O(n\\log n)\\) Space Complexity: \\(O(n)\\) Solution Union Find \\(O(n \\log n)\\) Python 1 class UnionFind: def init (self, n): self.parent = [i for i in range(n)] 1 2 3 4 5 6 7 8 9 10 11 12 def find(self, x): if(self.parent[x] != x): self.parent[x] = self.find(self.parent[x]) # path compression return self.parent[x] def union(self, x, y): rootX = self.find(x) rootY = self.find(y) if(rootX != rootY): self.parent[rootY] = rootX class Solution: def findCircleNum(self, M: List[List[int]]) -> int: n = len(M) 1 2 3 4 5 6 7 8 9 10 11 12 13 UF = UnionFind(n) for i in range(n): for j in range(n): if(M[i][j] == 1): UF.union(i, j) res = 0 for i in range(len(UF.parent)): if(UF.parent[i] == i): res += 1 return res LC684. Redundant Connection (Medium) Info LC684. Redundant Connection (Medium) Algorithm: Union Find Time Complexity: \\(O(n\\log n)\\) Space Complexity: \\(O(n)\\) Solution Union Find \\(O(n \\log n)\\) Python 1 class UnionFind: def init (self, n): self.parent = [i for i in range(n + 1)] 1 2 3 4 5 6 7 8 9 10 def find(self, x): if self.parent[x] != x: self.parent[x] = self.find(self.parent[x]) # path compression return self.parent[x] def union(self, x, y): parentX = self.find(x) parentY = self.find(y) self.parent[parentX] = parentY class Solution: def findRedundantConnection(self, edges: List[List[int]]) -> List[int]: n = max(max(i, j) for i, j in edges) 1 2 3 4 5 6 7 8 9 10 UF = UnionFind(n) ans = [] for i, j in edges: if UF.find(i) == UF.find(j): ans = [i, j] else: UF.union(i, j) return ans JZ116. \u670b\u53cb\u5708 (Medium) Info JZ116. \u670b\u53cb\u5708 (Medium) Algorithm: Union Find Time Complexity: \\(O(n)\\) Space Complexity: \\(O(n)\\) Solution Union Find \\(O(n)\\) Python 1 class Solution: def findCircleNum(self, isConnected: List[List[int]]) -> int: def find(x): if x != parent[x]: parent[x] = find(parent[x]) return parent[x] 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 def union(x, y): parentX = find(x) parentY = find(y) if parentX != parentY: parent[parentX] = parentY parent = [i for i in range(len(isConnected))] for i in range(len(isConnected)): for j in range(i + 1, len(isConnected[0])): if isConnected[i][j]: union(i, j) ans = 0 for i in range(len(parent)): if parent[i] == i: ans += 1 return ans LC990. Satisfiability of Equality Equations (Medium) Info LC990. Satisfiability of Equality Equations (Medium) Algorithm: Union Find Time Complexity: \\(O(n)\\) Space Complexity: \\(O(n)\\) Solution Union Find \\(O(n)\\) Python 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 class Solution : def equationsPossible ( self , equations : List [ str ]) -> bool : parent = {} def find ( x ): if x != parent [ x ]: parent [ x ] = find ( parent [ x ]) return parent [ x ] def union ( x , y ): parentX = find ( x ) parentY = find ( y ) if parentX != parentY : parent [ parentX ] = parentY for e in equations : x , op , y = e [ 0 ], e [ 1 : - 1 ], e [ - 1 ] if x not in parent : parent [ x ] = x if y not in parent : parent [ y ] = y if op == \"==\" : union ( x , y ) for e in equations : x , op , y = e [ 0 ], e [ 1 : - 1 ], e [ - 1 ] if op == \"!=\" and find ( x ) == find ( y ): return False return True LC1361. Validate Binary Tree Nodes (Medium) Info LC1361. Validate Binary Tree Nodes (Medium) Algorithm: Union Find Time Complexity: \\(O(n)\\) Space Complexity: \\(O(n)\\) Solution Union Find \\(O(n)\\) Python 1 class Solution: def validateBinaryTreeNodes(self, n: int, leftChild: List[int], rightChild: List[int]) -> bool: def find(x): if x != parent[x]: parent[x] = find(parent[x]) return parent[x] def union(x, y): parentX = find(x) parentY = find(y) if parentX != parentY: parent[parentX] = parentY 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 parent = [i for i in range(n)] for i in range(len(leftChild)): if leftChild[i] != -1: if find(leftChild[i]) != leftChild[i] or find(i) == find(leftChild[i]): return False else: union(leftChild[i], i) if rightChild[i] != -1: if find(rightChild[i]) != rightChild[i] or find(i) == find(rightChild[i]): return False else: union(rightChild[i], i) connectedComponents = 0 for i in range(len(parent)): if parent[i] == i: connectedComponents += 1 return connectedComponents == 1","title":"Problems"},{"location":"A.%20LeetCode/1.%20Data%20Structures/1.%20Auxilary%20Data%20Structures/1.3%20Map/Bloom%20Filter/","text":"Bloom Filter","title":"Bloom Filter"},{"location":"A.%20LeetCode/1.%20Data%20Structures/1.%20Auxilary%20Data%20Structures/1.3%20Map/Bloom%20Filter/#bloom-filter","text":"","title":"Bloom Filter"},{"location":"A.%20LeetCode/1.%20Data%20Structures/1.%20Auxilary%20Data%20Structures/1.3%20Map/Map/","text":"Map","title":"Map"},{"location":"A.%20LeetCode/1.%20Data%20Structures/1.%20Auxilary%20Data%20Structures/1.3%20Map/Map/#map","text":"","title":"Map"},{"location":"A.%20LeetCode/1.%20Data%20Structures/1.%20Auxilary%20Data%20Structures/1.5%20Stack%2C%20Queue%2C%20and%20Deque/Deque/","text":"Deque Deque is a special case of two pointers.","title":"Deque"},{"location":"A.%20LeetCode/1.%20Data%20Structures/1.%20Auxilary%20Data%20Structures/1.5%20Stack%2C%20Queue%2C%20and%20Deque/Deque/#deque","text":"Deque is a special case of two pointers.","title":"Deque"},{"location":"A.%20LeetCode/1.%20Data%20Structures/1.%20Auxilary%20Data%20Structures/1.5%20Stack%2C%20Queue%2C%20and%20Deque/Heap/","text":"Heap (1) \u5806\u9898\u5e93\uff08\u5171118\u9898\uff09 Introduction Leetcode 973. K Closest Points Leetcode 347. Top k Largest Elements Leetcode 23. Merge K Sorted Lists Leetcode 264. Ugly Number II Leetcode 1086. High Five Leetcode 68. Merge Sorted Arrays Leetcode 692. Top K Frequent Words Leetcode 378. Kth Smallest Element in a Sorted Matrix Leetcode 295. Find Median from Data Stream Leetcode 767. Reorganize String Leetcode 1438. Longest Continuous Subarray With Absolute Diff Less Than or Equal to Limit Leetcode 895. Maximum Frequency Stack Problems (0, 1, 0) LC659. Split Array into Consecutive Subsequences (Medium) LC659. Split Array into Consecutive Subsequences (Medium) Info LC659. Split Array into Consecutive Subsequences (Medium) Algorithm: Heap Time Complexity: Space Complexity: Solution Adhoc \\(O(n^2)\\) Python 1 Problems ID Title Difficulty 1094 Car Pooling Medium LC1094. Car Pooling (Medium) Info LC1094. Car Pooling (Medium) Algorithm: Heap Time Complexity: \\(O(n \\log n)\\) Space Complexity: \\(O(n)\\) Solution Heap. Heap \\(O(n \\log n)\\) Python 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 class Solution : def carPooling ( self , trips : List [ List [ int ]], capacity : int ) -> bool : trips . sort ( key = lambda x : ( x [ 1 ], x [ 2 ])) heap = [] heapq . heapify ( heap ) for i in range ( len ( trips )): n , time , end = trips [ i ] while heap and time >= heap [ 0 ]: heapq . heappop ( heap ) for j in range ( n ): heapq . heappush ( heap , end ) if len ( heap ) > capacity : return False return True","title":"Heap (1)"},{"location":"A.%20LeetCode/1.%20Data%20Structures/1.%20Auxilary%20Data%20Structures/1.5%20Stack%2C%20Queue%2C%20and%20Deque/Heap/#heap-1","text":"\u5806\u9898\u5e93\uff08\u5171118\u9898\uff09","title":"Heap (1)"},{"location":"A.%20LeetCode/1.%20Data%20Structures/1.%20Auxilary%20Data%20Structures/1.5%20Stack%2C%20Queue%2C%20and%20Deque/Heap/#introduction","text":"Leetcode 973. K Closest Points Leetcode 347. Top k Largest Elements Leetcode 23. Merge K Sorted Lists Leetcode 264. Ugly Number II Leetcode 1086. High Five Leetcode 68. Merge Sorted Arrays Leetcode 692. Top K Frequent Words Leetcode 378. Kth Smallest Element in a Sorted Matrix Leetcode 295. Find Median from Data Stream Leetcode 767. Reorganize String Leetcode 1438. Longest Continuous Subarray With Absolute Diff Less Than or Equal to Limit Leetcode 895. Maximum Frequency Stack","title":"Introduction"},{"location":"A.%20LeetCode/1.%20Data%20Structures/1.%20Auxilary%20Data%20Structures/1.5%20Stack%2C%20Queue%2C%20and%20Deque/Heap/#problems-0-1-0","text":"","title":"Problems (0, 1, 0)"},{"location":"A.%20LeetCode/1.%20Data%20Structures/1.%20Auxilary%20Data%20Structures/1.5%20Stack%2C%20Queue%2C%20and%20Deque/Heap/#lc659-split-array-into-consecutive-subsequences-medium","text":"LC659. Split Array into Consecutive Subsequences (Medium) Info LC659. Split Array into Consecutive Subsequences (Medium) Algorithm: Heap Time Complexity: Space Complexity: Solution Adhoc \\(O(n^2)\\) Python 1","title":"LC659. Split Array into Consecutive Subsequences (Medium)"},{"location":"A.%20LeetCode/1.%20Data%20Structures/1.%20Auxilary%20Data%20Structures/1.5%20Stack%2C%20Queue%2C%20and%20Deque/Heap/#problems","text":"ID Title Difficulty 1094 Car Pooling Medium LC1094. Car Pooling (Medium) Info LC1094. Car Pooling (Medium) Algorithm: Heap Time Complexity: \\(O(n \\log n)\\) Space Complexity: \\(O(n)\\) Solution Heap. Heap \\(O(n \\log n)\\) Python 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 class Solution : def carPooling ( self , trips : List [ List [ int ]], capacity : int ) -> bool : trips . sort ( key = lambda x : ( x [ 1 ], x [ 2 ])) heap = [] heapq . heapify ( heap ) for i in range ( len ( trips )): n , time , end = trips [ i ] while heap and time >= heap [ 0 ]: heapq . heappop ( heap ) for j in range ( n ): heapq . heappush ( heap , end ) if len ( heap ) > capacity : return False return True","title":"Problems"},{"location":"A.%20LeetCode/1.%20Data%20Structures/1.%20Auxilary%20Data%20Structures/1.5%20Stack%2C%20Queue%2C%20and%20Deque/Monotonic%20Stack/","text":"Monotonic Stack (0) \u5355\u8c03\u6808\u9898\u5e93\uff08\u517147\u9898\uff09 \u5355\u8c03\u961f\u5217\u9898\u5e93\uff08\u517111\u9898\uff09 Introduction \u57fa\u7840\u77e5\u8bc6\uff1a\u5355\u8c03\u6808\u4e00\u822c\u7528\u4e8e\u89e3\u51b3\u6570\u7ec4\u4e2d\u627e\u51fa\u6bcf\u4e2a\u6570\u5b57\u7684\u7b2c\u4e00\u4e2a\u5927\u4e8e\uff0f\u5c0f\u4e8e\u8be5\u6570\u5b57\u7684\u4f4d\u7f6e\u6216\u8005\u6570\u5b57\uff1b\u5355\u8c03\u961f\u5217\u53ea\u89c1\u8fc7\u4e00\u9053\u9898\u9700\u8981\u4f7f\u7528\uff1b\u4e0d\u8bba\u5355\u8c03\u6808\u8fd8\u662f\u5355\u8c03\u961f\u5217\uff0c\u5355\u8c03\u7684\u610f\u601d\u662f\u4fdd\u7559\u5728\u6808\u6216\u8005\u961f\u5217\u4e2d\u7684\u6570\u5b57\u662f\u5355\u8c03\u9012\u589e\u6216\u8005\u5355\u8c03\u9012\u51cf\u7684 \u5e38\u89c1\u9898\u76ee\uff1a - Leetcode 85 Maximum Rectangle - Leetcode 84 Largest Rectangle in Histogram - Leetcode 739 Daily Temperatures - Leetcode 901 Online Stock Span - Leetcode 503 Next Greater Element II - Leetcode 239 Sliding Window Maximum \uff08\u552f\u4e00\u7684\u5355\u8c03\u961f\u5217\u9898\uff09 - Leetcode 402 Remove K Digits Monotonic stack is a data structure that is able to find the nearest event (not the furthest ) for each of the \\(n\\) elements in an array of size \\(n\\) in \\(O(n)\\) time and \\(O(1)\\) space. Python 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 # # Monotonic stack to find the next bigger number. # def monotonicStack ( arr ): firstHigherValue = [ '#' ] * len ( arr ) stack = [] for i , n in enumerate ( arr ): while stack and n > stack [ - 1 ][ 1 ]: idx , value = stack . pop () # do something with (idx, value) firstHigherValue [ idx ] = n stack . append (( i , n )) return firstHigherValue arr = [ 1 , 3 , 4 , 6 , 2 , 1 , 4 , 5 ] print ( monotonicStack ( arr )) C++ 1 2 3 int binarySearch () { } Java 1 Problems (0, 0, 0)","title":"Monotonic Stack (0)"},{"location":"A.%20LeetCode/1.%20Data%20Structures/1.%20Auxilary%20Data%20Structures/1.5%20Stack%2C%20Queue%2C%20and%20Deque/Monotonic%20Stack/#monotonic-stack-0","text":"\u5355\u8c03\u6808\u9898\u5e93\uff08\u517147\u9898\uff09 \u5355\u8c03\u961f\u5217\u9898\u5e93\uff08\u517111\u9898\uff09","title":"Monotonic Stack (0)"},{"location":"A.%20LeetCode/1.%20Data%20Structures/1.%20Auxilary%20Data%20Structures/1.5%20Stack%2C%20Queue%2C%20and%20Deque/Monotonic%20Stack/#introduction","text":"\u57fa\u7840\u77e5\u8bc6\uff1a\u5355\u8c03\u6808\u4e00\u822c\u7528\u4e8e\u89e3\u51b3\u6570\u7ec4\u4e2d\u627e\u51fa\u6bcf\u4e2a\u6570\u5b57\u7684\u7b2c\u4e00\u4e2a\u5927\u4e8e\uff0f\u5c0f\u4e8e\u8be5\u6570\u5b57\u7684\u4f4d\u7f6e\u6216\u8005\u6570\u5b57\uff1b\u5355\u8c03\u961f\u5217\u53ea\u89c1\u8fc7\u4e00\u9053\u9898\u9700\u8981\u4f7f\u7528\uff1b\u4e0d\u8bba\u5355\u8c03\u6808\u8fd8\u662f\u5355\u8c03\u961f\u5217\uff0c\u5355\u8c03\u7684\u610f\u601d\u662f\u4fdd\u7559\u5728\u6808\u6216\u8005\u961f\u5217\u4e2d\u7684\u6570\u5b57\u662f\u5355\u8c03\u9012\u589e\u6216\u8005\u5355\u8c03\u9012\u51cf\u7684 \u5e38\u89c1\u9898\u76ee\uff1a - Leetcode 85 Maximum Rectangle - Leetcode 84 Largest Rectangle in Histogram - Leetcode 739 Daily Temperatures - Leetcode 901 Online Stock Span - Leetcode 503 Next Greater Element II - Leetcode 239 Sliding Window Maximum \uff08\u552f\u4e00\u7684\u5355\u8c03\u961f\u5217\u9898\uff09 - Leetcode 402 Remove K Digits Monotonic stack is a data structure that is able to find the nearest event (not the furthest ) for each of the \\(n\\) elements in an array of size \\(n\\) in \\(O(n)\\) time and \\(O(1)\\) space. Python 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 # # Monotonic stack to find the next bigger number. # def monotonicStack ( arr ): firstHigherValue = [ '#' ] * len ( arr ) stack = [] for i , n in enumerate ( arr ): while stack and n > stack [ - 1 ][ 1 ]: idx , value = stack . pop () # do something with (idx, value) firstHigherValue [ idx ] = n stack . append (( i , n )) return firstHigherValue arr = [ 1 , 3 , 4 , 6 , 2 , 1 , 4 , 5 ] print ( monotonicStack ( arr )) C++ 1 2 3 int binarySearch () { } Java 1","title":"Introduction"},{"location":"A.%20LeetCode/1.%20Data%20Structures/1.%20Auxilary%20Data%20Structures/1.5%20Stack%2C%20Queue%2C%20and%20Deque/Monotonic%20Stack/#problems-0-0-0","text":"","title":"Problems (0, 0, 0)"},{"location":"A.%20LeetCode/1.%20Data%20Structures/1.4%20Linked%20List%2C%20Array%2C%20String/Binary%20Search/","text":"Binary Search (6) Introduction \u57fa\u7840\u77e5\u8bc6\uff1a\u4e8c\u5206\u6cd5\u662f\u7528\u6765\u89e3\u6cd5\u57fa\u672c\u6a21\u677f\uff0c\u65f6\u95f4\u590d\u6742\u5ea6logN\uff1b\u5e38\u89c1\u7684\u4e8c\u5206\u6cd5\u9898\u76ee\u53ef\u4ee5\u5206\u4e3a\u4e24\u5927\u7c7b\uff0c\u663e\u5f0f\u4e0e\u9690\u5f0f\uff0c\u5373\u662f\u5426\u80fd\u4ece\u5b57\u9762\u4e0a\u4e00\u773c\u770b\u51fa\u4e8c\u5206\u6cd5\u7684\u7279\u70b9\uff1a\u8981\u67e5\u627e\u7684\u6570\u636e\u662f\u5426\u53ef\u4ee5\u5206\u4e3a\u4e24\u90e8\u5206\uff0c\u524d\u534a\u90e8\u5206\u4e3aX\uff0c\u540e\u534a\u90e8\u5206\u4e3aO Binary Search Problem Notes JZ068. \u5251\u6307 Offer II 068. \u67e5\u627e\u63d2\u5165\u4f4d\u7f6e JZ068. \u5251\u6307 Offer II 068. \u67e5\u627e\u63d2\u5165\u4f4d\u7f6e (Easy) Info JZ068. \u5251\u6307 Offer II 068. \u67e5\u627e\u63d2\u5165\u4f4d\u7f6e (Easy) Algorithm: Binary Search Time Complexity: \\(O(\\log n)\\) Space Complexity: \\(O(1)\\) Solution Binary Search. Binary Search \\(O(\\log n)\\) Python 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 class Solution : def searchInsert ( self , nums : List [ int ], target : int ) -> int : left , right = 0 , len ( nums ) - 1 while left <= right : mid = ( left + right ) // 2 if nums [ mid ] == target : return mid elif target < nums [ mid ]: right = mid - 1 else : left = mid + 1 return left Binary Search \u663e\u5f0f\u4e8c\u5206\u6cd5\uff1a Leetcode 34. Find First and Last Position of Element in Sorted Array Leetcode 33. Search in Rotated Sorted Array Leetcode 1095. Find in Mountain Array Leetcode 162. Find Peak Element Leetcode 278. First Bad Version Leetcode 74. Search a 2D Matrix Leetcode 240. Search a 2D Matrix II \u9690\u5f0f\u4e8c\u5206\u6cd5\uff1a Leetcode 69. Sqrt(x) Leetcode 540. Single Element in a Sorted Array Leetcode 644. Maximum Average Subarray II Leetcode 528. Random Pick with Weight Leetcode 1300. Sum of Mutated Array Closest to Target Leetcode 1060. Missing Element in Sorted Array \u9898\u76ee\u5206\u7c7b \u9898\u76ee\u7f16\u53f7 \u4e8c\u5206\u67e5\u627e\u5e94\u7528(\u7b80\u5355) 374\u300135\u3001278\u3001367\u300169\u3001441 \u4e8c\u5206\u67e5\u627e\u5e94\u7528(\u4e2d\u7b49) 34\u3001540\u3001275\u3001436\u3001300\u3001354\u3001658\u3001162\u30014 \u4e8c\u5206\u67e5\u627e\u4e0e\u65cb\u8f6c\u6570\u7ec4 153\u3001154\u300133\u300181 \u4e8c\u5206\u67e5\u627e\u4e0e\u77e9\u9635 74\u3001240 \u4e8c\u5206\u7b54\u6848\u6cd5 378\u3001668\u3001410\u3001483 Binary search is an algorithm that finds a target number in a sorted array in \\(O(\\log n)\\) time. Python 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 def binarySearch ( arr , target ): left , right = 0 , len ( arr ) - 1 while left <= right : mid = ( left + right ) // 2 if target == arr [ mid ]: return mid elif target < arr [ mid ]: right = mid - 1 else : left = mid + 1 return - 1 arr = [ 1 , 2 , 3 , 4 , 5 ] for n in range ( 0 , 7 ): print ( f ' { n } : { binarySearch ( arr , n ) } ' ) C++ 1 2 3 int binarySearch () { } Java 1 Problems ID Title Difficulty 704 Binary Search Medium 1011 Capacity To Ship Packages Within D Days Medium 1642 Furthest Building You Can Reach Medium 34 Find First and Last Position of Element in Sorted Array Medium 162 162. Find Peak Element Medium 1095 1095. Find in Mountain Array Hard LC704. Binary Search (Easy) Info LC704. Binary Search (Easy) Algorithm: Binary Search Time Complexity: \\(O(\\log n)\\) Space Complexity: \\(O(1)\\) Solution This is a standard binary search problem. Binary Search O(n) Python 1 2 3 4 5 6 7 8 9 10 11 12 13 class Solution : def search ( self , nums : List [ int ], target : int ) -> int : left , right = 0 , len ( nums ) - 1 while left <= right : mid = ( left + right ) // 2 if target == nums [ mid ]: return mid elif target < nums [ mid ]: right = mid - 1 else : left = mid + 1 return - 1 LC1011. Capacity To Ship Packages Within D Days (Medium) Info LC1011. Capacity To Ship Packages Within D Days (Medium) Algorithm: Binary Search Time Complexity: \\(O(n\\log(S))\\) , where \\(S\\) is the sum of all weights. Space Complexity: \\(O(1)\\) Solution Binary search for the \\(\\mbox{capacity} \\in [max(weights), sum(weights)]\\) . For each of these \\(O(\\log n)\\) capacity, it costs \\(O(n)\\) to check if the plan can be delivered. Total cost is thus \\(O(n \\log n)\\) . Binary Search \\(O(n\\log(S))\\) Python 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 class Solution : def canDeliver ( self , weights , capacity , days ) -> bool : i = 0 for d in range ( days ): load = 0 while load <= capacity and i < len ( weights ): load += weights [ i ] i += 1 if load > capacity : load -= weights [ i - 1 ] i -= 1 elif i >= len ( weights ): return True return False def shipWithinDays ( self , weights : List [ int ], days : int ) -> int : minCap , maxCap = max ( weights ), sum ( weights ) while minCap <= maxCap : capacity = ( minCap + maxCap ) // 2 if self . canDeliver ( weights , capacity , days ): maxCap = capacity - 1 else : minCap = capacity + 1 return minCap LC1642. Furthest Building You Can Reach (Medium) Info LC1642. Furthest Building You Can Reach (Medium) Algorithm: Binary Search Time Complexity: \\(O(n\\log n)\\) Space Complexity: \\(O(1)\\) Solution Binary search to propose the furthest building you try to reach, which costs \\(O(\\log n)\\) . Within each proposal, it takes \\(O(n)\\) to check if you are indeed able to finish. Total cost is thus \\(O(n \\log n)\\) . Binary Search \\(O(n\\log n)\\) Python 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 class Solution : def canFinish ( self , heights , bricks , ladders ) -> bool : steps = sorted ([ heights [ i ] - heights [ i - 1 ] for i in range ( 1 , len ( heights )) if heights [ i ] - heights [ i - 1 ] > 0 ]) if not steps : return True if ladders == 0 : return bricks >= sum ( steps ) return bricks >= sum ( steps [: - ladders ]) def furthestBuilding ( self , heights : List [ int ], bricks : int , ladders : int ) -> int : left , right = 0 , len ( heights ) - 1 while left <= right : mid = ( left + right ) // 2 if self . canFinish ( heights [: mid + 1 ], bricks , ladders ): left = mid + 1 else : right = mid - 1 return max ( 0 , right ) LC34. Find First and Last Position of Element in Sorted Array (Medium) Info LC34. Find First and Last Position of Element in Sorted Array (Medium) Algorithm: Binary Search Time Complexity: \\(O(\\log n)\\) Space Complexity: \\(O(1)\\) Solution Main Method O(n) Python 1 LC162. Find Peak Element (Medium) Info LC162. Find Peak Element (Medium) Algorithm: Binary Search Time Complexity: \\(O(\\log n)\\) Space Complexity: \\(O(1)\\) Solution Binary Search \\(O(n)\\) Python 1 class Solution: def findPeakElement(self, nums: List[int]) -> int: if nums[0] == max(nums): return 0 if nums[-1] == max(nums): return len(nums) - 1 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 left, right = 1, len(nums) - 2 while left <= right: mid = (left + right) // 2 leftSlope, rightSlope = nums[mid] - nums[mid-1], nums[mid+1] - nums[mid] if leftSlope > 0 and rightSlope > 0: left = mid + 1 elif leftSlope < 0 and rightSlope < 0: right = mid - 1 elif leftSlope > 0 and rightSlope < 0: return mid elif nums[right] > nums[left]: left = left + 1 else: right = right - 1 return -1 LC1095. Find in Mountain Array (Medium) Info LC1095. Find in Mountain Array (Medium) Algorithm: Binary Search Time Complexity: \\(O(\\log n)\\) Space Complexity: \\(O(1)\\) Solution Binary Search \\(O(n)\\) Python 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 class Solution : def findInMountainArray ( self , target : int , mountain_arr : 'MountainArray' ) -> int : L = mountain_arr . length () # find the peak left , right = 0 , L - 1 while left <= right : mid = ( left + right ) // 2 if mountain_arr . get ( mid + 1 ) - mountain_arr . get ( mid ) > 0 : left = mid + 1 else : right = mid - 1 peak = left # search in the left left , right = 0 , peak while left <= right : mid = ( left + right ) // 2 val = mountain_arr . get ( mid ) if target == val : return mid elif target < val : right = mid - 1 else : left = mid + 1 # search in the right left , right = peak , L - 1 while left <= right : mid = ( left + right ) // 2 val = mountain_arr . get ( mid ) if target == val : return mid elif target < val : left = mid + 1 else : right = mid - 1 return - 1","title":"Binary Search (6)"},{"location":"A.%20LeetCode/1.%20Data%20Structures/1.4%20Linked%20List%2C%20Array%2C%20String/Binary%20Search/#binary-search-6","text":"","title":"Binary Search (6)"},{"location":"A.%20LeetCode/1.%20Data%20Structures/1.4%20Linked%20List%2C%20Array%2C%20String/Binary%20Search/#introduction","text":"\u57fa\u7840\u77e5\u8bc6\uff1a\u4e8c\u5206\u6cd5\u662f\u7528\u6765\u89e3\u6cd5\u57fa\u672c\u6a21\u677f\uff0c\u65f6\u95f4\u590d\u6742\u5ea6logN\uff1b\u5e38\u89c1\u7684\u4e8c\u5206\u6cd5\u9898\u76ee\u53ef\u4ee5\u5206\u4e3a\u4e24\u5927\u7c7b\uff0c\u663e\u5f0f\u4e0e\u9690\u5f0f\uff0c\u5373\u662f\u5426\u80fd\u4ece\u5b57\u9762\u4e0a\u4e00\u773c\u770b\u51fa\u4e8c\u5206\u6cd5\u7684\u7279\u70b9\uff1a\u8981\u67e5\u627e\u7684\u6570\u636e\u662f\u5426\u53ef\u4ee5\u5206\u4e3a\u4e24\u90e8\u5206\uff0c\u524d\u534a\u90e8\u5206\u4e3aX\uff0c\u540e\u534a\u90e8\u5206\u4e3aO","title":"Introduction"},{"location":"A.%20LeetCode/1.%20Data%20Structures/1.4%20Linked%20List%2C%20Array%2C%20String/Binary%20Search/#binary-search","text":"Problem Notes JZ068. \u5251\u6307 Offer II 068. \u67e5\u627e\u63d2\u5165\u4f4d\u7f6e JZ068. \u5251\u6307 Offer II 068. \u67e5\u627e\u63d2\u5165\u4f4d\u7f6e (Easy) Info JZ068. \u5251\u6307 Offer II 068. \u67e5\u627e\u63d2\u5165\u4f4d\u7f6e (Easy) Algorithm: Binary Search Time Complexity: \\(O(\\log n)\\) Space Complexity: \\(O(1)\\) Solution Binary Search. Binary Search \\(O(\\log n)\\) Python 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 class Solution : def searchInsert ( self , nums : List [ int ], target : int ) -> int : left , right = 0 , len ( nums ) - 1 while left <= right : mid = ( left + right ) // 2 if nums [ mid ] == target : return mid elif target < nums [ mid ]: right = mid - 1 else : left = mid + 1 return left","title":"Binary Search"},{"location":"A.%20LeetCode/1.%20Data%20Structures/1.4%20Linked%20List%2C%20Array%2C%20String/Binary%20Search/#binary-search_1","text":"","title":"Binary Search"},{"location":"A.%20LeetCode/1.%20Data%20Structures/1.4%20Linked%20List%2C%20Array%2C%20String/Binary%20Search/#_1","text":"Leetcode 34. Find First and Last Position of Element in Sorted Array Leetcode 33. Search in Rotated Sorted Array Leetcode 1095. Find in Mountain Array Leetcode 162. Find Peak Element Leetcode 278. First Bad Version Leetcode 74. Search a 2D Matrix Leetcode 240. Search a 2D Matrix II","title":"\u663e\u5f0f\u4e8c\u5206\u6cd5\uff1a"},{"location":"A.%20LeetCode/1.%20Data%20Structures/1.4%20Linked%20List%2C%20Array%2C%20String/Binary%20Search/#_2","text":"Leetcode 69. Sqrt(x) Leetcode 540. Single Element in a Sorted Array Leetcode 644. Maximum Average Subarray II Leetcode 528. Random Pick with Weight Leetcode 1300. Sum of Mutated Array Closest to Target Leetcode 1060. Missing Element in Sorted Array","title":"\u9690\u5f0f\u4e8c\u5206\u6cd5\uff1a"},{"location":"A.%20LeetCode/1.%20Data%20Structures/1.4%20Linked%20List%2C%20Array%2C%20String/Binary%20Search/#_3","text":"\u4e8c\u5206\u67e5\u627e\u5e94\u7528(\u7b80\u5355) 374\u300135\u3001278\u3001367\u300169\u3001441 \u4e8c\u5206\u67e5\u627e\u5e94\u7528(\u4e2d\u7b49) 34\u3001540\u3001275\u3001436\u3001300\u3001354\u3001658\u3001162\u30014 \u4e8c\u5206\u67e5\u627e\u4e0e\u65cb\u8f6c\u6570\u7ec4 153\u3001154\u300133\u300181 \u4e8c\u5206\u67e5\u627e\u4e0e\u77e9\u9635 74\u3001240 \u4e8c\u5206\u7b54\u6848\u6cd5 378\u3001668\u3001410\u3001483 Binary search is an algorithm that finds a target number in a sorted array in \\(O(\\log n)\\) time. Python 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 def binarySearch ( arr , target ): left , right = 0 , len ( arr ) - 1 while left <= right : mid = ( left + right ) // 2 if target == arr [ mid ]: return mid elif target < arr [ mid ]: right = mid - 1 else : left = mid + 1 return - 1 arr = [ 1 , 2 , 3 , 4 , 5 ] for n in range ( 0 , 7 ): print ( f ' { n } : { binarySearch ( arr , n ) } ' ) C++ 1 2 3 int binarySearch () { } Java 1","title":"\u9898\u76ee\u5206\u7c7b  \u9898\u76ee\u7f16\u53f7"},{"location":"A.%20LeetCode/1.%20Data%20Structures/1.4%20Linked%20List%2C%20Array%2C%20String/Binary%20Search/#problems","text":"ID Title Difficulty 704 Binary Search Medium 1011 Capacity To Ship Packages Within D Days Medium 1642 Furthest Building You Can Reach Medium 34 Find First and Last Position of Element in Sorted Array Medium 162 162. Find Peak Element Medium 1095 1095. Find in Mountain Array Hard LC704. Binary Search (Easy) Info LC704. Binary Search (Easy) Algorithm: Binary Search Time Complexity: \\(O(\\log n)\\) Space Complexity: \\(O(1)\\) Solution This is a standard binary search problem. Binary Search O(n) Python 1 2 3 4 5 6 7 8 9 10 11 12 13 class Solution : def search ( self , nums : List [ int ], target : int ) -> int : left , right = 0 , len ( nums ) - 1 while left <= right : mid = ( left + right ) // 2 if target == nums [ mid ]: return mid elif target < nums [ mid ]: right = mid - 1 else : left = mid + 1 return - 1 LC1011. Capacity To Ship Packages Within D Days (Medium) Info LC1011. Capacity To Ship Packages Within D Days (Medium) Algorithm: Binary Search Time Complexity: \\(O(n\\log(S))\\) , where \\(S\\) is the sum of all weights. Space Complexity: \\(O(1)\\) Solution Binary search for the \\(\\mbox{capacity} \\in [max(weights), sum(weights)]\\) . For each of these \\(O(\\log n)\\) capacity, it costs \\(O(n)\\) to check if the plan can be delivered. Total cost is thus \\(O(n \\log n)\\) . Binary Search \\(O(n\\log(S))\\) Python 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 class Solution : def canDeliver ( self , weights , capacity , days ) -> bool : i = 0 for d in range ( days ): load = 0 while load <= capacity and i < len ( weights ): load += weights [ i ] i += 1 if load > capacity : load -= weights [ i - 1 ] i -= 1 elif i >= len ( weights ): return True return False def shipWithinDays ( self , weights : List [ int ], days : int ) -> int : minCap , maxCap = max ( weights ), sum ( weights ) while minCap <= maxCap : capacity = ( minCap + maxCap ) // 2 if self . canDeliver ( weights , capacity , days ): maxCap = capacity - 1 else : minCap = capacity + 1 return minCap LC1642. Furthest Building You Can Reach (Medium) Info LC1642. Furthest Building You Can Reach (Medium) Algorithm: Binary Search Time Complexity: \\(O(n\\log n)\\) Space Complexity: \\(O(1)\\) Solution Binary search to propose the furthest building you try to reach, which costs \\(O(\\log n)\\) . Within each proposal, it takes \\(O(n)\\) to check if you are indeed able to finish. Total cost is thus \\(O(n \\log n)\\) . Binary Search \\(O(n\\log n)\\) Python 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 class Solution : def canFinish ( self , heights , bricks , ladders ) -> bool : steps = sorted ([ heights [ i ] - heights [ i - 1 ] for i in range ( 1 , len ( heights )) if heights [ i ] - heights [ i - 1 ] > 0 ]) if not steps : return True if ladders == 0 : return bricks >= sum ( steps ) return bricks >= sum ( steps [: - ladders ]) def furthestBuilding ( self , heights : List [ int ], bricks : int , ladders : int ) -> int : left , right = 0 , len ( heights ) - 1 while left <= right : mid = ( left + right ) // 2 if self . canFinish ( heights [: mid + 1 ], bricks , ladders ): left = mid + 1 else : right = mid - 1 return max ( 0 , right ) LC34. Find First and Last Position of Element in Sorted Array (Medium) Info LC34. Find First and Last Position of Element in Sorted Array (Medium) Algorithm: Binary Search Time Complexity: \\(O(\\log n)\\) Space Complexity: \\(O(1)\\) Solution Main Method O(n) Python 1 LC162. Find Peak Element (Medium) Info LC162. Find Peak Element (Medium) Algorithm: Binary Search Time Complexity: \\(O(\\log n)\\) Space Complexity: \\(O(1)\\) Solution Binary Search \\(O(n)\\) Python 1 class Solution: def findPeakElement(self, nums: List[int]) -> int: if nums[0] == max(nums): return 0 if nums[-1] == max(nums): return len(nums) - 1 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 left, right = 1, len(nums) - 2 while left <= right: mid = (left + right) // 2 leftSlope, rightSlope = nums[mid] - nums[mid-1], nums[mid+1] - nums[mid] if leftSlope > 0 and rightSlope > 0: left = mid + 1 elif leftSlope < 0 and rightSlope < 0: right = mid - 1 elif leftSlope > 0 and rightSlope < 0: return mid elif nums[right] > nums[left]: left = left + 1 else: right = right - 1 return -1 LC1095. Find in Mountain Array (Medium) Info LC1095. Find in Mountain Array (Medium) Algorithm: Binary Search Time Complexity: \\(O(\\log n)\\) Space Complexity: \\(O(1)\\) Solution Binary Search \\(O(n)\\) Python 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 class Solution : def findInMountainArray ( self , target : int , mountain_arr : 'MountainArray' ) -> int : L = mountain_arr . length () # find the peak left , right = 0 , L - 1 while left <= right : mid = ( left + right ) // 2 if mountain_arr . get ( mid + 1 ) - mountain_arr . get ( mid ) > 0 : left = mid + 1 else : right = mid - 1 peak = left # search in the left left , right = 0 , peak while left <= right : mid = ( left + right ) // 2 val = mountain_arr . get ( mid ) if target == val : return mid elif target < val : right = mid - 1 else : left = mid + 1 # search in the right left , right = peak , L - 1 while left <= right : mid = ( left + right ) // 2 val = mountain_arr . get ( mid ) if target == val : return mid elif target < val : left = mid + 1 else : right = mid - 1 return - 1","title":"Problems"},{"location":"A.%20LeetCode/1.%20Data%20Structures/1.4%20Linked%20List%2C%20Array%2C%20String/Linked%20List/","text":"= Linked List \u94fe\u8868\u7c7b\u95ee\u9898\u7684\u57fa\u7840\u662f\uff1a\u589e\u5220\u67e5\u6539\u3001\u5feb\u6162\u6307\u9488\u3001\u53cd\u8f6c\u3002 == \u57fa\u7840\u9898\u76ee\uff1a - Leetcode 206. Reverse Linked List - Leetcode 876. Middle of the Linked List == \u8fdb\u9636\u9898\u76ee: - Leetcode 160. Intersection of Two Linked Lists - Leetcode 141. Linked List Cycle (Linked List Cycle II) - Leetcode 92. Reverse Linked List II - Leetcode 328. Odd Even Linked List \u9898\u76ee\u5206\u7c7b \u9898\u76ee\u7f16\u53f7 \u94fe\u8868\u7684\u5220\u9664 203\u3001237\u300119 \u94fe\u8868\u7684\u904d\u5386 430 \u94fe\u8868\u7684\u65cb\u8f6c\u4e0e\u53cd\u8f6c 61\u300124\u3001206\u300192\u300125 \u94fe\u8868\u9ad8\u7cbe\u5ea6\u52a0\u6cd5 2\u3001445 \u94fe\u8868\u7684\u5408\u5e76 21\u300123","title":"Linked List"},{"location":"A.%20LeetCode/1.%20Data%20Structures/1.4%20Linked%20List%2C%20Array%2C%20String/String/","text":"String","title":"String"},{"location":"A.%20LeetCode/1.%20Data%20Structures/1.4%20Linked%20List%2C%20Array%2C%20String/String/#string","text":"","title":"String"},{"location":"A.%20LeetCode/1.%20Data%20Structures/1.6%20Tree/BST/","text":"BST (2) Introduction \u9898\u76ee\u5206\u7c7b \u9898\u76ee\u7f16\u53f7 \u6811\u4e0e\u9012\u5f52 100\u3001222\u3001101\u3001226\u3001437\u3001563\u3001617\u3001508\u3001572\u3001543\u3001654\u3001687\u300187 \u6811\u7684\u5c42\u6b21\u904d\u5386 102\u3001429\u3001690\u3001559\u3001662\u3001671\u3001513\u3001515\u3001637\u3001103\u3001107\u3001257\u3001623\u3001653\u3001104\u3001111\u3001112\u3001113\u3001129\u3001404\u3001199\u3001655\u3001116\u3001117 \u6811\u7684\u524d\u5e8f\u904d\u5386 144\u3001589 \u6811\u7684\u524d\u5e8f\u5e8f\u5217\u5316 606\u3001331\u3001652\u3001297\u3001449 \u6811\u7684\u540e\u5e8f\u904d\u5386 145\u3001590 \u6811\u7684\u4e2d\u5e8f\u904d\u5386\u4e0e\u4e8c\u53c9\u641c\u7d22\u6811 94\u3001700\u3001530\u3001538\u3001230\u300198\u3001173\u3001669\u3001450\u3001110\u300195\u3001108\u3001109 \u91cd\u6784\u4e8c\u53c9\u6811 105\u3001106 \u4e8c\u53c9\u6811\u7684\u5c55\u5f00 114 \u6700\u8fd1\u516c\u5171\u7956\u5148 235\u3001236 Morris\u4e2d\u5e8f\u904d\u5386 501\u300199 \u56db\u53c9\u6811 558\u3001427 [https://techiedelight.quora.com/500-Data-Structures-and-Algorithms-practice-problems-and-their-solutions 500 Data Structures and Algorithms practice problems and their solutions] \u9ec4\u7eff\u84dd [https://en.wikipedia.org/wiki/List_of_data_structures list of DS] [https://www.youtube.com/channel/UCcdCkJKXlRoXVD03eo-q8mQ Coding Interview Problems] [https://www.topcoder.com/] [http://www.geeksforgeeks.org/] [https://www.interviewbit.com/] [http://ravindrababuravula.com/] [http://freevideolectures.com/] Algorithm Tricks: Reservoir Sampling [http://visualgo.net] [https://www.cs.usfca.edu/~galles/visualization/Algorithms.html] = Tree Map \u57fa\u7840\u77e5\u8bc6\uff1a\u57fa\u4e8e\u7ea2\u9ed1\u6811\uff08\u5e73\u8861\u4e8c\u53c9\u641c\u7d22\u6811\uff09\u7684\u4e00\u79cd\u6811\u72b6 hashmap\uff0c\u589e\u5220\u67e5\u6539\u3001\u627e\u6c42\u5927\u6700\u5c0f\u5747\u4e3alogN\u590d\u6742\u5ea6\uff0cPython\u5f53\u4e2d\u53ef\u4ee5\u4f7f\u7528SortedDict\u66ff\u4ee3 \u5e38\u89c1\u9898\u76ee\uff1a Leetcode 729 My Calendar I Leetcode 981 Time Based Key-Value Store Leetcode 846 Hand of Straights Leetcode 826 Most Profit Assigning Work Problems (0, 1, 0) Problem Type Info Data Structure Algorithm LC654. Maximum Binary Tree 2D Structured FindAll No No Recursion","title":"BST (2)"},{"location":"A.%20LeetCode/1.%20Data%20Structures/1.6%20Tree/BST/#bst-2","text":"","title":"BST (2)"},{"location":"A.%20LeetCode/1.%20Data%20Structures/1.6%20Tree/BST/#introduction","text":"\u9898\u76ee\u5206\u7c7b \u9898\u76ee\u7f16\u53f7 \u6811\u4e0e\u9012\u5f52 100\u3001222\u3001101\u3001226\u3001437\u3001563\u3001617\u3001508\u3001572\u3001543\u3001654\u3001687\u300187 \u6811\u7684\u5c42\u6b21\u904d\u5386 102\u3001429\u3001690\u3001559\u3001662\u3001671\u3001513\u3001515\u3001637\u3001103\u3001107\u3001257\u3001623\u3001653\u3001104\u3001111\u3001112\u3001113\u3001129\u3001404\u3001199\u3001655\u3001116\u3001117 \u6811\u7684\u524d\u5e8f\u904d\u5386 144\u3001589 \u6811\u7684\u524d\u5e8f\u5e8f\u5217\u5316 606\u3001331\u3001652\u3001297\u3001449 \u6811\u7684\u540e\u5e8f\u904d\u5386 145\u3001590 \u6811\u7684\u4e2d\u5e8f\u904d\u5386\u4e0e\u4e8c\u53c9\u641c\u7d22\u6811 94\u3001700\u3001530\u3001538\u3001230\u300198\u3001173\u3001669\u3001450\u3001110\u300195\u3001108\u3001109 \u91cd\u6784\u4e8c\u53c9\u6811 105\u3001106 \u4e8c\u53c9\u6811\u7684\u5c55\u5f00 114 \u6700\u8fd1\u516c\u5171\u7956\u5148 235\u3001236 Morris\u4e2d\u5e8f\u904d\u5386 501\u300199 \u56db\u53c9\u6811 558\u3001427 [https://techiedelight.quora.com/500-Data-Structures-and-Algorithms-practice-problems-and-their-solutions 500 Data Structures and Algorithms practice problems and their solutions] \u9ec4\u7eff\u84dd [https://en.wikipedia.org/wiki/List_of_data_structures list of DS] [https://www.youtube.com/channel/UCcdCkJKXlRoXVD03eo-q8mQ Coding Interview Problems] [https://www.topcoder.com/] [http://www.geeksforgeeks.org/] [https://www.interviewbit.com/] [http://ravindrababuravula.com/] [http://freevideolectures.com/] Algorithm Tricks: Reservoir Sampling [http://visualgo.net] [https://www.cs.usfca.edu/~galles/visualization/Algorithms.html] = Tree Map \u57fa\u7840\u77e5\u8bc6\uff1a\u57fa\u4e8e\u7ea2\u9ed1\u6811\uff08\u5e73\u8861\u4e8c\u53c9\u641c\u7d22\u6811\uff09\u7684\u4e00\u79cd\u6811\u72b6 hashmap\uff0c\u589e\u5220\u67e5\u6539\u3001\u627e\u6c42\u5927\u6700\u5c0f\u5747\u4e3alogN\u590d\u6742\u5ea6\uff0cPython\u5f53\u4e2d\u53ef\u4ee5\u4f7f\u7528SortedDict\u66ff\u4ee3 \u5e38\u89c1\u9898\u76ee\uff1a Leetcode 729 My Calendar I Leetcode 981 Time Based Key-Value Store Leetcode 846 Hand of Straights Leetcode 826 Most Profit Assigning Work","title":"Introduction"},{"location":"A.%20LeetCode/1.%20Data%20Structures/1.6%20Tree/BST/#problems-0-1-0","text":"Problem Type Info Data Structure Algorithm LC654. Maximum Binary Tree 2D Structured FindAll No No Recursion","title":"Problems (0, 1, 0)"},{"location":"A.%20LeetCode/1.%20Data%20Structures/1.6%20Tree/Binary%20Indexed%20Tree/","text":"Binary Indexed Tree","title":"Binary Indexed Tree"},{"location":"A.%20LeetCode/1.%20Data%20Structures/1.6%20Tree/Binary%20Indexed%20Tree/#binary-indexed-tree","text":"","title":"Binary Indexed Tree"},{"location":"A.%20LeetCode/1.%20Data%20Structures/1.6%20Tree/Line%20Sweep/","text":"Line Sweep","title":"Line Sweep"},{"location":"A.%20LeetCode/1.%20Data%20Structures/1.6%20Tree/Line%20Sweep/#line-sweep","text":"","title":"Line Sweep"},{"location":"A.%20LeetCode/1.%20Data%20Structures/1.6%20Tree/Segment%20Tree/","text":"Segment Tree","title":"Segment Tree"},{"location":"A.%20LeetCode/1.%20Data%20Structures/1.6%20Tree/Segment%20Tree/#segment-tree","text":"","title":"Segment Tree"},{"location":"A.%20LeetCode/1.%20Data%20Structures/1.6%20Tree/Trie/","text":"Trie (2) Trie \u57fa\u7840\u77e5\u8bc6\uff1a\uff08https://zh.wikipedia.org/wiki/Trie\uff09\uff1b\u591a\u6570\u60c5\u51b5\u4e0b\u53ef\u4ee5\u901a\u8fc7\u7528\u4e00\u4e2aset\u6765\u8bb0\u5f55\u6240\u6709\u5355\u8bcd\u7684prefix\u6765\u66ff\u4ee3\uff0c\u65f6\u95f4\u590d\u6742\u5ea6\u4e0d\u53d8\uff0c\u4f46\u7a7a\u95f4\u590d\u6742\u5ea6\u7565\u9ad8 \u5e38\u89c1\u9898\u76ee\uff1a - Leetcode 208 Implement Trie (Prefix Tree) - Leetcode 211 Design Add and Search Words Data Structure - Leetcode 1268 Search Suggestions System - Leetcode 79 Word Search ID Title Difficulty LC208 Implement Trie (Prefix Tree) Medium LC720 Longest Word in Dictionary Easy LC421 Maximum XOR of Two Numbers in an Array Medium LC1707 Maximum XOR With an Element From Array Medium LC384 Shuffle an Array Medium LC208. Implement Trie (Prefix Tree) (Medium) Info LC208. Implement Trie (Prefix Tree) (Medium) Algorithm: Trie Time Complexity: \\(O(n)\\) Space Complexity: \\(O(n)\\) Solution Trie. Trie \\(O(n)\\) Python 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 class Trie : def __init__ ( self ): \"\"\" Initialize your data structure here. \"\"\" self . nextNode = {} self . wordExist = False def insert ( self , word : str ) -> None : \"\"\" Inserts a word into the trie. \"\"\" node = self for ch in word : if ch not in node . nextNode : node . nextNode [ ch ] = Trie () node = node . nextNode [ ch ] node . wordExist = True def searchPrefix ( self , prefix : str ) -> \"Trie\" : node = self for ch in prefix : if ch not in node . nextNode : return None node = node . nextNode [ ch ] return node def search ( self , word : str ) -> bool : \"\"\" Returns if the word is in the trie. \"\"\" node = self . searchPrefix ( word ) return node is not None and node . wordExist def startsWith ( self , prefix : str ) -> bool : \"\"\" Returns if there is any word in the trie that starts with the given prefix. \"\"\" return self . searchPrefix ( prefix ) is not None LC720. Longest Word in Dictionary (Easy) Info LC720. Longest Word in Dictionary (Easy) Algorithm: Trie Time Complexity: \\(O(n)\\) Space Complexity: \\(O(1)\\) Solution Trie. Trie \\(O(n)\\) Python 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 class Trie : def __init__ ( self ): self . nextNode = {} self . wordExist = False def add ( self , word : str ): node = self for ch in word : if ch not in node . nextNode : node . nextNode [ ch ] = Trie () node = node . nextNode [ ch ] node . wordExist = True def check ( self , word : str ) -> bool : node = self for i , ch in enumerate ( word ): if ch not in node . nextNode or not node . nextNode [ ch ] . wordExist : return False node = node . nextNode [ ch ] return node . wordExist class Solution : def longestWord ( self , words : List [ str ]) -> str : words . sort () T = Trie () for word in words : T . add ( word ) ans = \"\" for word in words : if len ( word ) > len ( ans ) and T . check ( word ): ans = word return ans LC421. Maximum XOR of Two Numbers in an Array (Medium) Info LC421. Maximum XOR of Two Numbers in an Array (Medium) Algorithm: Trie Time Complexity: \\(O(n)\\) Space Complexity: \\(O(n)\\) Solution Trie. Trie \\(O(n)\\) Python 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 class Trie : def __init__ ( self ): self . nextCh = {} def add ( self , word : str ): node = self for ch in word : if ch not in node . nextCh : node . nextCh [ ch ] = Trie () node = node . nextCh [ ch ] node . nextCh [ '#' ] = None def maxXOR ( self , word : str ) -> int : ans = \"\" node = self for ch in word : if ch == '0' : if '1' in node . nextCh : node = node . nextCh [ '1' ] ans += '1' else : node = node . nextCh [ '0' ] ans += '0' else : if '0' in node . nextCh : node = node . nextCh [ '0' ] ans += '1' else : node = node . nextCh [ '1' ] ans += '0' return int ( ans , 2 ) class Solution : def findMaximumXOR ( self , nums : List [ int ]) -> int : T = Trie () B = [] for n in nums : b = bin ( n )[ 2 :] L = len ( b ) B . append ( '0' * ( 32 - L ) + b ) for b in B : T . add ( b ) ans = 0 for b in B : ans = max ( ans , T . maxXOR ( b )) return ans","title":"Trie (2)"},{"location":"A.%20LeetCode/1.%20Data%20Structures/1.6%20Tree/Trie/#trie-2","text":"","title":"Trie (2)"},{"location":"A.%20LeetCode/1.%20Data%20Structures/1.6%20Tree/Trie/#trie","text":"\u57fa\u7840\u77e5\u8bc6\uff1a\uff08https://zh.wikipedia.org/wiki/Trie\uff09\uff1b\u591a\u6570\u60c5\u51b5\u4e0b\u53ef\u4ee5\u901a\u8fc7\u7528\u4e00\u4e2aset\u6765\u8bb0\u5f55\u6240\u6709\u5355\u8bcd\u7684prefix\u6765\u66ff\u4ee3\uff0c\u65f6\u95f4\u590d\u6742\u5ea6\u4e0d\u53d8\uff0c\u4f46\u7a7a\u95f4\u590d\u6742\u5ea6\u7565\u9ad8 \u5e38\u89c1\u9898\u76ee\uff1a - Leetcode 208 Implement Trie (Prefix Tree) - Leetcode 211 Design Add and Search Words Data Structure - Leetcode 1268 Search Suggestions System - Leetcode 79 Word Search ID Title Difficulty LC208 Implement Trie (Prefix Tree) Medium LC720 Longest Word in Dictionary Easy LC421 Maximum XOR of Two Numbers in an Array Medium LC1707 Maximum XOR With an Element From Array Medium LC384 Shuffle an Array Medium LC208. Implement Trie (Prefix Tree) (Medium) Info LC208. Implement Trie (Prefix Tree) (Medium) Algorithm: Trie Time Complexity: \\(O(n)\\) Space Complexity: \\(O(n)\\) Solution Trie. Trie \\(O(n)\\) Python 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 class Trie : def __init__ ( self ): \"\"\" Initialize your data structure here. \"\"\" self . nextNode = {} self . wordExist = False def insert ( self , word : str ) -> None : \"\"\" Inserts a word into the trie. \"\"\" node = self for ch in word : if ch not in node . nextNode : node . nextNode [ ch ] = Trie () node = node . nextNode [ ch ] node . wordExist = True def searchPrefix ( self , prefix : str ) -> \"Trie\" : node = self for ch in prefix : if ch not in node . nextNode : return None node = node . nextNode [ ch ] return node def search ( self , word : str ) -> bool : \"\"\" Returns if the word is in the trie. \"\"\" node = self . searchPrefix ( word ) return node is not None and node . wordExist def startsWith ( self , prefix : str ) -> bool : \"\"\" Returns if there is any word in the trie that starts with the given prefix. \"\"\" return self . searchPrefix ( prefix ) is not None LC720. Longest Word in Dictionary (Easy) Info LC720. Longest Word in Dictionary (Easy) Algorithm: Trie Time Complexity: \\(O(n)\\) Space Complexity: \\(O(1)\\) Solution Trie. Trie \\(O(n)\\) Python 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 class Trie : def __init__ ( self ): self . nextNode = {} self . wordExist = False def add ( self , word : str ): node = self for ch in word : if ch not in node . nextNode : node . nextNode [ ch ] = Trie () node = node . nextNode [ ch ] node . wordExist = True def check ( self , word : str ) -> bool : node = self for i , ch in enumerate ( word ): if ch not in node . nextNode or not node . nextNode [ ch ] . wordExist : return False node = node . nextNode [ ch ] return node . wordExist class Solution : def longestWord ( self , words : List [ str ]) -> str : words . sort () T = Trie () for word in words : T . add ( word ) ans = \"\" for word in words : if len ( word ) > len ( ans ) and T . check ( word ): ans = word return ans LC421. Maximum XOR of Two Numbers in an Array (Medium) Info LC421. Maximum XOR of Two Numbers in an Array (Medium) Algorithm: Trie Time Complexity: \\(O(n)\\) Space Complexity: \\(O(n)\\) Solution Trie. Trie \\(O(n)\\) Python 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 class Trie : def __init__ ( self ): self . nextCh = {} def add ( self , word : str ): node = self for ch in word : if ch not in node . nextCh : node . nextCh [ ch ] = Trie () node = node . nextCh [ ch ] node . nextCh [ '#' ] = None def maxXOR ( self , word : str ) -> int : ans = \"\" node = self for ch in word : if ch == '0' : if '1' in node . nextCh : node = node . nextCh [ '1' ] ans += '1' else : node = node . nextCh [ '0' ] ans += '0' else : if '0' in node . nextCh : node = node . nextCh [ '0' ] ans += '1' else : node = node . nextCh [ '1' ] ans += '0' return int ( ans , 2 ) class Solution : def findMaximumXOR ( self , nums : List [ int ]) -> int : T = Trie () B = [] for n in nums : b = bin ( n )[ 2 :] L = len ( b ) B . append ( '0' * ( 32 - L ) + b ) for b in B : T . add ( b ) ans = 0 for b in B : ans = max ( ans , T . maxXOR ( b )) return ans","title":"Trie"},{"location":"A.%20LeetCode/1.%20Data%20Structures/1.7%20Graph/Graph/","text":"= Graph \u9898\u76ee\u5206\u7c7b \u9898\u76ee\u7f16\u53f7 \u56fe\u7684\u5efa\u7acb\u4e0e\u5e94\u7528 565 \u6df1\u5ea6\u4f18\u5148\u641c\u7d22 17\u3001397 \u56de\u6eaf\u6cd5 526\u3001401\u300136\u300137\u300151\u300152\u300177\u300139\u3001216\u300140\u300146\u300147\u300131\u3001556\u300160\u3001491\u300178\u300190\u300179\u300193\u3001332 \u56de\u6eaf\u6cd5\u4e0e\u8868\u8fbe\u5f0f 241\u3001282\u3001679 \u56de\u6eaf\u6cd5\u4e0e\u62ec\u53f7 22\u3001301 \u56de\u6eaf\u6cd5\u4e0e\u8d2a\u5fc3 488 \u5e7f\u5ea6\u4f18\u5148\u641c\u7d22 133\u3001200\u3001695\u3001463\u3001542\u3001130\u3001417\u3001529\u3001127\u3001126\u3001433\u3001675 \u5e76\u67e5\u96c6 547\u3001684\u3001685 \u62d3\u6251\u6392\u5e8f 399\u3001207\u3001210 \u6709\u9650\u72b6\u6001\u81ea\u52a8\u673a 65\u3001468","title":"Graph"},{"location":"A.%20LeetCode/1.%20Data%20Structures/1.7%20Graph/Grid/","text":"Matrix and Grid (6) Introduction Related Problems Problem Type LC378. Kth Smallest Element in a Sorted Matrix LC1351. Count Negative Numbers in a Sorted Matrix LC1439. Find the Kth Smallest Sum of a Matrix With Sorted Rows LC74. Search a 2D Matrix LC240. Search a 2D Matrix II LCCI1009. Sorted Matrix Search LCCI","title":"Matrix and Grid (6)"},{"location":"A.%20LeetCode/1.%20Data%20Structures/1.7%20Graph/Grid/#matrix-and-grid-6","text":"","title":"Matrix and Grid (6)"},{"location":"A.%20LeetCode/1.%20Data%20Structures/1.7%20Graph/Grid/#introduction","text":"","title":"Introduction"},{"location":"A.%20LeetCode/1.%20Data%20Structures/1.7%20Graph/Grid/#related-problems","text":"Problem Type LC378. Kth Smallest Element in a Sorted Matrix LC1351. Count Negative Numbers in a Sorted Matrix LC1439. Find the Kth Smallest Sum of a Matrix With Sorted Rows LC74. Search a 2D Matrix LC240. Search a 2D Matrix II LCCI1009. Sorted Matrix Search LCCI","title":"Related Problems"},{"location":"A.%20LeetCode/1.%20Data%20Structures/1.7%20Graph/Topological%20Sort/","text":"Topological Sort","title":"Topological Sort"},{"location":"A.%20LeetCode/1.%20Data%20Structures/1.7%20Graph/Topological%20Sort/#topological-sort","text":"","title":"Topological Sort"},{"location":"A.%20LeetCode/2.%20Algorithms%20and%20Tricks/DP/DP/","text":"Dynamic Programming Note that, \\(\\max\\) is not linear, that is, \\(\\max(x + y) \\ne \\max(x) + \\max(y)\\) . So in general, we may not use linear DP in problems involving \\(\\max\\) . \u9898\u53f7 \u9898\u76ee\u94fe\u63a5 \u8bb2\u89e3\u94fe\u63a5 \u8bf4\u660e \u4e00\u7ef4 70 Climbing Stairs \u89c6\u9891\u8bb2\u89e3 62 Unique Paths \u89c6\u9891\u8bb2\u89e3 63 Unique Paths II \u89c6\u9891\u8bb2\u89e3 120 Triangle \u89c6\u9891\u8bb2\u89e3 \u5f88\u5c11\u8003 279 Perfect Squares \u89c6\u9891\u8bb2\u89e3 139 Word Break \u89c6\u9891\u8bb2\u89e3 375 Guess Number Higher or Lower II \u89c6\u9891\u8bb2\u89e3 312 Burst Balloons \u89c6\u9891\u8bb2\u89e3 322 Coin Change \u89c6\u9891\u8bb2\u89e3 \u4e8c\u7ef4 256 Paint House \u89c6\u9891\u8bb2\u89e3 265 Paint House II \u89c6\u9891\u8bb2\u89e3 64 Minimum Path Sum \u89c6\u9891\u8bb2\u89e3 72 Edit Distance \u89c6\u9891\u8bb2\u89e3 97 Interleaving String \u89c6\u9891\u8bb2\u89e3 174 Dungeon Game \u89c6\u9891\u8bb2\u89e3 221 Maximal Square \u89c6\u9891\u8bb2\u89e3 85 Maximal Rectangle \u89c6\u9891\u8bb2\u89e3 363 Max Sum of Rectangle No Larger Than K \u89c6\u9891\u8bb2\u89e3 TreeSet \u5316\u7b80 198 House Robber \u89c6\u9891\u8bb2\u89e3 213 House Robber II \u89c6\u9891\u8bb2\u89e3 276 Paint Fence \u89c6\u9891\u8bb2\u89e3 91 Decode Ways \u89c6\u9891\u8bb2\u89e3 10 Regular Expression Matching \u89c6\u9891\u8bb2\u89e3 44 Wildcard Matching \u89c6\u9891\u8bb2\u89e3 \u57fa\u7840\u77e5\u8bc6\uff1a\u8fd9\u91cc\u6307\u7684\u662f\u7528for\u5faa\u73af\u65b9\u5f0f\u7684\u52a8\u6001\u89c4\u5212\uff0c\u975eMemoization Search\u65b9\u5f0f\u3002DP\u53ef\u4ee5\u5728\u591a\u9879\u5f0f\u65f6\u95f4\u590d\u6742\u5ea6\u5185\u89e3\u51b3DFS\u9700\u8981\u6307\u6570\u7ea7\u522b\u7684\u95ee\u9898\u3002\u5e38\u89c1\u7684\u9898\u76ee\u5305\u62ec\u627e\u6700\u5927\u6700\u5c0f\uff0c\u627e\u53ef\u884c\u6027\uff0c\u627e\u603b\u65b9\u6848\u6570\u7b49\uff0c\u4e00\u822c\u7ed3\u679c\u662f\u4e00\u4e2aInteger\u6216\u8005Boolean\u3002 \u5e38\u89c1\u9898\u76ee\uff1a - LeetCode 674 Longest Continuous Increasing Subsequence - LeetCode 62 Unique Paths II - LeetCode 70 Climbing Stairs - LeetCode 64 Minimum Path Sum - LeetCode 368 Largest Divisible Subset - LeetCode 300 Longest Increasing Subsequence - LeetCode 354 Russian Doll Envelopes - LeetCode 256 Paint House - LeetCode 121 Best Time to Buy and Sell Stock - LeetCode 55 Jump Game - LeetCode 45 Jump Game II - LeetCode 403 Frog Jump - LeetCode 132 Palindrome Partitioning II - LeetCode 312 Burst Balloons - LeetCode 1143 Longest Common Subsequence - LeetCode 115 Distinct Subsequences - LeetCode 72 Edit Distance - LeetCode 91 Decode Ways - LeetCode 639 Decode Ways II - LeetCode 712 Minimum ASCII Delete Sum for Two Strings - LeetCode 221 Maximal Square - LeetCode 198 House Robber - LeetCode 213 House Robber II - LeetCode 87 Scramble String - LeetCode 1062 Longest Repeating Substring - LeetCode 1140 Stone Game II - LeetCode 322 Coin Change - LeetCode 518 Coin Change II - LeetCode 97 Interleaving String \u9898\u76ee\u5206\u7c7b \u9898\u76ee\u7f16\u53f7 \u6570\u7ec4\u4e2d\u7684\u52a8\u6001\u89c4\u5212 509\u300170\u3001338\u300145\u300155\u3001198\u3001213\u3001650\u300191\u3001639\u3001552\u3001123\u3001188\u3001309\u300132\u3001264\u3001313\u3001403 \u5b50\u6570\u7ec4\u3001\u5b50\u5e8f\u5217\u4e2d\u7684\u52a8\u6001\u89c4\u5212 689\u3001413\u3001446\u3001368\u3001416\u3001279 \u80cc\u5305\u95ee\u9898 322\u3001518\u3001474\u3001494\u3001377 \u77e9\u9635\u4e2d\u7684\u52a8\u6001\u89c4\u5212 62\u300163\u300164\u3001120\u3001576\u3001688\u3001221\u3001629\u3001174\u300196\u3001329 \u52a8\u6001\u89c4\u5212\u4e0e\u5b57\u7b26\u4e32\u5339\u914d 583\u300172\u300197\u3001115\u3001516\u3001132\u3001131\u3001139\u3001140\u3001514\u300110\u300144 \u72b6\u6001\u538b\u7f29\u52a8\u6001\u89c4\u5212 464\u3001691\u3001698\u3001638\u3001473 \u533a\u95f4\u4e2d\u7684\u52a8\u6001\u89c4\u5212 486\u3001664\u3001375\u3001312\u3001546 \u6811\u5f62dp 337\u3001124 \u6570\u4f4ddp 233\u3001600","title":"Dynamic Programming"},{"location":"A.%20LeetCode/2.%20Algorithms%20and%20Tricks/DP/DP/#dynamic-programming","text":"Note that, \\(\\max\\) is not linear, that is, \\(\\max(x + y) \\ne \\max(x) + \\max(y)\\) . So in general, we may not use linear DP in problems involving \\(\\max\\) . \u9898\u53f7 \u9898\u76ee\u94fe\u63a5 \u8bb2\u89e3\u94fe\u63a5 \u8bf4\u660e \u4e00\u7ef4 70 Climbing Stairs \u89c6\u9891\u8bb2\u89e3 62 Unique Paths \u89c6\u9891\u8bb2\u89e3 63 Unique Paths II \u89c6\u9891\u8bb2\u89e3 120 Triangle \u89c6\u9891\u8bb2\u89e3 \u5f88\u5c11\u8003 279 Perfect Squares \u89c6\u9891\u8bb2\u89e3 139 Word Break \u89c6\u9891\u8bb2\u89e3 375 Guess Number Higher or Lower II \u89c6\u9891\u8bb2\u89e3 312 Burst Balloons \u89c6\u9891\u8bb2\u89e3 322 Coin Change \u89c6\u9891\u8bb2\u89e3 \u4e8c\u7ef4 256 Paint House \u89c6\u9891\u8bb2\u89e3 265 Paint House II \u89c6\u9891\u8bb2\u89e3 64 Minimum Path Sum \u89c6\u9891\u8bb2\u89e3 72 Edit Distance \u89c6\u9891\u8bb2\u89e3 97 Interleaving String \u89c6\u9891\u8bb2\u89e3 174 Dungeon Game \u89c6\u9891\u8bb2\u89e3 221 Maximal Square \u89c6\u9891\u8bb2\u89e3 85 Maximal Rectangle \u89c6\u9891\u8bb2\u89e3 363 Max Sum of Rectangle No Larger Than K \u89c6\u9891\u8bb2\u89e3 TreeSet \u5316\u7b80 198 House Robber \u89c6\u9891\u8bb2\u89e3 213 House Robber II \u89c6\u9891\u8bb2\u89e3 276 Paint Fence \u89c6\u9891\u8bb2\u89e3 91 Decode Ways \u89c6\u9891\u8bb2\u89e3 10 Regular Expression Matching \u89c6\u9891\u8bb2\u89e3 44 Wildcard Matching \u89c6\u9891\u8bb2\u89e3 \u57fa\u7840\u77e5\u8bc6\uff1a\u8fd9\u91cc\u6307\u7684\u662f\u7528for\u5faa\u73af\u65b9\u5f0f\u7684\u52a8\u6001\u89c4\u5212\uff0c\u975eMemoization Search\u65b9\u5f0f\u3002DP\u53ef\u4ee5\u5728\u591a\u9879\u5f0f\u65f6\u95f4\u590d\u6742\u5ea6\u5185\u89e3\u51b3DFS\u9700\u8981\u6307\u6570\u7ea7\u522b\u7684\u95ee\u9898\u3002\u5e38\u89c1\u7684\u9898\u76ee\u5305\u62ec\u627e\u6700\u5927\u6700\u5c0f\uff0c\u627e\u53ef\u884c\u6027\uff0c\u627e\u603b\u65b9\u6848\u6570\u7b49\uff0c\u4e00\u822c\u7ed3\u679c\u662f\u4e00\u4e2aInteger\u6216\u8005Boolean\u3002 \u5e38\u89c1\u9898\u76ee\uff1a - LeetCode 674 Longest Continuous Increasing Subsequence - LeetCode 62 Unique Paths II - LeetCode 70 Climbing Stairs - LeetCode 64 Minimum Path Sum - LeetCode 368 Largest Divisible Subset - LeetCode 300 Longest Increasing Subsequence - LeetCode 354 Russian Doll Envelopes - LeetCode 256 Paint House - LeetCode 121 Best Time to Buy and Sell Stock - LeetCode 55 Jump Game - LeetCode 45 Jump Game II - LeetCode 403 Frog Jump - LeetCode 132 Palindrome Partitioning II - LeetCode 312 Burst Balloons - LeetCode 1143 Longest Common Subsequence - LeetCode 115 Distinct Subsequences - LeetCode 72 Edit Distance - LeetCode 91 Decode Ways - LeetCode 639 Decode Ways II - LeetCode 712 Minimum ASCII Delete Sum for Two Strings - LeetCode 221 Maximal Square - LeetCode 198 House Robber - LeetCode 213 House Robber II - LeetCode 87 Scramble String - LeetCode 1062 Longest Repeating Substring - LeetCode 1140 Stone Game II - LeetCode 322 Coin Change - LeetCode 518 Coin Change II - LeetCode 97 Interleaving String \u9898\u76ee\u5206\u7c7b \u9898\u76ee\u7f16\u53f7 \u6570\u7ec4\u4e2d\u7684\u52a8\u6001\u89c4\u5212 509\u300170\u3001338\u300145\u300155\u3001198\u3001213\u3001650\u300191\u3001639\u3001552\u3001123\u3001188\u3001309\u300132\u3001264\u3001313\u3001403 \u5b50\u6570\u7ec4\u3001\u5b50\u5e8f\u5217\u4e2d\u7684\u52a8\u6001\u89c4\u5212 689\u3001413\u3001446\u3001368\u3001416\u3001279 \u80cc\u5305\u95ee\u9898 322\u3001518\u3001474\u3001494\u3001377 \u77e9\u9635\u4e2d\u7684\u52a8\u6001\u89c4\u5212 62\u300163\u300164\u3001120\u3001576\u3001688\u3001221\u3001629\u3001174\u300196\u3001329 \u52a8\u6001\u89c4\u5212\u4e0e\u5b57\u7b26\u4e32\u5339\u914d 583\u300172\u300197\u3001115\u3001516\u3001132\u3001131\u3001139\u3001140\u3001514\u300110\u300144 \u72b6\u6001\u538b\u7f29\u52a8\u6001\u89c4\u5212 464\u3001691\u3001698\u3001638\u3001473 \u533a\u95f4\u4e2d\u7684\u52a8\u6001\u89c4\u5212 486\u3001664\u3001375\u3001312\u3001546 \u6811\u5f62dp 337\u3001124 \u6570\u4f4ddp 233\u3001600","title":"Dynamic Programming"},{"location":"A.%20LeetCode/2.%20Algorithms%20and%20Tricks/DP/Knapsack/","text":"Knapsack","title":"Knapsack"},{"location":"A.%20LeetCode/2.%20Algorithms%20and%20Tricks/DP/Knapsack/#knapsack","text":"","title":"Knapsack"},{"location":"A.%20LeetCode/2.%20Algorithms%20and%20Tricks/DP/Palindrome/","text":"","title":"Palindrome"},{"location":"A.%20LeetCode/2.%20Algorithms%20and%20Tricks/DP/State_Compression_DP/","text":"State Compression DP","title":"State Compression DP"},{"location":"A.%20LeetCode/2.%20Algorithms%20and%20Tricks/DP/State_Compression_DP/#state-compression-dp","text":"","title":"State Compression DP"},{"location":"A.%20LeetCode/2.%20Algorithms%20and%20Tricks/Searching/BFS/","text":"BFS (3) Introduction BFS searches a tree or graph by level or distance. The time complexity is \\(O(|V| + |E|)\\) , where \\(|V|\\) is the number of vertices and \\(|E|\\) the number of edges; and the space complexity is \\(O(|V|)\\) . The pseudocode can be written as follows: When Level does not Matter 1 2 3 4 5 6 7 # Pseudocode of BFS; level not matter while queue : cur = queue . pop () visited [ cur ] = True for node in neighbors ( cur ): if node is both valid and unvisited : queue . append ( node ) When Level Matters 1 2 3 4 5 6 7 8 9 10 11 # Pseudocode of BFS; level matters level = 0 while queue : size = len ( queue ) for i in range ( size ): cur = queue . pop () visited [ cur ] = True for node in neighbors ( cur ): if node is both valid and unvisited : queue . append ( node ) level += 1 Problems ID Title Difficulty 542 01 Matrix Medium 1162 As Far from Land as Possible Medium 994 Rotting Oranges Medium LC542. 01 Matrix (Medium) Info LC542. 01 Matrix (Medium) Algorithm: BFS Time Complexity: \\(O(n)\\) Space Complexity: \\(O(1)\\) Solution BFS. BFS \\(O(n)\\) Python 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 class Solution : def updateMatrix ( self , mat : List [ List [ int ]]) -> List [ List [ int ]]: row , col = len ( mat ), len ( mat [ 0 ]) dist = [[ 0 ] * col for _ in range ( row )] qq = [( i , j ) for i in range ( len ( mat )) for j in range ( len ( mat [ 0 ])) if mat [ i ][ j ] == 0 ] Q = collections . deque ( qq ) while Q : i , j = Q . popleft () for ii , jj in [[ i - 1 , j ], [ i + 1 , j ], [ i , j - 1 ], [ i , j + 1 ]]: if 0 <= ii < row and 0 <= jj < col and dist [ ii ][ jj ] == 0 and mat [ ii ][ jj ] == 1 : dist [ ii ][ jj ] = dist [ i ][ j ] + 1 # visited Q . append (( ii , jj )) return dist LC1162. As Far from Land as Possible (Medium) Info LC1162. As Far from Land as Possible (Medium) Algorithm: BFS Time Complexity: \\(O(n)\\) Space Complexity: \\(O(1)\\) Solution BFS. BFS \\(O(n)\\) Python 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 class Solution : def maxDistance ( self , grid : List [ List [ int ]]) -> int : r , c = len ( grid ), len ( grid [ 0 ]) dist = [[ 0 ] * c for _ in range ( r )] Q = collections . deque ([( i , j ) for i in range ( c ) for j in range ( r ) if grid [ i ][ j ] == 1 ]) ans = 0 while Q : i , j = Q . popleft () ans = dist [ i ][ j ] for ii , jj in [( i + 1 , j ), ( i - 1 , j ), ( i , j + 1 ), ( i , j - 1 )]: if 0 <= ii < r and 0 <= jj < c and dist [ ii ][ jj ] == 0 and grid [ ii ][ jj ] == 0 : dist [ ii ][ jj ] = dist [ i ][ j ] + 1 Q . append (( ii , jj )) return ans if ans > 0 else - 1 LC994. Rotting Oranges (Medium) Info LC994. Rotting Oranges (Medium) Algorithm: BFS Time Complexity: \\(O(n)\\) Space Complexity: \\(O(1)\\) Solution BFS. BFS \\(O(n)\\) Python 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 class Solution : def orangesRotting ( self , grid : List [ List [ int ]]) -> int : row , col = len ( grid ), len ( grid [ 0 ]) dist = [[ 0 ] * col for _ in range ( row )] Q = collections . deque ([( i , j ) for i in range ( row ) for j in range ( col ) if grid [ i ][ j ] == 2 ]) toVisit = set ([( i , j ) for i in range ( row ) for j in range ( col ) if grid [ i ][ j ] == 1 ]) ans = 0 while Q : i , j = Q . popleft () ans = dist [ i ][ j ] for ii , jj in [( i - 1 , j ), ( i + 1 , j ), ( i , j + 1 ), ( i , j - 1 )]: if 0 <= ii < row and 0 <= jj < col and dist [ ii ][ jj ] == 0 and grid [ ii ][ jj ] == 1 : dist [ ii ][ jj ] = dist [ i ][ j ] + 1 Q . append (( ii , jj )) toVisit . remove (( ii , jj )) return - 1 if toVisit else ans \u57fa\u7840\u77e5\u8bc6\uff1a \u5e38\u89c1\u7684BFS\u7528\u6765\u89e3\u51b3\u4ec0\u4e48\u95ee\u9898\uff1f(1) \u7b80\u5355\u56fe\uff08\u6709\u5411\u65e0\u5411\u7686\u53ef\uff09\u7684\u6700\u77ed\u8def\u5f84\u957f\u5ea6\uff082\uff09\u62d3\u6251\u6392\u5e8f \uff083\uff09 \u904d\u5386\u4e00\u4e2a\u56fe\uff08\u6216\u8005\u6811\uff09 BFS\u57fa\u672c\u6a21\u677f\uff08\u9700\u8981\u8bb0\u5f55\u5c42\u6570\u6216\u8005\u4e0d\u9700\u8981\u8bb0\u5f55\u5c42\u6570\uff09 \u591a\u6570\u60c5\u51b5\u4e0b\u65f6\u95f4\u590d\u6742\u5ea6\u7a7a\u95f4\u590d\u6742\u5ea6\u90fd\u662fO\uff08N+M\uff09\uff0cN\u4e3a\u8282\u70b9\u4e2a\u6570\uff0cM\u4e3a\u8fb9\u7684\u4e2a\u6570 \u57fa\u4e8e\u6811\u7684BFS\uff1a\u4e0d\u9700\u8981\u4e13\u95e8\u4e00\u4e2aset\u6765\u8bb0\u5f55\u8bbf\u95ee\u8fc7\u7684\u8282\u70b9 Leetcode 102 Binary Tree Level Order Traversal Leetcode 103 Binary Tree Zigzag Level Order Traversal Leetcode 297 Serialize and Deserialize Binary Tree \uff08\u5f88\u597d\u7684BFS\u548c\u53cc\u6307\u9488\u7ed3\u5408\u7684\u9898\uff09 Leetcode 374 Binary Tree Vertical Order Traversal \u57fa\u4e8e\u56fe\u7684BFS\uff1a\uff08\u4e00\u822c\u9700\u8981\u4e00\u4e2aset\u6765\u8bb0\u5f55\u8bbf\u95ee\u8fc7\u7684\u8282\u70b9\uff09 Leetcode 200. Number of Islands Leetcode 133. Clone Graph Leetcode 127. Word Ladder Leetcode 490. The Maze Leetcode 323. Connected Component in Undirected Graph Leetcode 130. Surrounded Regions Leetcode 752. Open the Lock Leetcode 815. Bus Routes Leetcode 1091. Shortest Path in Binary Matrix Leetcode 1293. Shortest Path in a Grid with Obstacles Elimination \u62d3\u6251\u6392\u5e8f: Leetcode 207 Course Schedule \uff08I, II\uff09 Leetcode 444 Sequence Reconstruction Leetcode 269 Alien Dictionary","title":"BFS (3)"},{"location":"A.%20LeetCode/2.%20Algorithms%20and%20Tricks/Searching/BFS/#bfs-3","text":"","title":"BFS (3)"},{"location":"A.%20LeetCode/2.%20Algorithms%20and%20Tricks/Searching/BFS/#introduction","text":"BFS searches a tree or graph by level or distance. The time complexity is \\(O(|V| + |E|)\\) , where \\(|V|\\) is the number of vertices and \\(|E|\\) the number of edges; and the space complexity is \\(O(|V|)\\) . The pseudocode can be written as follows: When Level does not Matter 1 2 3 4 5 6 7 # Pseudocode of BFS; level not matter while queue : cur = queue . pop () visited [ cur ] = True for node in neighbors ( cur ): if node is both valid and unvisited : queue . append ( node ) When Level Matters 1 2 3 4 5 6 7 8 9 10 11 # Pseudocode of BFS; level matters level = 0 while queue : size = len ( queue ) for i in range ( size ): cur = queue . pop () visited [ cur ] = True for node in neighbors ( cur ): if node is both valid and unvisited : queue . append ( node ) level += 1","title":"Introduction"},{"location":"A.%20LeetCode/2.%20Algorithms%20and%20Tricks/Searching/BFS/#problems","text":"ID Title Difficulty 542 01 Matrix Medium 1162 As Far from Land as Possible Medium 994 Rotting Oranges Medium LC542. 01 Matrix (Medium) Info LC542. 01 Matrix (Medium) Algorithm: BFS Time Complexity: \\(O(n)\\) Space Complexity: \\(O(1)\\) Solution BFS. BFS \\(O(n)\\) Python 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 class Solution : def updateMatrix ( self , mat : List [ List [ int ]]) -> List [ List [ int ]]: row , col = len ( mat ), len ( mat [ 0 ]) dist = [[ 0 ] * col for _ in range ( row )] qq = [( i , j ) for i in range ( len ( mat )) for j in range ( len ( mat [ 0 ])) if mat [ i ][ j ] == 0 ] Q = collections . deque ( qq ) while Q : i , j = Q . popleft () for ii , jj in [[ i - 1 , j ], [ i + 1 , j ], [ i , j - 1 ], [ i , j + 1 ]]: if 0 <= ii < row and 0 <= jj < col and dist [ ii ][ jj ] == 0 and mat [ ii ][ jj ] == 1 : dist [ ii ][ jj ] = dist [ i ][ j ] + 1 # visited Q . append (( ii , jj )) return dist LC1162. As Far from Land as Possible (Medium) Info LC1162. As Far from Land as Possible (Medium) Algorithm: BFS Time Complexity: \\(O(n)\\) Space Complexity: \\(O(1)\\) Solution BFS. BFS \\(O(n)\\) Python 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 class Solution : def maxDistance ( self , grid : List [ List [ int ]]) -> int : r , c = len ( grid ), len ( grid [ 0 ]) dist = [[ 0 ] * c for _ in range ( r )] Q = collections . deque ([( i , j ) for i in range ( c ) for j in range ( r ) if grid [ i ][ j ] == 1 ]) ans = 0 while Q : i , j = Q . popleft () ans = dist [ i ][ j ] for ii , jj in [( i + 1 , j ), ( i - 1 , j ), ( i , j + 1 ), ( i , j - 1 )]: if 0 <= ii < r and 0 <= jj < c and dist [ ii ][ jj ] == 0 and grid [ ii ][ jj ] == 0 : dist [ ii ][ jj ] = dist [ i ][ j ] + 1 Q . append (( ii , jj )) return ans if ans > 0 else - 1 LC994. Rotting Oranges (Medium) Info LC994. Rotting Oranges (Medium) Algorithm: BFS Time Complexity: \\(O(n)\\) Space Complexity: \\(O(1)\\) Solution BFS. BFS \\(O(n)\\) Python 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 class Solution : def orangesRotting ( self , grid : List [ List [ int ]]) -> int : row , col = len ( grid ), len ( grid [ 0 ]) dist = [[ 0 ] * col for _ in range ( row )] Q = collections . deque ([( i , j ) for i in range ( row ) for j in range ( col ) if grid [ i ][ j ] == 2 ]) toVisit = set ([( i , j ) for i in range ( row ) for j in range ( col ) if grid [ i ][ j ] == 1 ]) ans = 0 while Q : i , j = Q . popleft () ans = dist [ i ][ j ] for ii , jj in [( i - 1 , j ), ( i + 1 , j ), ( i , j + 1 ), ( i , j - 1 )]: if 0 <= ii < row and 0 <= jj < col and dist [ ii ][ jj ] == 0 and grid [ ii ][ jj ] == 1 : dist [ ii ][ jj ] = dist [ i ][ j ] + 1 Q . append (( ii , jj )) toVisit . remove (( ii , jj )) return - 1 if toVisit else ans","title":"Problems"},{"location":"A.%20LeetCode/2.%20Algorithms%20and%20Tricks/Searching/BFS/#_1","text":"\u5e38\u89c1\u7684BFS\u7528\u6765\u89e3\u51b3\u4ec0\u4e48\u95ee\u9898\uff1f(1) \u7b80\u5355\u56fe\uff08\u6709\u5411\u65e0\u5411\u7686\u53ef\uff09\u7684\u6700\u77ed\u8def\u5f84\u957f\u5ea6\uff082\uff09\u62d3\u6251\u6392\u5e8f \uff083\uff09 \u904d\u5386\u4e00\u4e2a\u56fe\uff08\u6216\u8005\u6811\uff09 BFS\u57fa\u672c\u6a21\u677f\uff08\u9700\u8981\u8bb0\u5f55\u5c42\u6570\u6216\u8005\u4e0d\u9700\u8981\u8bb0\u5f55\u5c42\u6570\uff09 \u591a\u6570\u60c5\u51b5\u4e0b\u65f6\u95f4\u590d\u6742\u5ea6\u7a7a\u95f4\u590d\u6742\u5ea6\u90fd\u662fO\uff08N+M\uff09\uff0cN\u4e3a\u8282\u70b9\u4e2a\u6570\uff0cM\u4e3a\u8fb9\u7684\u4e2a\u6570","title":"\u57fa\u7840\u77e5\u8bc6\uff1a"},{"location":"A.%20LeetCode/2.%20Algorithms%20and%20Tricks/Searching/BFS/#bfsset","text":"Leetcode 102 Binary Tree Level Order Traversal Leetcode 103 Binary Tree Zigzag Level Order Traversal Leetcode 297 Serialize and Deserialize Binary Tree \uff08\u5f88\u597d\u7684BFS\u548c\u53cc\u6307\u9488\u7ed3\u5408\u7684\u9898\uff09 Leetcode 374 Binary Tree Vertical Order Traversal","title":"\u57fa\u4e8e\u6811\u7684BFS\uff1a\u4e0d\u9700\u8981\u4e13\u95e8\u4e00\u4e2aset\u6765\u8bb0\u5f55\u8bbf\u95ee\u8fc7\u7684\u8282\u70b9"},{"location":"A.%20LeetCode/2.%20Algorithms%20and%20Tricks/Searching/BFS/#bfsset_1","text":"Leetcode 200. Number of Islands Leetcode 133. Clone Graph Leetcode 127. Word Ladder Leetcode 490. The Maze Leetcode 323. Connected Component in Undirected Graph Leetcode 130. Surrounded Regions Leetcode 752. Open the Lock Leetcode 815. Bus Routes Leetcode 1091. Shortest Path in Binary Matrix Leetcode 1293. Shortest Path in a Grid with Obstacles Elimination","title":"\u57fa\u4e8e\u56fe\u7684BFS\uff1a\uff08\u4e00\u822c\u9700\u8981\u4e00\u4e2aset\u6765\u8bb0\u5f55\u8bbf\u95ee\u8fc7\u7684\u8282\u70b9\uff09"},{"location":"A.%20LeetCode/2.%20Algorithms%20and%20Tricks/Searching/BFS/#_2","text":"Leetcode 207 Course Schedule \uff08I, II\uff09 Leetcode 444 Sequence Reconstruction Leetcode 269 Alien Dictionary","title":"\u62d3\u6251\u6392\u5e8f:"},{"location":"A.%20LeetCode/2.%20Algorithms%20and%20Tricks/Searching/DFS/","text":"DFS (9) Introduction DFS searches a tree or graph as far as possible along each branch before backtracking. The time complexity is \\(O(|V| + |E|)\\) , where \\(|V|\\) is the number of vertices and \\(|E|\\) the number of edges; and the space complexity is \\(O(|V|)\\) . The pseudocode can be written as follows: Recursive Version 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 # Pseudocode of DFS; recursive version def DFS ( G , v ): # 1. LABEL label v as VISITED # 2. SETUP and INITIALIZE setup and initialize # 3. DFS and UPDATE for w in G . adjacentEdges ( v ) do : if w is not VISITED : DFS ( G , w ) # 4. SUMMARIZE and RETURN return Non-recursive Version 1 2 3 4 5 6 7 8 9 10 # Pseudocode of DFS; non-recursive version def DFS ( G ): Stack . append ( root ) // root is the starting point while Stack : v = Stack . pop () if v is not VISITED : label v as VISITED // do some work here for w in G . adjacentEdge ( v ) do : Stack . append ( w ) Problems ID Title Difficulty 46 Permutations Medium 695 Max Area of Island Medium 200 Number of Islands Medium 1254 Number of Closed Islands Medium 1034 Coloring A Border Medium 865 Smallest Subtree with all the Deepest Nodes Medium 1123 Lowest Common Ancestor of Deepest Leaves Medium 1325 Delete Leaves With a Given Value Medium 814 Binary Tree Pruning Medium LC46. Permutations (Medium) Info LC46. Permutations (Medium) Algorithm: DFS Time Complexity: \\(O(n!)\\) Space Complexity: \\(O(1)\\) Solution DFS. Main Method \\(O(n!)\\) Python 1 2 3 4 5 6 7 8 9 10 11 12 class Solution : def permute ( self , nums : List [ int ]) -> List [ List [ int ]]: if len ( nums ) == 1 : return [ nums ] ans = [] prev = self . permute ( nums [: - 1 ]) for p in prev : for i in range ( len ( p ) + 1 ): ans . append ( p [: i ] + [ nums [ - 1 ]] + p [ i :]) return ans LC695. Max Area of Island (Medium) Info LC695. Max Area of Island (Medium) Algorithm: DFS Time Complexity: \\(O(|V| + |E|)\\) Space Complexity: \\(O(|E|)\\) Solution This is a DFS problem. DFS \\(O(|V|+|E|)\\) Python 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 class Solution : def __init__ ( self ): self . VISITED = dict () def DFS ( self , grid , v ) -> int : if not ( 0 <= v [ 0 ] < len ( grid ) and 0 <= v [ 1 ] < len ( grid [ 0 ]) and grid [ v [ 0 ]][ v [ 1 ]]): self . VISITED [ v ] = 0 return 0 # 1. LABEL self . VISITED [ v ] = 1 # 2. SETUP and INITIALIZE adjacentNodes = [] adjacentNodes += [( v [ 0 ] - 1 , v [ 1 ])] # up adjacentNodes += [( v [ 0 ] + 1 , v [ 1 ])] # down adjacentNodes += [( v [ 0 ], v [ 1 ] - 1 )] # left adjacentNodes += [( v [ 0 ], v [ 1 ] + 1 )] # right # 3. DFS and UPDATE for w in adjacentNodes : if w not in self . VISITED : self . VISITED [ w ] = self . DFS ( grid , w ) self . VISITED [ v ] += self . VISITED [ w ] # 4. SUMMARIZE and RETURN return self . VISITED [ v ] def maxAreaOfIsland ( self , grid : List [ List [ int ]]) -> int : maxArea = 0 for i in range ( len ( grid )): for j in range ( len ( grid [ 0 ])): if grid [ i ][ j ] and ( i , j ) not in self . VISITED : maxArea = max ( maxArea , self . DFS ( grid , ( i , j ))) return maxArea LC200. Number of Islands (Medium) Info LC200. Number of Islands (Medium) Algorithm: DFS Time Complexity: \\(O(|V| + |E|)\\) Space Complexity: \\(O(|E|)\\) Solution This is a DFS problem. DFS \\(O(|V|+|E|)\\) Python 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 class Solution : def __init__ ( self ): self . VISITED = set () def DFS ( self , grid , v ): if not ( 0 <= v [ 0 ] < len ( grid ) and 0 <= v [ 1 ] < len ( grid [ 0 ]) and grid [ v [ 0 ]][ v [ 1 ]] == \"1\" ): return # 1. label self . VISITED . add ( v ) # 2. setup adjacent = [] adjacent += [( v [ 0 ] - 1 , v [ 1 ])] # up adjacent += [( v [ 0 ] + 1 , v [ 1 ])] # down adjacent += [( v [ 0 ], v [ 1 ] - 1 )] # left adjacent += [( v [ 0 ], v [ 1 ] + 1 )] # right # 3. DFS for w in adjacent : if w not in self . VISITED : self . DFS ( grid , w ) def numIslands ( self , grid : List [ List [ str ]]) -> int : islands = 0 for i in range ( len ( grid )): for j in range ( len ( grid [ 0 ])): if grid [ i ][ j ] == \"1\" and ( i , j ) not in self . VISITED : self . DFS ( grid , ( i , j )) islands += 1 return islands LC1254. Number of Closed Islands (Medium) Info LC1254. Number of Closed Islands (Medium) Algorithm: DFS Time Complexity: \\(O(|V| + |E|)\\) Space Complexity: \\(O(|E|)\\) Solution DFS. DFS \\(O(|V|+|E|)\\) Python 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 class Solution : def __init__ ( self ): self . VISITED = {} def findWayOut ( self , grid , v ) -> bool : # mark as visited self . VISITED [ v ] = False # base case if not ( 0 <= v [ 0 ] < len ( grid ) and 0 <= v [ 1 ] < len ( grid [ 0 ])): self . VISITED [ v ] = True return True if grid [ v [ 0 ]][ v [ 1 ]] == 1 : return False # DFS up = ( v [ 0 ] - 1 , v [ 1 ]) down = ( v [ 0 ] + 1 , v [ 1 ]) left = ( v [ 0 ], v [ 1 ] - 1 ) right = ( v [ 0 ], v [ 1 ] + 1 ) for w in { up , down , left , right }: if not self . VISITED [ v ]: # don't have to continue if found way out already if w not in self . VISITED : self . VISITED [ w ] = self . findWayOut ( grid , w ) self . VISITED [ v ] = self . VISITED [ v ] or self . VISITED [ w ] return self . VISITED [ v ] def closedIsland ( self , grid : List [ List [ int ]]) -> int : numClosedIslands = 0 for i in range ( len ( grid )): for j in range ( len ( grid [ 0 ])): if grid [ i ][ j ] == 0 and ( i , j ) not in self . VISITED : numClosedIslands += 1 if not self . findWayOut ( grid , ( i , j )) else 0 return numClosedIslands LC1034. Coloring A Border (Medium) Info LC1034. Coloring A Border (Medium) Algorithm: DFS Time Complexity: \\(O(|V| + |E|)\\) Space Complexity: \\(O(|E|)\\) Solution DFS. DFS \\(O(|V|+|E|)\\) Python 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 class Solution : def __init__ ( self ): self . VISITED = dict () def withinBoundary ( self , grid , x , y ) -> bool : if 0 <= x < len ( grid ) and 0 <= y < len ( grid [ 0 ]): return True else : return False def colorBorder ( self , grid : List [ List [ int ]], r0 : int , c0 : int , color : int ) -> List [ List [ int ]]: self . VISITED [( r0 , c0 )] = 1 toColor = False for r1 , c1 in {( r0 - 1 , c0 ), ( r0 + 1 , c0 ), ( r0 , c0 - 1 ), ( r0 , c0 + 1 )}: if ( r1 , c1 ) not in self . VISITED : if self . withinBoundary ( grid , r1 , c1 ): if grid [ r1 ][ c1 ] != grid [ r0 ][ c0 ]: toColor = True else : self . colorBorder ( grid , r1 , c1 , color ) else : toColor = True if toColor : grid [ r0 ][ c0 ] = color return grid LC865. Smallest Subtree with all the Deepest Nodes (Medium) Info LC865. Smallest Subtree with all the Deepest Nodes (Medium) Algorithm: DFS Time Complexity: \\(O(n)\\) Space Complexity: \\(O(1)\\) Solution DFS. DFS \\(O(n)\\) Python 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 class Solution : def allPaths ( self , root ) -> List [ List [ int ]]: if not root : return [] if not root . left and not root . right : return [[ root ]] return [[ root ] + x for x in self . allPaths ( root . left )] + [[ root ] + x for x in self . allPaths ( root . right )] def subtreeWithAllDeepest ( self , root : TreeNode ) -> TreeNode : paths = sorted ( self . allPaths ( root ), key = lambda x : len ( x ), reverse = True ) maxLen = len ( paths [ 0 ]) deepestPaths = [ x for x in paths if len ( x ) == maxLen ] for i in range ( maxLen ): if len ( set ( x [ i ] . val for x in deepestPaths )) != 1 : return deepestPaths [ 0 ][ i - 1 ] return deepestPaths [ 0 ][ - 1 ] LC1123. Lowest Common Ancestor of Deepest Leaves (Medium) Info LC1123. Lowest Common Ancestor of Deepest Leaves (Medium) Algorithm: DFS Time Complexity: \\(O(n)\\) Space Complexity: \\(O(1)\\) Solution DFS. Same as LC865. DFS \\(O(n)\\) Python 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 class Solution : def allPaths ( self , root ) -> List [ List [ int ]]: if not root : return [] if not root . left and not root . right : return [[ root ]] return [[ root ] + x for x in self . allPaths ( root . left )] + [[ root ] + x for x in self . allPaths ( root . right )] def lcaDeepestLeaves ( self , root : TreeNode ) -> TreeNode : paths = sorted ( self . allPaths ( root ), key = lambda x : len ( x ), reverse = True ) maxLen = len ( paths [ 0 ]) deepestPaths = [ x for x in paths if len ( x ) == maxLen ] for i in range ( maxLen ): if len ( set ( x [ i ] . val for x in deepestPaths )) != 1 : return deepestPaths [ 0 ][ i - 1 ] return deepestPaths [ 0 ][ - 1 ] LC1325. Delete Leaves With a Given Value (Medium) Info LC1325. Delete Leaves With a Given Value (Medium) Algorithm: DFS Time Complexity: \\(O(n)\\) Space Complexity: \\(O(1)\\) Solution DFS. DFS \\(O(n)\\) Python 1 2 3 4 5 6 7 8 9 10 11 12 class Solution : def removeLeafNodes ( self , root : TreeNode , target : int ) -> TreeNode : if not root : return None root . left = self . removeLeafNodes ( root . left , target ) root . right = self . removeLeafNodes ( root . right , target ) if not root . left and not root . right and root . val == target : return None else : return root LC814. Binary Tree Pruning (Medium) Info LC814. Binary Tree Pruning (Medium) Algorithm: DFS Time Complexity: \\(O(n)\\) Space Complexity: \\(O(1)\\) Solution DFS. DFS \\(O(n)\\) Python 1 2 3 4 5 6 7 8 9 10 11 12 class Solution : def pruneTree ( self , root : TreeNode ) -> TreeNode : if not root : return None root . left = self . pruneTree ( root . left ) root . right = self . pruneTree ( root . right ) if not root . left and not root . right and root . val == 0 : root = None return root \u57fa\u4e8e\u6811\u7684DFS\uff1a\u9700\u8981\u8bb0\u4f4f\u9012\u5f52\u5199\u524d\u5e8f\u4e2d\u5e8f\u540e\u5e8f\u904d\u5386\u4e8c\u53c9\u6811\u7684\u6a21\u677f LeetCode 543 Diameter of Binary Tree LeetCode 226 Invert Binary Tree LeetCode 124 Binary Tree Maximum Path Sum LeetCode 236 Lowest Common Ancestor of a Binary Tree LeetCode 101 Symmetric Tree LeetCode 105 Construct Binary Tree from Preorder and Inorder Traversal LeetCode 104 Maximum Depth of Binary Tree LeetCode 951 Flip Equivalent Binary Trees LeetCode 987 Vertical Order Traversal of a Binary Tree LeetCode 1485 Clone Binary Tree With Random Pointer LeetCode 572 Subtree of Another Tree LeetCode 863 All Nodes Distance K in Binary Tree \u4e8c\u53c9\u641c\u7d22\u6811\uff08BST\uff09\uff1aBST\u7279\u5f81\uff1a\u4e2d\u5e8f\u904d\u5386\u4e3a\u5355\u8c03\u9012\u589e\u7684\u4e8c\u53c9\u6811\uff0c\u6362\u53e5\u8bdd\u8bf4\uff0c\u6839\u8282\u70b9\u7684\u503c\u6bd4\u5de6\u5b50\u6811\u4efb\u610f\u8282\u70b9\u503c\u90fd\u5927\uff0c\u6bd4\u53f3\u5b50\u6811\u4efb\u610f\u8282\u70b9\u503c\u90fd\u5c0f\uff0c\u589e\u5220\u67e5\u6539\u5747\u4e3aO\uff08h\uff09\u590d\u6742\u5ea6\uff0ch\u4e3a\u6570\u7684\u9ad8\u5ea6\uff1b\u6ce8\u610f\u4e0d\u662f\u6240\u6709\u7684BST\u9898\u76ee\u90fd\u9700\u8981\u9012\u5f52\uff0c\u6709\u7684\u9898\u76ee\u53ea\u9700\u8981while\u5faa\u73af\u5373\u53ef LeetCode 230 Kth Smallest element in a BST LeetCode 98 Validate Binary Search Tree LeetCode 270 Cloest Binary Search Tree Value LeetCode 235 Lowest Common Ancestor of a Binary Search Tree LeetCode 669 Trim a Binary Search Tree LeetCode 700 Search Range in Binary Search Tree LeetCode 108 Convert Sorted Array to Binary Search Tree LeetCode 333 Largest BST Subtree LeetCode 510 Inorder Successor in BST II \u57fa\u4e8e\u56fe\u7684DFS: \u548cBFS\u4e00\u6837\u4e00\u822c\u9700\u8981\u4e00\u4e2aset\u6765\u8bb0\u5f55\u8bbf\u95ee\u8fc7\u7684\u8282\u70b9\uff0c\u907f\u514d\u91cd\u590d\u8bbf\u95ee\u9020\u6210\u6b7b\u5faa\u73af LeetCode 341 Flatten Nested List Iterator LeetCode 394 Decode String LeetCode 51 N-Queens LeetCode 291 Word Pattern II (I\u4e3a\u7b80\u5355\u7684Hashmap\u9898) LeetCode 126 Word Ladder II \uff08I\u4e3aBFS\u9898\u76ee\uff09 LeetCode 1110 Delete Nodes And Return Forest LeetCode 93 Restore IP Addresses LeetCode 22 Generate Parentheses LeetCode 37 Sodoku Solver LeetCode 301 Remove Invalid Parentheses LeetCode 212 Word Search II \uff08I, II\uff09 LeetCode 1087 Brace Expansion LeetCode 399 Evaluate Division LeetCode 1274 Number of Ships in a Rectangle LeetCode 1376 Time Needed to Inform All Employees LeetCode 694 Number of Distinct Islands LeetCode 586 Score of Parentheses \u57fa\u4e8e\u6392\u5217\u7ec4\u5408\u7684DFS: \u5176\u5b9e\u4e0e\u56fe\u7c7bDFS\u65b9\u6cd5\u4e00\u81f4\uff0c\u4f46\u662f\u6392\u5217\u7ec4\u5408\u7684\u7279\u5f81\u66f4\u660e\u663e LeetCode 17 Letter Combinations of a Phone Number LeetCode 39 Combination Sum \uff08I, II, III, IV\uff09 LeetCode 90 Subsets II \uff08\u91cd\u70b9\u5728\u4e8e\u5982\u4f55\u53bb\u91cd\uff09 LeetCode 47 Permutation II LeetCode 77 Combinations LeetCode 526 Beautiful Arrangement \u8bb0\u5fc6\u5316\u641c\u7d22\uff08DFS + Memoization Search\uff09\uff1a\u7b97\u662f\u52a8\u6001\u89c4\u5212\u7684\u4e00\u79cd\uff0c\u9012\u5f52\u6bcf\u6b21\u8fd4\u56de\u65f6\u540c\u65f6\u8bb0\u5f55\u4e0b\u5df2\u8bbf\u95ee\u8fc7\u7684\u8282\u70b9\u7279\u5f81\uff0c\u907f\u514d\u91cd\u590d\u8bbf\u95ee\u540c\u4e00\u4e2a\u8282\u70b9\uff0c\u53ef\u4ee5\u6709\u6548\u7684\u628a\u6307\u6570\u7ea7\u522b\u7684DFS\u65f6\u95f4\u590d\u6742\u5ea6\u964d\u4e3a\u591a\u9879\u5f0f\u7ea7\u522b LeetCode 139 Word Break II LeetCode 131 Palindrome Partitioning LeetCode 72 Edit Distance LeetCode 377 Combination Sum IV LeetCode 1335 Minimum Difficulty of a Job Schedule","title":"DFS (9)"},{"location":"A.%20LeetCode/2.%20Algorithms%20and%20Tricks/Searching/DFS/#dfs-9","text":"","title":"DFS (9)"},{"location":"A.%20LeetCode/2.%20Algorithms%20and%20Tricks/Searching/DFS/#introduction","text":"DFS searches a tree or graph as far as possible along each branch before backtracking. The time complexity is \\(O(|V| + |E|)\\) , where \\(|V|\\) is the number of vertices and \\(|E|\\) the number of edges; and the space complexity is \\(O(|V|)\\) . The pseudocode can be written as follows: Recursive Version 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 # Pseudocode of DFS; recursive version def DFS ( G , v ): # 1. LABEL label v as VISITED # 2. SETUP and INITIALIZE setup and initialize # 3. DFS and UPDATE for w in G . adjacentEdges ( v ) do : if w is not VISITED : DFS ( G , w ) # 4. SUMMARIZE and RETURN return Non-recursive Version 1 2 3 4 5 6 7 8 9 10 # Pseudocode of DFS; non-recursive version def DFS ( G ): Stack . append ( root ) // root is the starting point while Stack : v = Stack . pop () if v is not VISITED : label v as VISITED // do some work here for w in G . adjacentEdge ( v ) do : Stack . append ( w )","title":"Introduction"},{"location":"A.%20LeetCode/2.%20Algorithms%20and%20Tricks/Searching/DFS/#problems","text":"ID Title Difficulty 46 Permutations Medium 695 Max Area of Island Medium 200 Number of Islands Medium 1254 Number of Closed Islands Medium 1034 Coloring A Border Medium 865 Smallest Subtree with all the Deepest Nodes Medium 1123 Lowest Common Ancestor of Deepest Leaves Medium 1325 Delete Leaves With a Given Value Medium 814 Binary Tree Pruning Medium LC46. Permutations (Medium) Info LC46. Permutations (Medium) Algorithm: DFS Time Complexity: \\(O(n!)\\) Space Complexity: \\(O(1)\\) Solution DFS. Main Method \\(O(n!)\\) Python 1 2 3 4 5 6 7 8 9 10 11 12 class Solution : def permute ( self , nums : List [ int ]) -> List [ List [ int ]]: if len ( nums ) == 1 : return [ nums ] ans = [] prev = self . permute ( nums [: - 1 ]) for p in prev : for i in range ( len ( p ) + 1 ): ans . append ( p [: i ] + [ nums [ - 1 ]] + p [ i :]) return ans LC695. Max Area of Island (Medium) Info LC695. Max Area of Island (Medium) Algorithm: DFS Time Complexity: \\(O(|V| + |E|)\\) Space Complexity: \\(O(|E|)\\) Solution This is a DFS problem. DFS \\(O(|V|+|E|)\\) Python 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 class Solution : def __init__ ( self ): self . VISITED = dict () def DFS ( self , grid , v ) -> int : if not ( 0 <= v [ 0 ] < len ( grid ) and 0 <= v [ 1 ] < len ( grid [ 0 ]) and grid [ v [ 0 ]][ v [ 1 ]]): self . VISITED [ v ] = 0 return 0 # 1. LABEL self . VISITED [ v ] = 1 # 2. SETUP and INITIALIZE adjacentNodes = [] adjacentNodes += [( v [ 0 ] - 1 , v [ 1 ])] # up adjacentNodes += [( v [ 0 ] + 1 , v [ 1 ])] # down adjacentNodes += [( v [ 0 ], v [ 1 ] - 1 )] # left adjacentNodes += [( v [ 0 ], v [ 1 ] + 1 )] # right # 3. DFS and UPDATE for w in adjacentNodes : if w not in self . VISITED : self . VISITED [ w ] = self . DFS ( grid , w ) self . VISITED [ v ] += self . VISITED [ w ] # 4. SUMMARIZE and RETURN return self . VISITED [ v ] def maxAreaOfIsland ( self , grid : List [ List [ int ]]) -> int : maxArea = 0 for i in range ( len ( grid )): for j in range ( len ( grid [ 0 ])): if grid [ i ][ j ] and ( i , j ) not in self . VISITED : maxArea = max ( maxArea , self . DFS ( grid , ( i , j ))) return maxArea LC200. Number of Islands (Medium) Info LC200. Number of Islands (Medium) Algorithm: DFS Time Complexity: \\(O(|V| + |E|)\\) Space Complexity: \\(O(|E|)\\) Solution This is a DFS problem. DFS \\(O(|V|+|E|)\\) Python 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 class Solution : def __init__ ( self ): self . VISITED = set () def DFS ( self , grid , v ): if not ( 0 <= v [ 0 ] < len ( grid ) and 0 <= v [ 1 ] < len ( grid [ 0 ]) and grid [ v [ 0 ]][ v [ 1 ]] == \"1\" ): return # 1. label self . VISITED . add ( v ) # 2. setup adjacent = [] adjacent += [( v [ 0 ] - 1 , v [ 1 ])] # up adjacent += [( v [ 0 ] + 1 , v [ 1 ])] # down adjacent += [( v [ 0 ], v [ 1 ] - 1 )] # left adjacent += [( v [ 0 ], v [ 1 ] + 1 )] # right # 3. DFS for w in adjacent : if w not in self . VISITED : self . DFS ( grid , w ) def numIslands ( self , grid : List [ List [ str ]]) -> int : islands = 0 for i in range ( len ( grid )): for j in range ( len ( grid [ 0 ])): if grid [ i ][ j ] == \"1\" and ( i , j ) not in self . VISITED : self . DFS ( grid , ( i , j )) islands += 1 return islands LC1254. Number of Closed Islands (Medium) Info LC1254. Number of Closed Islands (Medium) Algorithm: DFS Time Complexity: \\(O(|V| + |E|)\\) Space Complexity: \\(O(|E|)\\) Solution DFS. DFS \\(O(|V|+|E|)\\) Python 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 class Solution : def __init__ ( self ): self . VISITED = {} def findWayOut ( self , grid , v ) -> bool : # mark as visited self . VISITED [ v ] = False # base case if not ( 0 <= v [ 0 ] < len ( grid ) and 0 <= v [ 1 ] < len ( grid [ 0 ])): self . VISITED [ v ] = True return True if grid [ v [ 0 ]][ v [ 1 ]] == 1 : return False # DFS up = ( v [ 0 ] - 1 , v [ 1 ]) down = ( v [ 0 ] + 1 , v [ 1 ]) left = ( v [ 0 ], v [ 1 ] - 1 ) right = ( v [ 0 ], v [ 1 ] + 1 ) for w in { up , down , left , right }: if not self . VISITED [ v ]: # don't have to continue if found way out already if w not in self . VISITED : self . VISITED [ w ] = self . findWayOut ( grid , w ) self . VISITED [ v ] = self . VISITED [ v ] or self . VISITED [ w ] return self . VISITED [ v ] def closedIsland ( self , grid : List [ List [ int ]]) -> int : numClosedIslands = 0 for i in range ( len ( grid )): for j in range ( len ( grid [ 0 ])): if grid [ i ][ j ] == 0 and ( i , j ) not in self . VISITED : numClosedIslands += 1 if not self . findWayOut ( grid , ( i , j )) else 0 return numClosedIslands LC1034. Coloring A Border (Medium) Info LC1034. Coloring A Border (Medium) Algorithm: DFS Time Complexity: \\(O(|V| + |E|)\\) Space Complexity: \\(O(|E|)\\) Solution DFS. DFS \\(O(|V|+|E|)\\) Python 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 class Solution : def __init__ ( self ): self . VISITED = dict () def withinBoundary ( self , grid , x , y ) -> bool : if 0 <= x < len ( grid ) and 0 <= y < len ( grid [ 0 ]): return True else : return False def colorBorder ( self , grid : List [ List [ int ]], r0 : int , c0 : int , color : int ) -> List [ List [ int ]]: self . VISITED [( r0 , c0 )] = 1 toColor = False for r1 , c1 in {( r0 - 1 , c0 ), ( r0 + 1 , c0 ), ( r0 , c0 - 1 ), ( r0 , c0 + 1 )}: if ( r1 , c1 ) not in self . VISITED : if self . withinBoundary ( grid , r1 , c1 ): if grid [ r1 ][ c1 ] != grid [ r0 ][ c0 ]: toColor = True else : self . colorBorder ( grid , r1 , c1 , color ) else : toColor = True if toColor : grid [ r0 ][ c0 ] = color return grid LC865. Smallest Subtree with all the Deepest Nodes (Medium) Info LC865. Smallest Subtree with all the Deepest Nodes (Medium) Algorithm: DFS Time Complexity: \\(O(n)\\) Space Complexity: \\(O(1)\\) Solution DFS. DFS \\(O(n)\\) Python 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 class Solution : def allPaths ( self , root ) -> List [ List [ int ]]: if not root : return [] if not root . left and not root . right : return [[ root ]] return [[ root ] + x for x in self . allPaths ( root . left )] + [[ root ] + x for x in self . allPaths ( root . right )] def subtreeWithAllDeepest ( self , root : TreeNode ) -> TreeNode : paths = sorted ( self . allPaths ( root ), key = lambda x : len ( x ), reverse = True ) maxLen = len ( paths [ 0 ]) deepestPaths = [ x for x in paths if len ( x ) == maxLen ] for i in range ( maxLen ): if len ( set ( x [ i ] . val for x in deepestPaths )) != 1 : return deepestPaths [ 0 ][ i - 1 ] return deepestPaths [ 0 ][ - 1 ] LC1123. Lowest Common Ancestor of Deepest Leaves (Medium) Info LC1123. Lowest Common Ancestor of Deepest Leaves (Medium) Algorithm: DFS Time Complexity: \\(O(n)\\) Space Complexity: \\(O(1)\\) Solution DFS. Same as LC865. DFS \\(O(n)\\) Python 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 class Solution : def allPaths ( self , root ) -> List [ List [ int ]]: if not root : return [] if not root . left and not root . right : return [[ root ]] return [[ root ] + x for x in self . allPaths ( root . left )] + [[ root ] + x for x in self . allPaths ( root . right )] def lcaDeepestLeaves ( self , root : TreeNode ) -> TreeNode : paths = sorted ( self . allPaths ( root ), key = lambda x : len ( x ), reverse = True ) maxLen = len ( paths [ 0 ]) deepestPaths = [ x for x in paths if len ( x ) == maxLen ] for i in range ( maxLen ): if len ( set ( x [ i ] . val for x in deepestPaths )) != 1 : return deepestPaths [ 0 ][ i - 1 ] return deepestPaths [ 0 ][ - 1 ] LC1325. Delete Leaves With a Given Value (Medium) Info LC1325. Delete Leaves With a Given Value (Medium) Algorithm: DFS Time Complexity: \\(O(n)\\) Space Complexity: \\(O(1)\\) Solution DFS. DFS \\(O(n)\\) Python 1 2 3 4 5 6 7 8 9 10 11 12 class Solution : def removeLeafNodes ( self , root : TreeNode , target : int ) -> TreeNode : if not root : return None root . left = self . removeLeafNodes ( root . left , target ) root . right = self . removeLeafNodes ( root . right , target ) if not root . left and not root . right and root . val == target : return None else : return root LC814. Binary Tree Pruning (Medium) Info LC814. Binary Tree Pruning (Medium) Algorithm: DFS Time Complexity: \\(O(n)\\) Space Complexity: \\(O(1)\\) Solution DFS. DFS \\(O(n)\\) Python 1 2 3 4 5 6 7 8 9 10 11 12 class Solution : def pruneTree ( self , root : TreeNode ) -> TreeNode : if not root : return None root . left = self . pruneTree ( root . left ) root . right = self . pruneTree ( root . right ) if not root . left and not root . right and root . val == 0 : root = None return root","title":"Problems"},{"location":"A.%20LeetCode/2.%20Algorithms%20and%20Tricks/Searching/DFS/#dfs","text":"LeetCode 543 Diameter of Binary Tree LeetCode 226 Invert Binary Tree LeetCode 124 Binary Tree Maximum Path Sum LeetCode 236 Lowest Common Ancestor of a Binary Tree LeetCode 101 Symmetric Tree LeetCode 105 Construct Binary Tree from Preorder and Inorder Traversal LeetCode 104 Maximum Depth of Binary Tree LeetCode 951 Flip Equivalent Binary Trees LeetCode 987 Vertical Order Traversal of a Binary Tree LeetCode 1485 Clone Binary Tree With Random Pointer LeetCode 572 Subtree of Another Tree LeetCode 863 All Nodes Distance K in Binary Tree","title":"\u57fa\u4e8e\u6811\u7684DFS\uff1a\u9700\u8981\u8bb0\u4f4f\u9012\u5f52\u5199\u524d\u5e8f\u4e2d\u5e8f\u540e\u5e8f\u904d\u5386\u4e8c\u53c9\u6811\u7684\u6a21\u677f"},{"location":"A.%20LeetCode/2.%20Algorithms%20and%20Tricks/Searching/DFS/#bstbstohhbstwhile","text":"LeetCode 230 Kth Smallest element in a BST LeetCode 98 Validate Binary Search Tree LeetCode 270 Cloest Binary Search Tree Value LeetCode 235 Lowest Common Ancestor of a Binary Search Tree LeetCode 669 Trim a Binary Search Tree LeetCode 700 Search Range in Binary Search Tree LeetCode 108 Convert Sorted Array to Binary Search Tree LeetCode 333 Largest BST Subtree LeetCode 510 Inorder Successor in BST II","title":"\u4e8c\u53c9\u641c\u7d22\u6811\uff08BST\uff09\uff1aBST\u7279\u5f81\uff1a\u4e2d\u5e8f\u904d\u5386\u4e3a\u5355\u8c03\u9012\u589e\u7684\u4e8c\u53c9\u6811\uff0c\u6362\u53e5\u8bdd\u8bf4\uff0c\u6839\u8282\u70b9\u7684\u503c\u6bd4\u5de6\u5b50\u6811\u4efb\u610f\u8282\u70b9\u503c\u90fd\u5927\uff0c\u6bd4\u53f3\u5b50\u6811\u4efb\u610f\u8282\u70b9\u503c\u90fd\u5c0f\uff0c\u589e\u5220\u67e5\u6539\u5747\u4e3aO\uff08h\uff09\u590d\u6742\u5ea6\uff0ch\u4e3a\u6570\u7684\u9ad8\u5ea6\uff1b\u6ce8\u610f\u4e0d\u662f\u6240\u6709\u7684BST\u9898\u76ee\u90fd\u9700\u8981\u9012\u5f52\uff0c\u6709\u7684\u9898\u76ee\u53ea\u9700\u8981while\u5faa\u73af\u5373\u53ef"},{"location":"A.%20LeetCode/2.%20Algorithms%20and%20Tricks/Searching/DFS/#dfs-bfsset","text":"LeetCode 341 Flatten Nested List Iterator LeetCode 394 Decode String LeetCode 51 N-Queens LeetCode 291 Word Pattern II (I\u4e3a\u7b80\u5355\u7684Hashmap\u9898) LeetCode 126 Word Ladder II \uff08I\u4e3aBFS\u9898\u76ee\uff09 LeetCode 1110 Delete Nodes And Return Forest LeetCode 93 Restore IP Addresses LeetCode 22 Generate Parentheses LeetCode 37 Sodoku Solver LeetCode 301 Remove Invalid Parentheses LeetCode 212 Word Search II \uff08I, II\uff09 LeetCode 1087 Brace Expansion LeetCode 399 Evaluate Division LeetCode 1274 Number of Ships in a Rectangle LeetCode 1376 Time Needed to Inform All Employees LeetCode 694 Number of Distinct Islands LeetCode 586 Score of Parentheses","title":"\u57fa\u4e8e\u56fe\u7684DFS: \u548cBFS\u4e00\u6837\u4e00\u822c\u9700\u8981\u4e00\u4e2aset\u6765\u8bb0\u5f55\u8bbf\u95ee\u8fc7\u7684\u8282\u70b9\uff0c\u907f\u514d\u91cd\u590d\u8bbf\u95ee\u9020\u6210\u6b7b\u5faa\u73af"},{"location":"A.%20LeetCode/2.%20Algorithms%20and%20Tricks/Searching/DFS/#dfs-dfs","text":"LeetCode 17 Letter Combinations of a Phone Number LeetCode 39 Combination Sum \uff08I, II, III, IV\uff09 LeetCode 90 Subsets II \uff08\u91cd\u70b9\u5728\u4e8e\u5982\u4f55\u53bb\u91cd\uff09 LeetCode 47 Permutation II LeetCode 77 Combinations LeetCode 526 Beautiful Arrangement","title":"\u57fa\u4e8e\u6392\u5217\u7ec4\u5408\u7684DFS: \u5176\u5b9e\u4e0e\u56fe\u7c7bDFS\u65b9\u6cd5\u4e00\u81f4\uff0c\u4f46\u662f\u6392\u5217\u7ec4\u5408\u7684\u7279\u5f81\u66f4\u660e\u663e"},{"location":"A.%20LeetCode/2.%20Algorithms%20and%20Tricks/Searching/DFS/#dfs-memoization-searchdfs","text":"LeetCode 139 Word Break II LeetCode 131 Palindrome Partitioning LeetCode 72 Edit Distance LeetCode 377 Combination Sum IV LeetCode 1335 Minimum Difficulty of a Job Schedule","title":"\u8bb0\u5fc6\u5316\u641c\u7d22\uff08DFS + Memoization Search\uff09\uff1a\u7b97\u662f\u52a8\u6001\u89c4\u5212\u7684\u4e00\u79cd\uff0c\u9012\u5f52\u6bcf\u6b21\u8fd4\u56de\u65f6\u540c\u65f6\u8bb0\u5f55\u4e0b\u5df2\u8bbf\u95ee\u8fc7\u7684\u8282\u70b9\u7279\u5f81\uff0c\u907f\u514d\u91cd\u590d\u8bbf\u95ee\u540c\u4e00\u4e2a\u8282\u70b9\uff0c\u53ef\u4ee5\u6709\u6548\u7684\u628a\u6307\u6570\u7ea7\u522b\u7684DFS\u65f6\u95f4\u590d\u6742\u5ea6\u964d\u4e3a\u591a\u9879\u5f0f\u7ea7\u522b"},{"location":"A.%20LeetCode/2.%20Algorithms%20and%20Tricks/Sorting/Quicksort/","text":"Quicksort","title":"Quicksort"},{"location":"A.%20LeetCode/2.%20Algorithms%20and%20Tricks/Sorting/Quicksort/#quicksort","text":"","title":"Quicksort"},{"location":"A.%20LeetCode/2.%20Algorithms%20and%20Tricks/Tricks/Adhoc/","text":"Adhoc (1) Sweep Line \u57fa\u7840\u77e5\u8bc6\uff1a\u4e00\u4e2a\u5f88\u5de7\u5999\u7684\u89e3\u51b3\u65f6\u95f4\u5b89\u6392\u51b2\u7a81\u7684\u7b97\u6cd5\uff0c\u672c\u8eab\u6bd4\u8f83\u5bb9\u6613\u4e9b\u4e5f\u5f88\u5bb9\u6613\u7406\u89e3 \u5e38\u89c1\u9898\u76ee\uff1a - Leetcode 253 Meeting Room II\uff08Meeting Room I\u4e5f\u53ef\u4ee5\u4f7f\u7528\uff09 - Leetcode 218 The Skyline Problem - Leetcode 759 Employee Free Time String \u9898\u76ee\u5206\u7c7b \u9898\u76ee\u7f16\u53f7 \u5b57\u7b26 520 \u56de\u6587\u4e32\u7684\u5b9a\u4e49 125 \u516c\u5171\u524d\u7f00 14 \u5355\u8bcd 434\u300158 \u5b57\u7b26\u4e32\u7684\u53cd\u8f6c 344\u3001541\u3001557\u3001151 \u5b57\u7b26\u7684\u7edf\u8ba1 387\u3001389\u3001383\u3001242\u300149\u3001451\u3001423\u3001657\u3001551\u3001696\u3001467\u3001535 \u6570\u5b57\u4e0e\u5b57\u7b26\u4e32\u95f4\u8f6c\u6362 299\u3001412\u3001506\u3001539\u3001553\u3001537\u3001592\u3001640\u300138\u3001443\u30018\u300113\u300112\u3001273\u3001165\u3001481 \u5b50\u5e8f\u5217 392\u3001524\u3001521\u3001522 \u9ad8\u7cbe\u5ea6\u8fd0\u7b97 66\u300167\u3001415\u300143\u3001306 \u5b57\u7b26\u4e32\u53d8\u6362 482\u30016\u300168 \u5b57\u7b26\u4e32\u5339\u914d 28\u3001686\u3001459\u3001214 \u4e2d\u5fc3\u62d3\u5c55\u6cd5 5\u3001647 Stack Leetcode 232. Implement Queue using Stacks Leetcode 150. Evaluate Reverse Polish Notation Leetcode 224. Basic Calculator II (I, II, III, IV) Leetcode 20. Valid Parentheses Leetcode 1472. Design Browser History Leetcode 1209. Remove All Adjacent Duplicates in String II Leetcode 1249. Minimum Remove to Make Valid Parentheses Leetcode 735. Asteroid Collision \u9898\u76ee\u5206\u7c7b \u9898\u76ee\u7f16\u53f7 \u7528\u6808\u8bbf\u95ee\u6700\u540e\u82e5\u5e72\u5143\u7d20 682\u300171\u3001388 \u6808\u4e0e\u8ba1\u7b97\u5668 150\u3001227\u3001224 \u6808\u4e0e\u62ec\u53f7\u5339\u914d 20\u3001636\u3001591\u300132 \u9012\u5f52 385\u3001341\u3001394 Sort \u57fa\u7840\u77e5\u8bc6\uff1a\u5feb\u901f\u6392\u5e8f\uff08Quick Sort\uff09\uff0c \u5f52\u5e76\u6392\u5e8f\uff08Merge Sort\uff09\u7684\u539f\u7406\u4e0e\u4ee3\u7801\u5b9e\u73b0\u3002\u9700\u8981\u80fd\u8bb2\u660e\u767d\u4ee3\u7801\u4e2d\u6bcf\u4e00\u884c\u7684\u76ee\u7684\u3002\u5feb\u901f\u6392\u5e8f\u65f6\u95f4\u590d\u6742\u5ea6\u5e73\u5747\u72b6\u6001\u4e0bO\uff08NlogN\uff09\uff0c\u7a7a\u95f4\u590d\u6742\u5ea6O\uff081\uff09\uff0c\u5f52\u5e76\u6392\u5e8f\u6700\u574f\u60c5\u51b5\u4e0b\u65f6\u95f4\u590d\u6742\u5ea6O\uff08NlogN\uff09\uff0c\u7a7a\u95f4\u590d\u6742\u5ea6O\uff08N\uff09 \u5165\u95e8\u9898\u76ee\uff1a Leetcode 148. Sort List Leetcode 56. Merge Intervals \u8fdb\u9636\u9898\u76ee\uff1a Leetcode 179. Largest Number Leetcode 75. Sort Colors Leetcode 215. Kth Largest Element Leetcode 4. Median of Two Sorted Arrays \u6ce8\u610f\uff1a\u540e\u4e24\u9898\u662f\u4e0e\u5feb\u901f\u6392\u5e8f\u975e\u5e38\u76f8\u4f3c\u7684\u5feb\u901f\u9009\u62e9\uff08Quick Select\uff09\u7b97\u6cd5\uff0c\u9762\u8bd5\u4e2d\u5f88\u5e38\u8003 Queue Leetcode 225. Implement Stack using Queues Leetcode 346. Moving Average from Data Stream Leetcode 281. Zigzag Iterator Leetcode 1429. First Unique Number Leetcode 54. Spiral Matrix Leetcode 362. Design Hit Counter Hash Leetcode 1. Two Sum Leetcode 146. LRU Cache (Python\u4e2d\u53ef\u4ee5\u4f7f\u7528OrderedDict\u6765\u4ee3\u66ff) Leetcode 128. Longest Consecutive Sequence Leetcode 73. Set Matrix Zeroes Leetcode 380. Insert Delete GetRandom O(1) Leetcode 49. Group Anagrams Leetcode 350. Intersection of Two Arrays II Leetcode 299. Bulls and Cows Leetcode 348 Design Tic-Tac-Toe \u9898\u76ee\u5206\u7c7b \u9898\u76ee\u7f16\u53f7 \u54c8\u5e0c\u8868\u7684\u67e5\u627e\u3001\u63d2\u5165\u53ca\u5220\u9664 217\u3001633\u3001349\u3001128\u3001202\u3001500\u3001290\u3001532\u3001205\u3001166\u3001466\u3001138 \u54c8\u5e0c\u8868\u4e0e\u7d22\u5f15 1\u3001167\u3001599\u3001219\u3001220 \u54c8\u5e0c\u8868\u4e0e\u7edf\u8ba1 594\u3001350\u3001554\u3001609\u3001454\u300118 \u54c8\u5e0c\u8868\u4e0e\u524d\u7f00\u548c 560\u3001523\u3001525 Greedy \u9898\u76ee\u5206\u7c7b \u9898\u76ee\u7f16\u53f7 \u6570\u7ec4\u4e0e\u8d2a\u5fc3\u7b97\u6cd5 605\u3001121\u3001122\u3001561\u3001455\u3001575\u3001135\u3001409\u3001621\u3001179\u300156\u300157\u3001228\u3001452\u3001435\u3001646\u3001406\u300148\u3001169\u3001215\u300175\u3001324\u3001517\u3001649\u3001678\u3001420 \u5b50\u6570\u7ec4\u4e0e\u8d2a\u5fc3\u7b97\u6cd5 53\u3001134\u3001581\u3001152 \u5b50\u5e8f\u5217\u4e0e\u8d2a\u5fc3\u7b97\u6cd5 334\u3001376\u3001659 \u6570\u5b57\u4e0e\u8d2a\u5fc3 343 \u5355\u8c03\u6808\u6cd5 496\u3001503\u3001456\u3001316\u3001402\u3001321\u300184\u300185 Problems (0, 1, 0) LC73. Set Matrix Zeroes (Medium) LC73. Set Matrix Zeroes (Medium) Info LC73. Set Matrix Zeroes (Medium) Algorithm: Adhoc Time Complexity: \\(O(n^2)\\) Space Complexity: \\(O(1)\\) Solution This is an Adhoc problem. Adhoc \\(O(n^2)\\) Python 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 class Solution : def setZeroes ( self , matrix : List [ List [ int ]]) -> None : \"\"\" Do not return anything, modify matrix in-place instead. \"\"\" # pre-processing to check the first row and the first column firstRowHasZero = any ([ matrix [ 0 ][ j ] == 0 for j in range ( len ( matrix [ 0 ]))]) firstColHasZero = any ([ matrix [ i ][ 0 ] == 0 for i in range ( len ( matrix ))]) # KEY: check each element and record the results in the first row and the first column for i in range ( len ( matrix )): for j in range ( len ( matrix [ 0 ])): if matrix [ i ][ j ] == 0 : matrix [ i ][ 0 ] = matrix [ 0 ][ j ] = 0 # sweep for i in range ( 1 , len ( matrix )): # starts from 1, not 0 if matrix [ i ][ 0 ] == 0 : for j in range ( len ( matrix [ 0 ])): matrix [ i ][ j ] = 0 for j in range ( 1 , len ( matrix [ 0 ])): # starts from 1, not 0 if matrix [ 0 ][ j ] == 0 : for i in range ( len ( matrix )): matrix [ i ][ j ] = 0 # post-processing if firstColHasZero : for i in range ( len ( matrix )): matrix [ i ][ 0 ] = 0 if firstRowHasZero : for j in range ( len ( matrix [ 0 ])): matrix [ 0 ][ j ] = 0","title":"Adhoc (1)"},{"location":"A.%20LeetCode/2.%20Algorithms%20and%20Tricks/Tricks/Adhoc/#adhoc-1","text":"","title":"Adhoc (1)"},{"location":"A.%20LeetCode/2.%20Algorithms%20and%20Tricks/Tricks/Adhoc/#sweep-line","text":"\u57fa\u7840\u77e5\u8bc6\uff1a\u4e00\u4e2a\u5f88\u5de7\u5999\u7684\u89e3\u51b3\u65f6\u95f4\u5b89\u6392\u51b2\u7a81\u7684\u7b97\u6cd5\uff0c\u672c\u8eab\u6bd4\u8f83\u5bb9\u6613\u4e9b\u4e5f\u5f88\u5bb9\u6613\u7406\u89e3 \u5e38\u89c1\u9898\u76ee\uff1a - Leetcode 253 Meeting Room II\uff08Meeting Room I\u4e5f\u53ef\u4ee5\u4f7f\u7528\uff09 - Leetcode 218 The Skyline Problem - Leetcode 759 Employee Free Time","title":"Sweep Line"},{"location":"A.%20LeetCode/2.%20Algorithms%20and%20Tricks/Tricks/Adhoc/#string","text":"\u9898\u76ee\u5206\u7c7b \u9898\u76ee\u7f16\u53f7 \u5b57\u7b26 520 \u56de\u6587\u4e32\u7684\u5b9a\u4e49 125 \u516c\u5171\u524d\u7f00 14 \u5355\u8bcd 434\u300158 \u5b57\u7b26\u4e32\u7684\u53cd\u8f6c 344\u3001541\u3001557\u3001151 \u5b57\u7b26\u7684\u7edf\u8ba1 387\u3001389\u3001383\u3001242\u300149\u3001451\u3001423\u3001657\u3001551\u3001696\u3001467\u3001535 \u6570\u5b57\u4e0e\u5b57\u7b26\u4e32\u95f4\u8f6c\u6362 299\u3001412\u3001506\u3001539\u3001553\u3001537\u3001592\u3001640\u300138\u3001443\u30018\u300113\u300112\u3001273\u3001165\u3001481 \u5b50\u5e8f\u5217 392\u3001524\u3001521\u3001522 \u9ad8\u7cbe\u5ea6\u8fd0\u7b97 66\u300167\u3001415\u300143\u3001306 \u5b57\u7b26\u4e32\u53d8\u6362 482\u30016\u300168 \u5b57\u7b26\u4e32\u5339\u914d 28\u3001686\u3001459\u3001214 \u4e2d\u5fc3\u62d3\u5c55\u6cd5 5\u3001647","title":"String"},{"location":"A.%20LeetCode/2.%20Algorithms%20and%20Tricks/Tricks/Adhoc/#stack","text":"Leetcode 232. Implement Queue using Stacks Leetcode 150. Evaluate Reverse Polish Notation Leetcode 224. Basic Calculator II (I, II, III, IV) Leetcode 20. Valid Parentheses Leetcode 1472. Design Browser History Leetcode 1209. Remove All Adjacent Duplicates in String II Leetcode 1249. Minimum Remove to Make Valid Parentheses Leetcode 735. Asteroid Collision \u9898\u76ee\u5206\u7c7b \u9898\u76ee\u7f16\u53f7 \u7528\u6808\u8bbf\u95ee\u6700\u540e\u82e5\u5e72\u5143\u7d20 682\u300171\u3001388 \u6808\u4e0e\u8ba1\u7b97\u5668 150\u3001227\u3001224 \u6808\u4e0e\u62ec\u53f7\u5339\u914d 20\u3001636\u3001591\u300132 \u9012\u5f52 385\u3001341\u3001394","title":"Stack"},{"location":"A.%20LeetCode/2.%20Algorithms%20and%20Tricks/Tricks/Adhoc/#sort","text":"\u57fa\u7840\u77e5\u8bc6\uff1a\u5feb\u901f\u6392\u5e8f\uff08Quick Sort\uff09\uff0c \u5f52\u5e76\u6392\u5e8f\uff08Merge Sort\uff09\u7684\u539f\u7406\u4e0e\u4ee3\u7801\u5b9e\u73b0\u3002\u9700\u8981\u80fd\u8bb2\u660e\u767d\u4ee3\u7801\u4e2d\u6bcf\u4e00\u884c\u7684\u76ee\u7684\u3002\u5feb\u901f\u6392\u5e8f\u65f6\u95f4\u590d\u6742\u5ea6\u5e73\u5747\u72b6\u6001\u4e0bO\uff08NlogN\uff09\uff0c\u7a7a\u95f4\u590d\u6742\u5ea6O\uff081\uff09\uff0c\u5f52\u5e76\u6392\u5e8f\u6700\u574f\u60c5\u51b5\u4e0b\u65f6\u95f4\u590d\u6742\u5ea6O\uff08NlogN\uff09\uff0c\u7a7a\u95f4\u590d\u6742\u5ea6O\uff08N\uff09","title":"Sort"},{"location":"A.%20LeetCode/2.%20Algorithms%20and%20Tricks/Tricks/Adhoc/#_1","text":"Leetcode 148. Sort List Leetcode 56. Merge Intervals","title":"\u5165\u95e8\u9898\u76ee\uff1a"},{"location":"A.%20LeetCode/2.%20Algorithms%20and%20Tricks/Tricks/Adhoc/#_2","text":"Leetcode 179. Largest Number Leetcode 75. Sort Colors Leetcode 215. Kth Largest Element Leetcode 4. Median of Two Sorted Arrays \u6ce8\u610f\uff1a\u540e\u4e24\u9898\u662f\u4e0e\u5feb\u901f\u6392\u5e8f\u975e\u5e38\u76f8\u4f3c\u7684\u5feb\u901f\u9009\u62e9\uff08Quick Select\uff09\u7b97\u6cd5\uff0c\u9762\u8bd5\u4e2d\u5f88\u5e38\u8003","title":"\u8fdb\u9636\u9898\u76ee\uff1a"},{"location":"A.%20LeetCode/2.%20Algorithms%20and%20Tricks/Tricks/Adhoc/#queue","text":"Leetcode 225. Implement Stack using Queues Leetcode 346. Moving Average from Data Stream Leetcode 281. Zigzag Iterator Leetcode 1429. First Unique Number Leetcode 54. Spiral Matrix Leetcode 362. Design Hit Counter","title":"Queue"},{"location":"A.%20LeetCode/2.%20Algorithms%20and%20Tricks/Tricks/Adhoc/#hash","text":"Leetcode 1. Two Sum Leetcode 146. LRU Cache (Python\u4e2d\u53ef\u4ee5\u4f7f\u7528OrderedDict\u6765\u4ee3\u66ff) Leetcode 128. Longest Consecutive Sequence Leetcode 73. Set Matrix Zeroes Leetcode 380. Insert Delete GetRandom O(1) Leetcode 49. Group Anagrams Leetcode 350. Intersection of Two Arrays II Leetcode 299. Bulls and Cows Leetcode 348 Design Tic-Tac-Toe \u9898\u76ee\u5206\u7c7b \u9898\u76ee\u7f16\u53f7 \u54c8\u5e0c\u8868\u7684\u67e5\u627e\u3001\u63d2\u5165\u53ca\u5220\u9664 217\u3001633\u3001349\u3001128\u3001202\u3001500\u3001290\u3001532\u3001205\u3001166\u3001466\u3001138 \u54c8\u5e0c\u8868\u4e0e\u7d22\u5f15 1\u3001167\u3001599\u3001219\u3001220 \u54c8\u5e0c\u8868\u4e0e\u7edf\u8ba1 594\u3001350\u3001554\u3001609\u3001454\u300118 \u54c8\u5e0c\u8868\u4e0e\u524d\u7f00\u548c 560\u3001523\u3001525","title":"Hash"},{"location":"A.%20LeetCode/2.%20Algorithms%20and%20Tricks/Tricks/Adhoc/#greedy","text":"\u9898\u76ee\u5206\u7c7b \u9898\u76ee\u7f16\u53f7 \u6570\u7ec4\u4e0e\u8d2a\u5fc3\u7b97\u6cd5 605\u3001121\u3001122\u3001561\u3001455\u3001575\u3001135\u3001409\u3001621\u3001179\u300156\u300157\u3001228\u3001452\u3001435\u3001646\u3001406\u300148\u3001169\u3001215\u300175\u3001324\u3001517\u3001649\u3001678\u3001420 \u5b50\u6570\u7ec4\u4e0e\u8d2a\u5fc3\u7b97\u6cd5 53\u3001134\u3001581\u3001152 \u5b50\u5e8f\u5217\u4e0e\u8d2a\u5fc3\u7b97\u6cd5 334\u3001376\u3001659 \u6570\u5b57\u4e0e\u8d2a\u5fc3 343 \u5355\u8c03\u6808\u6cd5 496\u3001503\u3001456\u3001316\u3001402\u3001321\u300184\u300185","title":"Greedy"},{"location":"A.%20LeetCode/2.%20Algorithms%20and%20Tricks/Tricks/Adhoc/#problems-0-1-0","text":"","title":"Problems (0, 1, 0)"},{"location":"A.%20LeetCode/2.%20Algorithms%20and%20Tricks/Tricks/Adhoc/#lc73-set-matrix-zeroes-medium","text":"LC73. Set Matrix Zeroes (Medium) Info LC73. Set Matrix Zeroes (Medium) Algorithm: Adhoc Time Complexity: \\(O(n^2)\\) Space Complexity: \\(O(1)\\) Solution This is an Adhoc problem. Adhoc \\(O(n^2)\\) Python 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 class Solution : def setZeroes ( self , matrix : List [ List [ int ]]) -> None : \"\"\" Do not return anything, modify matrix in-place instead. \"\"\" # pre-processing to check the first row and the first column firstRowHasZero = any ([ matrix [ 0 ][ j ] == 0 for j in range ( len ( matrix [ 0 ]))]) firstColHasZero = any ([ matrix [ i ][ 0 ] == 0 for i in range ( len ( matrix ))]) # KEY: check each element and record the results in the first row and the first column for i in range ( len ( matrix )): for j in range ( len ( matrix [ 0 ])): if matrix [ i ][ j ] == 0 : matrix [ i ][ 0 ] = matrix [ 0 ][ j ] = 0 # sweep for i in range ( 1 , len ( matrix )): # starts from 1, not 0 if matrix [ i ][ 0 ] == 0 : for j in range ( len ( matrix [ 0 ])): matrix [ i ][ j ] = 0 for j in range ( 1 , len ( matrix [ 0 ])): # starts from 1, not 0 if matrix [ 0 ][ j ] == 0 : for i in range ( len ( matrix )): matrix [ i ][ j ] = 0 # post-processing if firstColHasZero : for i in range ( len ( matrix )): matrix [ i ][ 0 ] = 0 if firstRowHasZero : for j in range ( len ( matrix [ 0 ])): matrix [ 0 ][ j ] = 0","title":"LC73. Set Matrix Zeroes (Medium)"},{"location":"A.%20LeetCode/2.%20Algorithms%20and%20Tricks/Tricks/Bit_Manipulation/","text":"Bit Manipulation (152) \u4f4d\u8fd0\u7b97\u9898\u5e93\uff08\u5171152\u9898\uff09","title":"Bit Manipulation (152)"},{"location":"A.%20LeetCode/2.%20Algorithms%20and%20Tricks/Tricks/Bit_Manipulation/#bit-manipulation-152","text":"\u4f4d\u8fd0\u7b97\u9898\u5e93\uff08\u5171152\u9898\uff09","title":"Bit Manipulation (152)"},{"location":"A.%20LeetCode/2.%20Algorithms%20and%20Tricks/Tricks/Presum/","text":"Presum (2) ID Title Difficulty 1524 Number of Sub-arrays With Odd Sum Medium 1525 Number of Good Ways to Split a String Medium LC1524. Number of Sub-arrays With Odd Sum (Medium) Info LC1524. Number of Sub-arrays With Odd Sum (Medium) Algorithm: Presum Time Complexity: \\(O(n)\\) Space Complexity: \\(O(n)\\) Solution Presum. Presum \\(O(n)\\) Python 1 2 3 4 5 6 7 8 9 10 11 12 13 14 class Solution : def numOfSubarrays ( self , arr : List [ int ]) -> int : s , odd , even = 0 , 0 , 1 ans = 0 for n in arr : s += n if s % 2 == 0 : even += 1 ans += odd else : odd += 1 ans += even return ans % ( 10 ** 9 + 7 ) LC1525. Number of Good Ways to Split a String (Medium) Info LC1525. Number of Good Ways to Split a String (Medium) Algorithm: Presum Time Complexity: \\(O(n)\\) Space Complexity: \\(O(n)\\) Solution Presum. Presum \\(O(n)\\) Python 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 from collections import defaultdict class Solution : def numSplits ( self , s : str ) -> int : chSet2 = defaultdict ( int ) count2 = 0 for ch in s : chSet2 [ ch ] += 1 if chSet2 [ ch ] == 1 : count2 += 1 ans = 0 count1 = 0 chSet1 = defaultdict ( int ) for i in range ( len ( s )): chSet1 [ s [ i ]] += 1 if chSet1 [ s [ i ]] == 1 : count1 += 1 chSet2 [ s [ i ]] -= 1 if chSet2 [ s [ i ]] == 0 : count2 -= 1 chSet2 . pop ( s [ i ]) if count1 == count2 : ans += 1 return ans","title":"Presum (2)"},{"location":"A.%20LeetCode/2.%20Algorithms%20and%20Tricks/Tricks/Presum/#presum-2","text":"ID Title Difficulty 1524 Number of Sub-arrays With Odd Sum Medium 1525 Number of Good Ways to Split a String Medium LC1524. Number of Sub-arrays With Odd Sum (Medium) Info LC1524. Number of Sub-arrays With Odd Sum (Medium) Algorithm: Presum Time Complexity: \\(O(n)\\) Space Complexity: \\(O(n)\\) Solution Presum. Presum \\(O(n)\\) Python 1 2 3 4 5 6 7 8 9 10 11 12 13 14 class Solution : def numOfSubarrays ( self , arr : List [ int ]) -> int : s , odd , even = 0 , 0 , 1 ans = 0 for n in arr : s += n if s % 2 == 0 : even += 1 ans += odd else : odd += 1 ans += even return ans % ( 10 ** 9 + 7 ) LC1525. Number of Good Ways to Split a String (Medium) Info LC1525. Number of Good Ways to Split a String (Medium) Algorithm: Presum Time Complexity: \\(O(n)\\) Space Complexity: \\(O(n)\\) Solution Presum. Presum \\(O(n)\\) Python 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 from collections import defaultdict class Solution : def numSplits ( self , s : str ) -> int : chSet2 = defaultdict ( int ) count2 = 0 for ch in s : chSet2 [ ch ] += 1 if chSet2 [ ch ] == 1 : count2 += 1 ans = 0 count1 = 0 chSet1 = defaultdict ( int ) for i in range ( len ( s )): chSet1 [ s [ i ]] += 1 if chSet1 [ s [ i ]] == 1 : count1 += 1 chSet2 [ s [ i ]] -= 1 if chSet2 [ s [ i ]] == 0 : count2 -= 1 chSet2 . pop ( s [ i ]) if count1 == count2 : ans += 1 return ans","title":"Presum (2)"},{"location":"A.%20LeetCode/2.%20Algorithms%20and%20Tricks/Tricks/Sliding_Window_Two_Pointers/","text":"Sliding Window and Two Pointers \uff08252\uff09 \u6ed1\u52a8\u7a97\u53e3\u9898\u5e93\uff08\u517176\u9898\uff09 \u6ed1\u52a8\u7a97\u53e3\u9898\u5e93\uff08\u5171176\u9898\uff09 \u6ed1\u52a8\u7a97\u53e3\u4e0e\u53cc\u6307\u9488\u6559\u7a0b \u57fa\u7840\u77e5\u8bc6 \u5e38\u89c1\u53cc\u6307\u9488\u7b97\u6cd5\u5206\u4e3a\u4e09\u7c7b\uff0c\u540c\u5411\uff08\u5373\u4e24\u4e2a\u6307\u9488\u90fd\u76f8\u540c\u4e00\u4e2a\u65b9\u5411\u79fb\u52a8\uff09\uff0c\u80cc\u5411\uff08\u4e24\u4e2a\u6307\u9488\u4ece\u76f8\u540c\u6216\u8005\u76f8\u90bb\u7684\u4f4d\u7f6e\u51fa\u53d1\uff0c\u80cc\u5411\u79fb\u52a8\u76f4\u5230\u5176\u4e2d\u4e00\u6839\u6307\u9488\u5230\u8fbe\u8fb9\u754c\u4e3a\u6b62\uff09\uff0c\u76f8\u5411\uff08\u4e24\u4e2a\u6307\u9488\u4ece\u4e24\u8fb9\u51fa\u53d1\u4e00\u8d77\u5411\u4e2d\u95f4\u79fb\u52a8\u76f4\u5230\u4e24\u4e2a\u6307\u9488\u76f8\u9047\uff09 \u80cc\u5411\u53cc\u6307\u9488\uff1a(\u57fa\u672c\u4e0a\u5168\u662f\u56de\u6587\u4e32\u7684\u9898) Leetcode 409. Longest Palindrome Leetcode 125. Valid Palindrome Leetcode 5. Longest Palindromic Substring \u76f8\u5411\u53cc\u6307\u9488\uff1a(\u4ee5two sum\u4e3a\u57fa\u7840\u7684\u4e00\u7cfb\u5217\u9898) Leetcode 1. Two Sum (\u8fd9\u91cc\u4f7f\u7528\u7684\u662f\u5148\u6392\u5e8f\u7684\u53cc\u6307\u9488\u7b97\u6cd5\uff0c\u4e0d\u540c\u4e8ehashmap\u505a\u6cd5) Leetcode 167. Two Sum II - Input array is sorted Leetcode 15. 3Sum Leetcode 16. 3Sum Closest Leetcode 18. 4Sum Leetcode 454. 4Sum II Leetcode 277. Find the Celebrity \u540c\u5411\u53cc\u6307\u9488\uff1a\uff08\u4e2a\u4eba\u89c9\u5f97\u6700\u96be\u7684\u4e00\u7c7b\u9898\uff09 Leetcode 283. Move Zeroes Leetcode 26. Remove Duplicate Numbers in Array Leetcode 395. Longest Substring with At Least K Repeating Characters Leetcode 340. Longest Substring with At Most K Distinct Characters Leetcode 76. Minimum Window Substring Leetcode 3. Longest Substring Without Repeating Characters \u9898\u76ee\u5206\u7c7b \u9898\u76ee\u7f16\u53f7 \u5934\u5c3e\u6307\u9488 345\u3001680\u3001167\u300115\u300116\u300118\u300111\u300142 \u540c\u5411\u53cc\u6307\u9488\u3001\u6ed1\u52a8\u7a97\u53e3 27\u300126\u300180\u300183\u300182\u3001611\u3001187\u3001643\u3001674\u3001209\u30013\u3001438\u3001567\u3001424\u300176\u300130 \u5206\u6bb5\u53cc\u6307\u9488 86\u3001328\u3001160\u300188\u3001475 \u5feb\u6162\u6307\u9488 141\u3001142\u3001143\u3001234\u3001457\u3001287","title":"Sliding Window and Two Pointers \uff08252\uff09"},{"location":"A.%20LeetCode/2.%20Algorithms%20and%20Tricks/Tricks/Sliding_Window_Two_Pointers/#sliding-window-and-two-pointers-252","text":"\u6ed1\u52a8\u7a97\u53e3\u9898\u5e93\uff08\u517176\u9898\uff09 \u6ed1\u52a8\u7a97\u53e3\u9898\u5e93\uff08\u5171176\u9898\uff09 \u6ed1\u52a8\u7a97\u53e3\u4e0e\u53cc\u6307\u9488\u6559\u7a0b","title":"Sliding Window and Two Pointers \uff08252\uff09"},{"location":"A.%20LeetCode/2.%20Algorithms%20and%20Tricks/Tricks/Sliding_Window_Two_Pointers/#_1","text":"\u5e38\u89c1\u53cc\u6307\u9488\u7b97\u6cd5\u5206\u4e3a\u4e09\u7c7b\uff0c\u540c\u5411\uff08\u5373\u4e24\u4e2a\u6307\u9488\u90fd\u76f8\u540c\u4e00\u4e2a\u65b9\u5411\u79fb\u52a8\uff09\uff0c\u80cc\u5411\uff08\u4e24\u4e2a\u6307\u9488\u4ece\u76f8\u540c\u6216\u8005\u76f8\u90bb\u7684\u4f4d\u7f6e\u51fa\u53d1\uff0c\u80cc\u5411\u79fb\u52a8\u76f4\u5230\u5176\u4e2d\u4e00\u6839\u6307\u9488\u5230\u8fbe\u8fb9\u754c\u4e3a\u6b62\uff09\uff0c\u76f8\u5411\uff08\u4e24\u4e2a\u6307\u9488\u4ece\u4e24\u8fb9\u51fa\u53d1\u4e00\u8d77\u5411\u4e2d\u95f4\u79fb\u52a8\u76f4\u5230\u4e24\u4e2a\u6307\u9488\u76f8\u9047\uff09","title":"\u57fa\u7840\u77e5\u8bc6"},{"location":"A.%20LeetCode/2.%20Algorithms%20and%20Tricks/Tricks/Sliding_Window_Two_Pointers/#_2","text":"Leetcode 409. Longest Palindrome Leetcode 125. Valid Palindrome Leetcode 5. Longest Palindromic Substring","title":"\u80cc\u5411\u53cc\u6307\u9488\uff1a(\u57fa\u672c\u4e0a\u5168\u662f\u56de\u6587\u4e32\u7684\u9898)"},{"location":"A.%20LeetCode/2.%20Algorithms%20and%20Tricks/Tricks/Sliding_Window_Two_Pointers/#two-sum","text":"Leetcode 1. Two Sum (\u8fd9\u91cc\u4f7f\u7528\u7684\u662f\u5148\u6392\u5e8f\u7684\u53cc\u6307\u9488\u7b97\u6cd5\uff0c\u4e0d\u540c\u4e8ehashmap\u505a\u6cd5) Leetcode 167. Two Sum II - Input array is sorted Leetcode 15. 3Sum Leetcode 16. 3Sum Closest Leetcode 18. 4Sum Leetcode 454. 4Sum II Leetcode 277. Find the Celebrity","title":"\u76f8\u5411\u53cc\u6307\u9488\uff1a(\u4ee5two sum\u4e3a\u57fa\u7840\u7684\u4e00\u7cfb\u5217\u9898)"},{"location":"A.%20LeetCode/2.%20Algorithms%20and%20Tricks/Tricks/Sliding_Window_Two_Pointers/#_3","text":"Leetcode 283. Move Zeroes Leetcode 26. Remove Duplicate Numbers in Array Leetcode 395. Longest Substring with At Least K Repeating Characters Leetcode 340. Longest Substring with At Most K Distinct Characters Leetcode 76. Minimum Window Substring Leetcode 3. Longest Substring Without Repeating Characters \u9898\u76ee\u5206\u7c7b \u9898\u76ee\u7f16\u53f7 \u5934\u5c3e\u6307\u9488 345\u3001680\u3001167\u300115\u300116\u300118\u300111\u300142 \u540c\u5411\u53cc\u6307\u9488\u3001\u6ed1\u52a8\u7a97\u53e3 27\u300126\u300180\u300183\u300182\u3001611\u3001187\u3001643\u3001674\u3001209\u30013\u3001438\u3001567\u3001424\u300176\u300130 \u5206\u6bb5\u53cc\u6307\u9488 86\u3001328\u3001160\u300188\u3001475 \u5feb\u6162\u6307\u9488 141\u3001142\u3001143\u3001234\u3001457\u3001287","title":"\u540c\u5411\u53cc\u6307\u9488\uff1a\uff08\u4e2a\u4eba\u89c9\u5f97\u6700\u96be\u7684\u4e00\u7c7b\u9898\uff09"},{"location":"A.%20LeetCode/3.%20Math/Binary%20Exponentiation/","text":"Binary Exponentiation \u5feb\u901f\u5e42\u662f\u4e00\u4e2a\u5728 \\(\\Theta(\\log n)\\) \u7684\u65f6\u95f4\u5185\u8ba1\u7b97 \\(a^n\\) \u7684\u5c0f\u6280\u5de7\uff0c\u800c\u66b4\u529b\u7684\u8ba1\u7b97\u9700\u8981 \\(\\Theta(n)\\) \u7684\u65f6\u95f4\u3002\u4e8b\u5b9e\u4e0a\uff0c\u8fd9\u4e2a\u6280\u5de7\u4e5f\u7ecf\u5e38\u7528\u5728\u5177\u6709\u7ed3\u5408\u5f8b\u7684\u975e\u8ba1\u7b97\u7684\u573a\u666f\u4e2d\uff0c\u6bd4\u5982\u53d6\u6a21\u3001\u77e9\u9635\u5e42\u7b49\u7b49\u3002 \u7b97\u6cd5\u63cf\u8ff0","title":"Binary Exponentiation"},{"location":"A.%20LeetCode/3.%20Math/Binary%20Exponentiation/#binary-exponentiation","text":"\u5feb\u901f\u5e42\u662f\u4e00\u4e2a\u5728 \\(\\Theta(\\log n)\\) \u7684\u65f6\u95f4\u5185\u8ba1\u7b97 \\(a^n\\) \u7684\u5c0f\u6280\u5de7\uff0c\u800c\u66b4\u529b\u7684\u8ba1\u7b97\u9700\u8981 \\(\\Theta(n)\\) \u7684\u65f6\u95f4\u3002\u4e8b\u5b9e\u4e0a\uff0c\u8fd9\u4e2a\u6280\u5de7\u4e5f\u7ecf\u5e38\u7528\u5728\u5177\u6709\u7ed3\u5408\u5f8b\u7684\u975e\u8ba1\u7b97\u7684\u573a\u666f\u4e2d\uff0c\u6bd4\u5982\u53d6\u6a21\u3001\u77e9\u9635\u5e42\u7b49\u7b49\u3002","title":"Binary Exponentiation"},{"location":"A.%20LeetCode/3.%20Math/Binary%20Exponentiation/#_1","text":"","title":"\u7b97\u6cd5\u63cf\u8ff0"},{"location":"A.%20LeetCode/3.%20Math/Josephus_Problem/","text":"Josephus Problem Problem Notes 1823. Find the Winner of the Circular Game (Medium) LC1823. Find the Winner of the Circular Game (Medium) Info LC1823. Find the Winner of the Circular Game (Medium) Algorithm: DP | Josephus Problem Time Complexity: \\(O(n)\\) Space Complexity: \\(O(1)\\) Solution DP | Josephus Problem Main Method \\(O(n)\\) Python 1 2 3 4 5 6 7 class Solution : def findTheWinner ( self , n : int , k : int ) -> int : def helper ( m ): if m == 1 : return 0 # index starts from 0 return ( helper ( m - 1 ) + k ) % m return helper ( n ) + 1 # convert back to start from 1","title":"Josephus Problem"},{"location":"A.%20LeetCode/3.%20Math/Josephus_Problem/#josephus-problem","text":"Problem Notes 1823. Find the Winner of the Circular Game (Medium) LC1823. Find the Winner of the Circular Game (Medium) Info LC1823. Find the Winner of the Circular Game (Medium) Algorithm: DP | Josephus Problem Time Complexity: \\(O(n)\\) Space Complexity: \\(O(1)\\) Solution DP | Josephus Problem Main Method \\(O(n)\\) Python 1 2 3 4 5 6 7 class Solution : def findTheWinner ( self , n : int , k : int ) -> int : def helper ( m ): if m == 1 : return 0 # index starts from 0 return ( helper ( m - 1 ) + k ) % m return helper ( n ) + 1 # convert back to start from 1","title":"Josephus Problem"},{"location":"A.%20LeetCode/4.%20Problems/Arrangement/","text":"Arrangement LC984, LC1968","title":"Arrangement"},{"location":"A.%20LeetCode/4.%20Problems/Arrangement/#arrangement","text":"LC984, LC1968","title":"Arrangement"},{"location":"A.%20LeetCode/4.%20Problems/Combination%20and%20Permutation/","text":"Combination and Permutation (14) - LC77. Combinations Related Problems Problem Type LC0031. Next Permutation LC0039. Combination Sum LC0040. Combination Sum II LC0046. Permutations LC0047. Permutations II LC0060. Permutation Sequence LC0077. Combinations LC0216. Combination Sum III LC0377. Combination Sum IV LC0567. Permutation in String LC0784. Letter Case Permutation JZ0038. String Permutation LCCI0807. Permutation I LCCI0808. Permutation II","title":"Combination and Permutation (14)"},{"location":"A.%20LeetCode/4.%20Problems/Combination%20and%20Permutation/#combination-and-permutation-14","text":"","title":"Combination and Permutation (14)"},{"location":"A.%20LeetCode/4.%20Problems/Combination%20and%20Permutation/#-lc77-combinations","text":"","title":"- LC77. Combinations"},{"location":"A.%20LeetCode/4.%20Problems/Combination%20and%20Permutation/#related-problems","text":"Problem Type LC0031. Next Permutation LC0039. Combination Sum LC0040. Combination Sum II LC0046. Permutations LC0047. Permutations II LC0060. Permutation Sequence LC0077. Combinations LC0216. Combination Sum III LC0377. Combination Sum IV LC0567. Permutation in String LC0784. Letter Case Permutation JZ0038. String Permutation LCCI0807. Permutation I LCCI0808. Permutation II","title":"Related Problems"},{"location":"A.%20LeetCode/4.%20Problems/Lecture%200/","text":"Lecture 1. Bit (17) Pow(x, n) Single Number II Bitwise AND of Numbers Range Single Number III Sum of Two Integers Integer Replacement Partition Equal Subset Sum Partitioning Into Minimum Number Of Deci-Binary Numbers \u5251\u6307 Offer 56 - I. \u6570\u7ec4\u4e2d\u6570\u5b57\u51fa\u73b0\u7684\u6b21\u6570 LCOF \u5251\u6307 Offer 56 - II. \u6570\u7ec4\u4e2d\u6570\u5b57\u51fa\u73b0\u7684\u6b21\u6570 II LCOF \u5251\u6307 Offer II 079. \u6240\u6709\u5b50\u96c6 \u9762\u8bd5\u9898 05.02. Binary Number to String LCCI \u9762\u8bd5\u9898 05.04. Closed Number LCCI \u9762\u8bd5\u9898 08.04. Power Set LCCI \u9762\u8bd5\u9898 08.05. Recursive Mulitply LCCI \u9762\u8bd5\u9898 16.01. Swap Numbers LCCI \u9762\u8bd5\u9898 17.19. Missing Two LCCI","title":"Lecture 1. Bit (17)"},{"location":"A.%20LeetCode/4.%20Problems/Lecture%200/#lecture-1-bit-17","text":"Pow(x, n) Single Number II Bitwise AND of Numbers Range Single Number III Sum of Two Integers Integer Replacement Partition Equal Subset Sum Partitioning Into Minimum Number Of Deci-Binary Numbers \u5251\u6307 Offer 56 - I. \u6570\u7ec4\u4e2d\u6570\u5b57\u51fa\u73b0\u7684\u6b21\u6570 LCOF \u5251\u6307 Offer 56 - II. \u6570\u7ec4\u4e2d\u6570\u5b57\u51fa\u73b0\u7684\u6b21\u6570 II LCOF \u5251\u6307 Offer II 079. \u6240\u6709\u5b50\u96c6 \u9762\u8bd5\u9898 05.02. Binary Number to String LCCI \u9762\u8bd5\u9898 05.04. Closed Number LCCI \u9762\u8bd5\u9898 08.04. Power Set LCCI \u9762\u8bd5\u9898 08.05. Recursive Mulitply LCCI \u9762\u8bd5\u9898 16.01. Swap Numbers LCCI \u9762\u8bd5\u9898 17.19. Missing Two LCCI","title":"Lecture 1. Bit (17)"},{"location":"A.%20LeetCode/4.%20Problems/Lecture%201/","text":"Lecture 2. Linked List (14) Add Two Numbers Remove Nth Node From End of List Swap Nodes in Pairs Rotate List Flatten Binary Tree to Linked List Linked List Cycle II Reorder List Linked List Random Node Design Linked List Next Greater Node In Linked List Linked List in Binary Tree \u5251\u6307 Offer II 021. \u5220\u9664\u94fe\u8868\u7684\u5012\u6570\u7b2c n \u4e2a\u7ed3\u70b9 \u5251\u6307 Offer II 026. \u91cd\u6392\u94fe\u8868 \u9762\u8bd5\u9898 02.05. Sum Lists LCCI","title":"Lecture 2. Linked List (14)"},{"location":"A.%20LeetCode/4.%20Problems/Lecture%201/#lecture-2-linked-list-14","text":"Add Two Numbers Remove Nth Node From End of List Swap Nodes in Pairs Rotate List Flatten Binary Tree to Linked List Linked List Cycle II Reorder List Linked List Random Node Design Linked List Next Greater Node In Linked List Linked List in Binary Tree \u5251\u6307 Offer II 021. \u5220\u9664\u94fe\u8868\u7684\u5012\u6570\u7b2c n \u4e2a\u7ed3\u70b9 \u5251\u6307 Offer II 026. \u91cd\u6392\u94fe\u8868 \u9762\u8bd5\u9898 02.05. Sum Lists LCCI","title":"Lecture 2. Linked List (14)"},{"location":"A.%20LeetCode/4.%20Problems/Lecture%202/","text":"Lecture 3. Tree (62) Tree Traversal Binary Tree Level Order Traversal Binary Tree Zigzag Level Order Traversal Binary Tree Level Order Traversal II Path Sum II Problem Notes \u5251\u6307 Offer II 045. \u4e8c\u53c9\u6811\u6700\u5e95\u5c42\u6700\u5de6\u8fb9\u7684\u503c Recursion LC114. Flatten Binary Tree to Linked List Pre-order Traversal LC116. Populating Next Right Pointers in Each Node Level Traversal JZ045. \u5251\u6307 Offer II 045. \u4e8c\u53c9\u6811\u6700\u5e95\u5c42\u6700\u5de6\u8fb9\u7684\u503c (Medium) Info JZ045. \u5251\u6307 Offer II 045. \u4e8c\u53c9\u6811\u6700\u5e95\u5c42\u6700\u5de6\u8fb9\u7684\u503c (Medium) Algorithm: Two Pointers Time Complexity: \\(O(n)\\) Space Complexity: \\(O(n)\\) Solution Two Pointers. Same as LC209. Two Pointers \\(O(n)\\) Python 1 2 3 4 5 6 class Solution : def findBottomLeftValue ( self , root ): queue = [ root ] for node in queue : queue += filter ( None , ( node . right , node . left )) return node . val LC114. Flatten Binary Tree to Linked List (Medium) Info LC114. Flatten Binary Tree to Linked List (Medium) Algorithm: Binary Search Time Complexity: \\(O(\\log n)\\) Space Complexity: \\(O(1)\\) Solution Main Method O(n) Python 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 class Solution : def helper ( self , root : TreeNode ) -> List [ TreeNode ]: HEAD , TAIL = 0 , 1 # Base Case if not root : return [ None , None ] # DFS left = self . helper ( root . left ) right = self . helper ( root . right ) # Merge root . left = None newTail = root if left [ HEAD ]: root . right = left [ HEAD ] left [ TAIL ] . right = right [ HEAD ] newTail = left [ TAIL ] if right [ HEAD ]: newTail = right [ TAIL ] # Return return [ root , newTail ] # the first node and the last node of the linked list def flatten ( self , root : TreeNode ) -> None : \"\"\" Do not return anything, modify root in-place instead. \"\"\" self . helper ( root ) LC116. Populating Next Right Pointers in Each Node (Medium) Info LC116. Populating Next Right Pointers in Each Node (Medium) Algorithm: Binary Search Time Complexity: \\(O(\\log n)\\) Space Complexity: \\(O(1)\\) Solution Main Method O(n) Python 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 class Solution : def connect ( self , root : 'Node' ) -> 'Node' : if not root : return None Queue = [ root ] while Queue : levelQueue = [] for node in Queue : if node . left : levelQueue . append ( node . left ) if node . right : levelQueue . append ( node . right ) for i in range ( len ( levelQueue ) - 1 ): levelQueue [ i ] . next = levelQueue [ i + 1 ] Queue = levelQueue return root Tree Validation Problem Notes 98. Validate Binary Search Tree Recursion Validate Binary Tree Nodes LC98. Validate Binary Search Tree (Medium) Info LC98. Validate Binary Search Tree (Medium) Algorithm: Recursion Time Complexity: \\(O(n)\\) Space Complexity: \\(O(n)\\) Solution Recursion. Recursion \\(O(n)\\) Python 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 # Definition for a binary tree node. # class TreeNode: # def __init__(self, val=0, left=None, right=None): # self.val = val # self.left = left # self.right = right class Solution : def helper ( self , root : TreeNode ) -> List [ int ]: if not root : return [ 1e16 , - 1e16 , True ] # min, max, isBST left = self . helper ( root . left ) right = self . helper ( root . right ) min_val = min ( root . val , left [ 0 ]) max_val = max ( root . val , right [ 1 ]) isBST = left [ 1 ] < root . val and right [ 0 ] > root . val and left [ 2 ] and right [ 2 ] return [ min_val , max_val , isBST ] def isValidBST ( self , root : TreeNode ) -> bool : ans = self . helper ( root ) return ans [ - 1 ] Tree Construction Construct Binary Tree from Preorder and Inorder Traversal Construct Binary Tree from Inorder and Postorder Traversal Convert Sorted List to Binary Search Tree Problem Notes 95. Unique Binary Search Trees II Recursion 96. Unique Binary Search Trees DP LC95. Unique Binary Search Trees II (Medium) Info LC95. Unique Binary Search Trees II (Medium) Algorithm: DP Time Complexity: \\(O(n)\\) Space Complexity: \\(O(n)\\) Solution Recursion. Recursion \\(O(n)\\) Python 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 class Solution : def __init__ ( self ): self . cache = dict () def tree ( self , i , j ) -> List [ TreeNode ]: if i > j : return [ None ] ans = [] for r in range ( i , j + 1 ): if ( i , r - 1 ) not in self . cache : self . cache [( i , r - 1 )] = self . tree ( i , r - 1 ) if ( r + 1 , j ) not in self . cache : self . cache [( r + 1 , j )] = self . tree ( r + 1 , j ) for left in self . cache [( i , r - 1 )]: for right in self . cache [( r + 1 , j )]: ans . append ( TreeNode ( r , left , right )) return ans def generateTrees ( self , n : int ) -> List [ TreeNode ]: return self . tree ( 1 , n ) LC96. Unique Binary Search Trees (Medium) Info LC96. Unique Binary Search Trees (Medium) Algorithm: DP Time Complexity: \\(O(n)\\) Space Complexity: \\(O(n)\\) Solution DP. Recursion \\(O(n)\\) Python 1 2 3 4 5 6 7 8 9 10 class Solution : def numTrees ( self , n : int ) -> int : DP = [ 0 ] * ( n + 1 ) DP [ 0 ], DP [ 1 ] = 1 , 1 for i in range ( 2 , n + 1 ): for j in range ( 1 , i + 1 ): DP [ i ] += DP [ j - 1 ] * DP [ i - j ] return DP [ - 1 ] Populating Next Right Pointers in Each Node II Binary Tree Maximum Path Sum Sum Root to Leaf Numbers Binary Search Tree Iterator Binary Tree Right Side View Count Complete Tree Nodes Kth Smallest Element in a BST Lowest Common Ancestor of a Binary Tree N-ary Tree Level Order Traversal Path Sum III Delete Node in a BST Most Frequent Subtree Sum Find Bottom Left Tree Value Find Largest Value in Each Tree Row Convert BST to Greater Tree Add One Row to Tree Maximum Binary Tree Maximum Width of Binary Tree Trim a Binary Search Tree Longest Univalue Path Employee Importance Insert into a Binary Search Tree Binary Tree Pruning Smallest Subtree with all the Deepest Nodes Flip Equivalent Binary Trees Check Completeness of a Binary Tree Vertical Order Traversal of a Binary Tree Smallest String Starting From Leaf Binary Search Tree to Greater Sum Tree Lowest Common Ancestor of Deepest Leaves Maximum Level Sum of a Binary Tree Deepest Leaves Sum All Elements in Two Binary Search Trees Sum of Nodes with Even-Valued Grandparent Delete Leaves With a Given Value Maximum Product of Splitted Binary Tree Linked List in Binary Tree Longest ZigZag Path in a Binary Tree Balance a Binary Search Tree Count Good Nodes in Binary Tree Even Odd Tree \u5251\u6307 Offer II 047. \u4e8c\u53c9\u6811\u526a\u679d \u5251\u6307 Offer II 049. \u4ece\u6839\u8282\u70b9\u5230\u53f6\u8282\u70b9\u7684\u8def\u5f84\u6570\u5b57\u4e4b\u548c \u5251\u6307 Offer II 050. \u5411\u4e0b\u7684\u8def\u5f84\u8282\u70b9\u4e4b\u548c \u5251\u6307 Offer II 054. \u6240\u6709\u5927\u4e8e\u7b49\u4e8e\u8282\u70b9\u7684\u503c\u4e4b\u548c \u5251\u6307 Offer II 055. \u4e8c\u53c9\u641c\u7d22\u6811\u8fed\u4ee3\u5668 \u9762\u8bd5\u9898 04.03. List of Depth LCCI \u9762\u8bd5\u9898 04.10. Check SubTree LCCI","title":"Lecture 3. Tree (62)"},{"location":"A.%20LeetCode/4.%20Problems/Lecture%202/#lecture-3-tree-62","text":"","title":"Lecture 3. Tree (62)"},{"location":"A.%20LeetCode/4.%20Problems/Lecture%202/#tree-traversal","text":"Binary Tree Level Order Traversal Binary Tree Zigzag Level Order Traversal Binary Tree Level Order Traversal II Path Sum II Problem Notes \u5251\u6307 Offer II 045. \u4e8c\u53c9\u6811\u6700\u5e95\u5c42\u6700\u5de6\u8fb9\u7684\u503c Recursion LC114. Flatten Binary Tree to Linked List Pre-order Traversal LC116. Populating Next Right Pointers in Each Node Level Traversal JZ045. \u5251\u6307 Offer II 045. \u4e8c\u53c9\u6811\u6700\u5e95\u5c42\u6700\u5de6\u8fb9\u7684\u503c (Medium) Info JZ045. \u5251\u6307 Offer II 045. \u4e8c\u53c9\u6811\u6700\u5e95\u5c42\u6700\u5de6\u8fb9\u7684\u503c (Medium) Algorithm: Two Pointers Time Complexity: \\(O(n)\\) Space Complexity: \\(O(n)\\) Solution Two Pointers. Same as LC209. Two Pointers \\(O(n)\\) Python 1 2 3 4 5 6 class Solution : def findBottomLeftValue ( self , root ): queue = [ root ] for node in queue : queue += filter ( None , ( node . right , node . left )) return node . val LC114. Flatten Binary Tree to Linked List (Medium) Info LC114. Flatten Binary Tree to Linked List (Medium) Algorithm: Binary Search Time Complexity: \\(O(\\log n)\\) Space Complexity: \\(O(1)\\) Solution Main Method O(n) Python 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 class Solution : def helper ( self , root : TreeNode ) -> List [ TreeNode ]: HEAD , TAIL = 0 , 1 # Base Case if not root : return [ None , None ] # DFS left = self . helper ( root . left ) right = self . helper ( root . right ) # Merge root . left = None newTail = root if left [ HEAD ]: root . right = left [ HEAD ] left [ TAIL ] . right = right [ HEAD ] newTail = left [ TAIL ] if right [ HEAD ]: newTail = right [ TAIL ] # Return return [ root , newTail ] # the first node and the last node of the linked list def flatten ( self , root : TreeNode ) -> None : \"\"\" Do not return anything, modify root in-place instead. \"\"\" self . helper ( root ) LC116. Populating Next Right Pointers in Each Node (Medium) Info LC116. Populating Next Right Pointers in Each Node (Medium) Algorithm: Binary Search Time Complexity: \\(O(\\log n)\\) Space Complexity: \\(O(1)\\) Solution Main Method O(n) Python 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 class Solution : def connect ( self , root : 'Node' ) -> 'Node' : if not root : return None Queue = [ root ] while Queue : levelQueue = [] for node in Queue : if node . left : levelQueue . append ( node . left ) if node . right : levelQueue . append ( node . right ) for i in range ( len ( levelQueue ) - 1 ): levelQueue [ i ] . next = levelQueue [ i + 1 ] Queue = levelQueue return root","title":"Tree Traversal"},{"location":"A.%20LeetCode/4.%20Problems/Lecture%202/#tree-validation","text":"Problem Notes 98. Validate Binary Search Tree Recursion Validate Binary Tree Nodes LC98. Validate Binary Search Tree (Medium) Info LC98. Validate Binary Search Tree (Medium) Algorithm: Recursion Time Complexity: \\(O(n)\\) Space Complexity: \\(O(n)\\) Solution Recursion. Recursion \\(O(n)\\) Python 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 # Definition for a binary tree node. # class TreeNode: # def __init__(self, val=0, left=None, right=None): # self.val = val # self.left = left # self.right = right class Solution : def helper ( self , root : TreeNode ) -> List [ int ]: if not root : return [ 1e16 , - 1e16 , True ] # min, max, isBST left = self . helper ( root . left ) right = self . helper ( root . right ) min_val = min ( root . val , left [ 0 ]) max_val = max ( root . val , right [ 1 ]) isBST = left [ 1 ] < root . val and right [ 0 ] > root . val and left [ 2 ] and right [ 2 ] return [ min_val , max_val , isBST ] def isValidBST ( self , root : TreeNode ) -> bool : ans = self . helper ( root ) return ans [ - 1 ]","title":"Tree Validation"},{"location":"A.%20LeetCode/4.%20Problems/Lecture%202/#tree-construction","text":"Construct Binary Tree from Preorder and Inorder Traversal Construct Binary Tree from Inorder and Postorder Traversal Convert Sorted List to Binary Search Tree Problem Notes 95. Unique Binary Search Trees II Recursion 96. Unique Binary Search Trees DP LC95. Unique Binary Search Trees II (Medium) Info LC95. Unique Binary Search Trees II (Medium) Algorithm: DP Time Complexity: \\(O(n)\\) Space Complexity: \\(O(n)\\) Solution Recursion. Recursion \\(O(n)\\) Python 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 class Solution : def __init__ ( self ): self . cache = dict () def tree ( self , i , j ) -> List [ TreeNode ]: if i > j : return [ None ] ans = [] for r in range ( i , j + 1 ): if ( i , r - 1 ) not in self . cache : self . cache [( i , r - 1 )] = self . tree ( i , r - 1 ) if ( r + 1 , j ) not in self . cache : self . cache [( r + 1 , j )] = self . tree ( r + 1 , j ) for left in self . cache [( i , r - 1 )]: for right in self . cache [( r + 1 , j )]: ans . append ( TreeNode ( r , left , right )) return ans def generateTrees ( self , n : int ) -> List [ TreeNode ]: return self . tree ( 1 , n ) LC96. Unique Binary Search Trees (Medium) Info LC96. Unique Binary Search Trees (Medium) Algorithm: DP Time Complexity: \\(O(n)\\) Space Complexity: \\(O(n)\\) Solution DP. Recursion \\(O(n)\\) Python 1 2 3 4 5 6 7 8 9 10 class Solution : def numTrees ( self , n : int ) -> int : DP = [ 0 ] * ( n + 1 ) DP [ 0 ], DP [ 1 ] = 1 , 1 for i in range ( 2 , n + 1 ): for j in range ( 1 , i + 1 ): DP [ i ] += DP [ j - 1 ] * DP [ i - j ] return DP [ - 1 ] Populating Next Right Pointers in Each Node II Binary Tree Maximum Path Sum Sum Root to Leaf Numbers Binary Search Tree Iterator Binary Tree Right Side View Count Complete Tree Nodes Kth Smallest Element in a BST Lowest Common Ancestor of a Binary Tree N-ary Tree Level Order Traversal Path Sum III Delete Node in a BST Most Frequent Subtree Sum Find Bottom Left Tree Value Find Largest Value in Each Tree Row Convert BST to Greater Tree Add One Row to Tree Maximum Binary Tree Maximum Width of Binary Tree Trim a Binary Search Tree Longest Univalue Path Employee Importance Insert into a Binary Search Tree Binary Tree Pruning Smallest Subtree with all the Deepest Nodes Flip Equivalent Binary Trees Check Completeness of a Binary Tree Vertical Order Traversal of a Binary Tree Smallest String Starting From Leaf Binary Search Tree to Greater Sum Tree Lowest Common Ancestor of Deepest Leaves Maximum Level Sum of a Binary Tree Deepest Leaves Sum All Elements in Two Binary Search Trees Sum of Nodes with Even-Valued Grandparent Delete Leaves With a Given Value Maximum Product of Splitted Binary Tree Linked List in Binary Tree Longest ZigZag Path in a Binary Tree Balance a Binary Search Tree Count Good Nodes in Binary Tree Even Odd Tree \u5251\u6307 Offer II 047. \u4e8c\u53c9\u6811\u526a\u679d \u5251\u6307 Offer II 049. \u4ece\u6839\u8282\u70b9\u5230\u53f6\u8282\u70b9\u7684\u8def\u5f84\u6570\u5b57\u4e4b\u548c \u5251\u6307 Offer II 050. \u5411\u4e0b\u7684\u8def\u5f84\u8282\u70b9\u4e4b\u548c \u5251\u6307 Offer II 054. \u6240\u6709\u5927\u4e8e\u7b49\u4e8e\u8282\u70b9\u7684\u503c\u4e4b\u548c \u5251\u6307 Offer II 055. \u4e8c\u53c9\u641c\u7d22\u6811\u8fed\u4ee3\u5668 \u9762\u8bd5\u9898 04.03. List of Depth LCCI \u9762\u8bd5\u9898 04.10. Check SubTree LCCI","title":"Tree Construction"},{"location":"A.%20LeetCode/4.%20Problems/Lecture%203/","text":"Lecture 3. String (50) Longest Substring Without Repeating Characters Longest Palindromic Substring ZigZag Conversion String to Integer (atoi) Letter Combinations of a Phone Number Generate Parentheses Longest Valid Parentheses Multiply Strings Group Anagrams Permutation Sequence Interleaving String Palindrome Partitioning Word Break Evaluate Reverse Polish Notation Reverse Words in a String Different Ways to Add Parentheses Maximum Product of Word Lengths Decode String Longest Substring with At Least K Repeating Characters Find All Anagrams in a String Ones and Zeroes Permutation in String Palindromic Substrings Top K Frequent Words Monotone Increasing Digits Partition Labels Letter Case Permutation Custom Sort String Masking Personal Information String Without AAA or BBB Smallest String Starting From Leaf Check If Word Is Valid After Substitutions Binary String With Substrings Representing 1 To N Robot Bounded In Circle Longest String Chain Compare Strings by Frequency of the Smallest Character Get Equal Substrings Within Budget Remove All Adjacent Duplicates in String II Replace the Substring for Balanced String Minimum Swaps to Make Strings Equal Minimum Remove to Make Valid Parentheses Break a Palindrome Simplified Fractions Number of Good Ways to Split a String Count Sorted Vowel Strings Unique Length-3 Palindromic Subsequences Largest Number After Mutating Substring Minimum Number of Swaps to Make the String Balanced Find Unique Binary String \u5251\u6307 Offer 67. \u628a\u5b57\u7b26\u4e32\u8f6c\u6362\u6210\u6574\u6570 LCOF","title":"Lecture 3. String (50)"},{"location":"A.%20LeetCode/4.%20Problems/Lecture%203/#lecture-3-string-50","text":"Longest Substring Without Repeating Characters Longest Palindromic Substring ZigZag Conversion String to Integer (atoi) Letter Combinations of a Phone Number Generate Parentheses Longest Valid Parentheses Multiply Strings Group Anagrams Permutation Sequence Interleaving String Palindrome Partitioning Word Break Evaluate Reverse Polish Notation Reverse Words in a String Different Ways to Add Parentheses Maximum Product of Word Lengths Decode String Longest Substring with At Least K Repeating Characters Find All Anagrams in a String Ones and Zeroes Permutation in String Palindromic Substrings Top K Frequent Words Monotone Increasing Digits Partition Labels Letter Case Permutation Custom Sort String Masking Personal Information String Without AAA or BBB Smallest String Starting From Leaf Check If Word Is Valid After Substitutions Binary String With Substrings Representing 1 To N Robot Bounded In Circle Longest String Chain Compare Strings by Frequency of the Smallest Character Get Equal Substrings Within Budget Remove All Adjacent Duplicates in String II Replace the Substring for Balanced String Minimum Swaps to Make Strings Equal Minimum Remove to Make Valid Parentheses Break a Palindrome Simplified Fractions Number of Good Ways to Split a String Count Sorted Vowel Strings Unique Length-3 Palindromic Subsequences Largest Number After Mutating Substring Minimum Number of Swaps to Make the String Balanced Find Unique Binary String \u5251\u6307 Offer 67. \u628a\u5b57\u7b26\u4e32\u8f6c\u6362\u6210\u6574\u6570 LCOF","title":"Lecture 3. String (50)"},{"location":"A.%20LeetCode/4.%20Problems/Lecture%204/","text":"Lecture 4. Array (81) Two Pointers Problem Notes LC11. Container With Most Water Two Pointers LC11. Container With Most Water (Medium) Info LC11. Container With Most Water (Medium) Algorithm: Two Pointers Time Complexity: \\(O(n)\\) Space Complexity: \\(O(1)\\) Solution Two Pointers. Two Pointers \\(O(n)\\) Python 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 class Solution : def maxArea ( self , height : List [ int ]) -> int : left , right = 0 , len ( height ) - 1 ans = 0 while ( left <= right ): area = ( right - left ) * min ( height [ left ], height [ right ]) if area > ans : ans = area if height [ left ] < height [ right ]: left += 1 else : right -= 1 return ans Two Pointers \\(O(n)\\) Python 1 Binary Search Problem Notes LC4. Median of Two Sorted Arrays Binary Search LC4. Median of Two Sorted Arrays (Medium) Info LC4. Median of Two Sorted Arrays (Medium) Algorithm: Binary Search Time Complexity: \\(O(\\log(n))\\) Space Complexity: \\(O(1)\\) Solution Binary Search. Binary Search \\(O(\\log(n))\\) Python 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 class Solution : def findMedianSortedArrays ( self , nums1 : List [ int ], nums2 : List [ int ]) -> float : L1 = len ( nums1 ) L2 = len ( nums2 ) if L1 == 1 and L2 == 0 : return nums1 [ 0 ] if L2 == 1 and L1 == 0 : return nums2 [ 0 ] if nums1 [ L1 // 2 ] <= nums2 [ L2 // 2 ]: return self . findMedianSortedArrays ( nums1 [ L1 // 2 :], nums2 [: L2 // 2 ]) else : return self . findMedianSortedArrays ( nums1 [: L1 // 2 ], nums2 [ L2 // 2 :]) Two Pointers \\(O(n)\\) Python 1 3Sum 4Sum Next Permutation Find First and Last Position of Element in Sorted Array Combination Sum Combination Sum II Trapping Rain Water Jump Game II Permutations Permutations II Jump Game Subsets Longest Consecutive Sequence Maximum Product Subarray Find Minimum in Rotated Sorted Array Find Minimum in Rotated Sorted Array II Find Peak Element Rotate Array Minimum Size Subarray Sum Kth Largest Element in an Array Contains Duplicate III Product of Array Except Self H-Index H-Index II Find the Duplicate Number Longest Increasing Subsequence Range Sum Query - Mutable Top K Frequent Elements Find K Pairs with Smallest Sums Combination Sum IV Partition Equal Subset Sum Maximum XOR of Two Numbers in an Array Find All Duplicates in an Array 4Sum II 132 Pattern Increasing Subsequences Target Sum Continuous Subarray Sum Subarray Sum Equals K Array Nesting Shortest Unsorted Continuous Subarray Non-decreasing Array Partition to K Equal Sum Subsets Subarray Product Less Than K Maximum Length of Repeated Subarray Number of Subarrays with Bounded Maximum Friends Of Appropriate Ages Keys and Rooms Shortest Subarray with Sum at Least K Koko Eating Bananas Sum of Subarray Minimums Sort an Array Binary Subarrays With Sum Minimum Increment to Make Array Unique Most Stones Removed with Same Row or Column Subarray Sums Divisible by K Longest Turbulent Subarray Sum of Even Numbers After Queries Capacity To Ship Packages Within D Days Maximum Sum of Two Non-Overlapping Subarrays Partition Array for Maximum Sum Distant Barcodes Find in Mountain Array Corporate Flight Bookings K-Concatenation Maximum Sum Count Number of Nice Subarrays Greatest Sum Divisible by Three Group the People Given the Group Size They Belong To Reduce Array Size to The Half Minimum Number of Days to Make m Bouquets Check If Array Pairs Are Divisible by k Number of Sub-arrays With Odd Sum Maximum Length of Subarray With Positive Product Furthest Building You Can Reach Max Number of K-Sum Pairs Minimum Elements to Add to Form a Given Sum Maximum Subarray Min-Product Find the Longest Valid Obstacle Course at Each Position Array With Elements Not Equal to Average of Neighbors","title":"Lecture 4. Array (81)"},{"location":"A.%20LeetCode/4.%20Problems/Lecture%204/#lecture-4-array-81","text":"","title":"Lecture 4. Array (81)"},{"location":"A.%20LeetCode/4.%20Problems/Lecture%204/#two-pointers","text":"Problem Notes LC11. Container With Most Water Two Pointers LC11. Container With Most Water (Medium) Info LC11. Container With Most Water (Medium) Algorithm: Two Pointers Time Complexity: \\(O(n)\\) Space Complexity: \\(O(1)\\) Solution Two Pointers. Two Pointers \\(O(n)\\) Python 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 class Solution : def maxArea ( self , height : List [ int ]) -> int : left , right = 0 , len ( height ) - 1 ans = 0 while ( left <= right ): area = ( right - left ) * min ( height [ left ], height [ right ]) if area > ans : ans = area if height [ left ] < height [ right ]: left += 1 else : right -= 1 return ans Two Pointers \\(O(n)\\) Python 1","title":"Two Pointers"},{"location":"A.%20LeetCode/4.%20Problems/Lecture%204/#binary-search","text":"Problem Notes LC4. Median of Two Sorted Arrays Binary Search LC4. Median of Two Sorted Arrays (Medium) Info LC4. Median of Two Sorted Arrays (Medium) Algorithm: Binary Search Time Complexity: \\(O(\\log(n))\\) Space Complexity: \\(O(1)\\) Solution Binary Search. Binary Search \\(O(\\log(n))\\) Python 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 class Solution : def findMedianSortedArrays ( self , nums1 : List [ int ], nums2 : List [ int ]) -> float : L1 = len ( nums1 ) L2 = len ( nums2 ) if L1 == 1 and L2 == 0 : return nums1 [ 0 ] if L2 == 1 and L1 == 0 : return nums2 [ 0 ] if nums1 [ L1 // 2 ] <= nums2 [ L2 // 2 ]: return self . findMedianSortedArrays ( nums1 [ L1 // 2 :], nums2 [: L2 // 2 ]) else : return self . findMedianSortedArrays ( nums1 [: L1 // 2 ], nums2 [ L2 // 2 :]) Two Pointers \\(O(n)\\) Python 1 3Sum 4Sum Next Permutation Find First and Last Position of Element in Sorted Array Combination Sum Combination Sum II Trapping Rain Water Jump Game II Permutations Permutations II Jump Game Subsets Longest Consecutive Sequence Maximum Product Subarray Find Minimum in Rotated Sorted Array Find Minimum in Rotated Sorted Array II Find Peak Element Rotate Array Minimum Size Subarray Sum Kth Largest Element in an Array Contains Duplicate III Product of Array Except Self H-Index H-Index II Find the Duplicate Number Longest Increasing Subsequence Range Sum Query - Mutable Top K Frequent Elements Find K Pairs with Smallest Sums Combination Sum IV Partition Equal Subset Sum Maximum XOR of Two Numbers in an Array Find All Duplicates in an Array 4Sum II 132 Pattern Increasing Subsequences Target Sum Continuous Subarray Sum Subarray Sum Equals K Array Nesting Shortest Unsorted Continuous Subarray Non-decreasing Array Partition to K Equal Sum Subsets Subarray Product Less Than K Maximum Length of Repeated Subarray Number of Subarrays with Bounded Maximum Friends Of Appropriate Ages Keys and Rooms Shortest Subarray with Sum at Least K Koko Eating Bananas Sum of Subarray Minimums Sort an Array Binary Subarrays With Sum Minimum Increment to Make Array Unique Most Stones Removed with Same Row or Column Subarray Sums Divisible by K Longest Turbulent Subarray Sum of Even Numbers After Queries Capacity To Ship Packages Within D Days Maximum Sum of Two Non-Overlapping Subarrays Partition Array for Maximum Sum Distant Barcodes Find in Mountain Array Corporate Flight Bookings K-Concatenation Maximum Sum Count Number of Nice Subarrays Greatest Sum Divisible by Three Group the People Given the Group Size They Belong To Reduce Array Size to The Half Minimum Number of Days to Make m Bouquets Check If Array Pairs Are Divisible by k Number of Sub-arrays With Odd Sum Maximum Length of Subarray With Positive Product Furthest Building You Can Reach Max Number of K-Sum Pairs Minimum Elements to Add to Form a Given Sum Maximum Subarray Min-Product Find the Longest Valid Obstacle Course at Each Position Array With Elements Not Equal to Average of Neighbors","title":"Binary Search"},{"location":"A.%20LeetCode/4.%20Problems/Lecture%205/","text":"Lecture 5. Grid (15) Valid Sudoku Rotate Image Unique Paths Minimum Path Sum Set Matrix Zeroes Search a 2D Matrix Sort Colors Maximal Rectangle Maximal Square Search a 2D Matrix II 01 Matrix Magic Squares In Grid Regions Cut By Slashes Find Kth Largest XOR Coordinate Value Rotating the Box","title":"Lecture 5. Grid (15)"},{"location":"A.%20LeetCode/4.%20Problems/Lecture%205/#lecture-5-grid-15","text":"Valid Sudoku Rotate Image Unique Paths Minimum Path Sum Set Matrix Zeroes Search a 2D Matrix Sort Colors Maximal Rectangle Maximal Square Search a 2D Matrix II 01 Matrix Magic Squares In Grid Regions Cut By Slashes Find Kth Largest XOR Coordinate Value Rotating the Box","title":"Lecture 5. Grid (15)"},{"location":"A.%20LeetCode/4.%20Problems/Lecture%206/","text":"Lecture 6. Graph (5) All Paths From Source to Target Two City Scheduling Coloring A Border \u5251\u6307 Offer II 106. \u4e8c\u5206\u56fe \u9762\u8bd5\u9898 04.01. Route Between Nodes LCCI","title":"Lecture 6. Graph (5)"},{"location":"A.%20LeetCode/4.%20Problems/Lecture%206/#lecture-6-graph-5","text":"All Paths From Source to Target Two City Scheduling Coloring A Border \u5251\u6307 Offer II 106. \u4e8c\u5206\u56fe \u9762\u8bd5\u9898 04.01. Route Between Nodes LCCI","title":"Lecture 6. Graph (5)"},{"location":"A.%20LeetCode/4.%20Problems/Lecture%207/","text":"Lecture 7. Math (22) Pow(x, n) Gas Station Factorial Trailing Zeroes Rectangle Area H-Index H-Index II Perfect Squares Integer Break Water and Jug Problem Sum of Two Integers Complex Number Multiplication Sum of Square Numbers 2 Keys Keyboard Smallest Range II Beautiful Array Broken Calculator Find Positive Integer Solution for a Given Equation The kth Factor of n Check if Number is a Sum of Powers of Three Find the Winner of the Circular Game Maximum Matrix Sum Vowels of All Substrings \u5251\u6307 Offer 64. \u6c421+2+\u2026+n","title":"Lecture 7. Math (22)"},{"location":"A.%20LeetCode/4.%20Problems/Lecture%207/#lecture-7-math-22","text":"Pow(x, n) Gas Station Factorial Trailing Zeroes Rectangle Area H-Index H-Index II Perfect Squares Integer Break Water and Jug Problem Sum of Two Integers Complex Number Multiplication Sum of Square Numbers 2 Keys Keyboard Smallest Range II Beautiful Array Broken Calculator Find Positive Integer Solution for a Given Equation The kth Factor of n Check if Number is a Sum of Powers of Three Find the Winner of the Circular Game Maximum Matrix Sum Vowels of All Substrings \u5251\u6307 Offer 64. \u6c421+2+\u2026+n","title":"Lecture 7. Math (22)"},{"location":"A.%20LeetCode/4.%20Problems/Missing%20Number/","text":"Missing Number (8) Related Problems ID Title Difficulty LC136 Single Number Easy LC268 Missing Number Easy LC287 Find the Duplicate Number Medium LC41 First Missing Positive Hard LC765 Couples Holding Hands Hard LC1539 Kth Missing Positive Number Easy LCCI1704 \u9762\u8bd5\u9898 17.04. Missing Number LCCI Easy LCCI1719 \u9762\u8bd5\u9898 17.19. Missing Two LCCI Hard","title":"Missing Number (8)"},{"location":"A.%20LeetCode/4.%20Problems/Missing%20Number/#missing-number-8","text":"","title":"Missing Number (8)"},{"location":"A.%20LeetCode/4.%20Problems/Missing%20Number/#related-problems","text":"ID Title Difficulty LC136 Single Number Easy LC268 Missing Number Easy LC287 Find the Duplicate Number Medium LC41 First Missing Positive Hard LC765 Couples Holding Hands Hard LC1539 Kth Missing Positive Number Easy LCCI1704 \u9762\u8bd5\u9898 17.04. Missing Number LCCI Easy LCCI1719 \u9762\u8bd5\u9898 17.19. Missing Two LCCI Hard","title":"Related Problems"},{"location":"A.%20LeetCode/4.%20Problems/Path%20Sum/","text":"Path Sum (3) Related Problems Problem Type LC112. Path Sum LC113. Path Sum II LC437. Path Sum III","title":"Path Sum (3)"},{"location":"A.%20LeetCode/4.%20Problems/Path%20Sum/#path-sum-3","text":"","title":"Path Sum (3)"},{"location":"A.%20LeetCode/4.%20Problems/Path%20Sum/#related-problems","text":"Problem Type LC112. Path Sum LC113. Path Sum II LC437. Path Sum III","title":"Related Problems"},{"location":"A.%20LeetCode/4.%20Problems/Range%20Query/","text":"Range Query Problem Notes 303. Range Sum Query - Immutable Presum LC303. Range Sum Query - Immutable (Easy) Info LC303. Range Sum Query - Immutable (Easy) Algorithm: Presum Time Complexity: \\(O(n)\\) Space Complexity: \\(O(n)\\) Solution Presum. Presum \\(O(n)\\) Python 1 2 3 4 5 6 7 8 9 10 11 12 class NumArray : def __init__ ( self , nums : List [ int ]): self . nums = nums if nums : self . preSum = [ nums [ 0 ]] * len ( nums ) # add one more in front for i in range ( 1 , len ( nums )): self . preSum [ i ] = self . preSum [ i - 1 ] + nums [ i ] def sumRange ( self , i : int , j : int ) -> int : return self . preSum [ j ] - self . preSum [ i ] + self . nums [ i ]","title":"Range Query"},{"location":"A.%20LeetCode/4.%20Problems/Range%20Query/#range-query","text":"Problem Notes 303. Range Sum Query - Immutable Presum LC303. Range Sum Query - Immutable (Easy) Info LC303. Range Sum Query - Immutable (Easy) Algorithm: Presum Time Complexity: \\(O(n)\\) Space Complexity: \\(O(n)\\) Solution Presum. Presum \\(O(n)\\) Python 1 2 3 4 5 6 7 8 9 10 11 12 class NumArray : def __init__ ( self , nums : List [ int ]): self . nums = nums if nums : self . preSum = [ nums [ 0 ]] * len ( nums ) # add one more in front for i in range ( 1 , len ( nums )): self . preSum [ i ] = self . preSum [ i - 1 ] + nums [ i ] def sumRange ( self , i : int , j : int ) -> int : return self . preSum [ j ] - self . preSum [ i ] + self . nums [ i ]","title":"Range Query"},{"location":"A.%20LeetCode/4.%20Problems/Stone%20Game/","text":"Stone Game (8) Related Problems Problem Type LC877. Stone Game LC1140. Stone Game II LC1406. Stone Game III LC1510. Stone Game IV LC1563. Stone Game V LC1686. Stone Game VI LC1690. Stone Game VII LC1872. Stone Game VIII","title":"Stone Game (8)"},{"location":"A.%20LeetCode/4.%20Problems/Stone%20Game/#stone-game-8","text":"","title":"Stone Game (8)"},{"location":"A.%20LeetCode/4.%20Problems/Stone%20Game/#related-problems","text":"Problem Type LC877. Stone Game LC1140. Stone Game II LC1406. Stone Game III LC1510. Stone Game IV LC1563. Stone Game V LC1686. Stone Game VI LC1690. Stone Game VII LC1872. Stone Game VIII","title":"Related Problems"},{"location":"A.%20LeetCode/4.%20Problems/Top250/","text":"Top 300 Linked List Tricks When dealing with Linked list, use a new pointer that points to the real head. Problem Notes 2. Add Two Numbers Create a pointer that points to the real head. LC2. Add Two Numbers (Medium) Info LC2. Add Two Numbers (Medium) Algorithm: Linked List Time Complexity: \\(O(n)\\) Space Complexity: \\(O(1)\\) Solution Linked List. The trick is the create a pointer that points to the real head. Linked List \\(O(n)\\) Python 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 class Solution : def addTwoNumbers ( self , l1 : ListNode , l2 : ListNode ) -> ListNode : p1 = ListNode () p2 = ListNode () p1 . next = l1 p2 . next = l2 carry = 0 while p1 . next or p2 . next : if not p1 . next : p1 . next = ListNode () if not p2 . next : p2 . next = ListNode () s = p1 . next . val + p2 . next . val + carry p1 . next . val = s % 10 carry = s // 10 p1 = p1 . next p2 = p2 . next if carry : p1 . next = ListNode ( carry ) return l1 DP Problem Notes 3. Longest Substring Without Repeating Characters Lastseen hashmap. Also two pointers. LC3. Longest Substring Without Repeating Characters (Medium) Info LC3. Longest Substring Without Repeating Characters (Medium) Algorithm: DP Time Complexity: \\(O(n)\\) Space Complexity: \\(O(1)\\) Solution DP or Two Pointers. DP \\(O(n)\\) Python 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 from collections import defaultdict class Solution : def lengthOfLongestSubstring ( self , s : str ) -> int : lastSeen = defaultdict ( int ) longestDist = 0 ans = 0 for i , ch in enumerate ( s ): longestDist += 1 if ch in lastSeen : longestDist = min ( longestDist , i - lastSeen [ ch ]) lastSeen [ ch ] = i ans = max ( ans , longestDist ) return ans Two Pointers \\(O(n)\\) Python 1 Two Pointers Deque is a special case of two pointers. Problem Notes 3. Longest Substring Without Repeating Characters Lastseen hashmap. Also DP. LC3. Longest Substring Without Repeating Characters (Medium) Info LC3. Longest Substring Without Repeating Characters (Medium) Algorithm: DP Time Complexity: \\(O(n)\\) Space Complexity: \\(O(1)\\) Solution DP or Two Pointers. DP \\(O(n)\\) Python 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 from collections import defaultdict class Solution : def lengthOfLongestSubstring ( self , s : str ) -> int : lastSeen = defaultdict ( int ) longestDist = 0 ans = 0 for i , ch in enumerate ( s ): longestDist += 1 if ch in lastSeen : longestDist = min ( longestDist , i - lastSeen [ ch ]) lastSeen [ ch ] = i ans = max ( ans , longestDist ) return ans Two Pointers \\(O(n)\\) Python 1 Range Query Pointer Query No Update: Array Point Update: Array Range Update: Range Query No Update: Presum Point Update: BIT\uff08Binary Index Tree\uff1b\u7528\u7ebf\u6bb5\u6811\u7406\u89e3\u6811\u72b6\u6570\u7ec4 \u2014\u2014 \u780d\u6389\u4e00\u534a\u7684\u7ebf\u6bb5\u6811\uff1b\u51e1\u662f\u6811\u72b6\u6570\u7ec4\u53ef\u4ee5\u89e3\u51b3\u7684\u95ee\u9898\uff0c\u7ebf\u6bb5\u6811\u90fd\u53ef\u4ee5\u89e3\u51b3\uff0c\u53cd\u8fc7\u6765\u4e0d\u4e00\u5b9a\uff09\u3002 Range Update: Difference Array Problem Notes 303. Range Sum Query - Immutable Range Query. Presum \\(O(n)\\) LC303. Range Sum Query - Immutable (Easy) Info LC303. Range Sum Query - Immutable (Easy) Algorithm: Presum Time Complexity: \\(O(n)\\) Space Complexity: \\(O(n)\\) Solution Presum. Presum \\(O(n)\\) Python 1 2 3 4 5 6 7 8 9 10 11 12 class NumArray : def __init__ ( self , nums : List [ int ]): self . nums = nums if nums : self . preSum = [ nums [ 0 ]] * len ( nums ) # add one more in front for i in range ( 1 , len ( nums )): self . preSum [ i ] = self . preSum [ i - 1 ] + nums [ i ] def sumRange ( self , i : int , j : int ) -> int : return self . preSum [ j ] - self . preSum [ i ] + self . nums [ i ] Greedy Problem Notes 984. String Without AAA or BBB LC984. String Without AAA or BBB (Medium) Info LC984. String Without AAA or BBB (Medium) Algorithm: Greedy Time Complexity: \\(O(n)\\) Space Complexity: \\(O(1)\\) Solution Greedy. Greedy \\(O(n)\\) Python 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 class Solution : def strWithout3a3b ( self , a : int , b : int ) -> str : if a > b : ans = \"a\" a -= 1 else : ans = \"b\" b -= 1 while a > 0 or b > 0 : if a > b : if not ( len ( ans ) >= 2 and ans [ - 1 ] == ans [ - 2 ] == 'a' ): ans += 'a' a -= 1 else : ans += 'b' b -= 1 else : if not ( len ( ans ) >= 2 and ans [ - 1 ] == ans [ - 2 ] == 'b' ): ans += 'b' b -= 1 else : ans += 'a' a -= 1 return ans","title":"Top 300"},{"location":"A.%20LeetCode/4.%20Problems/Top250/#top-300","text":"","title":"Top 300"},{"location":"A.%20LeetCode/4.%20Problems/Top250/#linked-list","text":"","title":"Linked List"},{"location":"A.%20LeetCode/4.%20Problems/Top250/#tricks","text":"When dealing with Linked list, use a new pointer that points to the real head. Problem Notes 2. Add Two Numbers Create a pointer that points to the real head. LC2. Add Two Numbers (Medium) Info LC2. Add Two Numbers (Medium) Algorithm: Linked List Time Complexity: \\(O(n)\\) Space Complexity: \\(O(1)\\) Solution Linked List. The trick is the create a pointer that points to the real head. Linked List \\(O(n)\\) Python 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 class Solution : def addTwoNumbers ( self , l1 : ListNode , l2 : ListNode ) -> ListNode : p1 = ListNode () p2 = ListNode () p1 . next = l1 p2 . next = l2 carry = 0 while p1 . next or p2 . next : if not p1 . next : p1 . next = ListNode () if not p2 . next : p2 . next = ListNode () s = p1 . next . val + p2 . next . val + carry p1 . next . val = s % 10 carry = s // 10 p1 = p1 . next p2 = p2 . next if carry : p1 . next = ListNode ( carry ) return l1","title":"Tricks"},{"location":"A.%20LeetCode/4.%20Problems/Top250/#dp","text":"Problem Notes 3. Longest Substring Without Repeating Characters Lastseen hashmap. Also two pointers. LC3. Longest Substring Without Repeating Characters (Medium) Info LC3. Longest Substring Without Repeating Characters (Medium) Algorithm: DP Time Complexity: \\(O(n)\\) Space Complexity: \\(O(1)\\) Solution DP or Two Pointers. DP \\(O(n)\\) Python 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 from collections import defaultdict class Solution : def lengthOfLongestSubstring ( self , s : str ) -> int : lastSeen = defaultdict ( int ) longestDist = 0 ans = 0 for i , ch in enumerate ( s ): longestDist += 1 if ch in lastSeen : longestDist = min ( longestDist , i - lastSeen [ ch ]) lastSeen [ ch ] = i ans = max ( ans , longestDist ) return ans Two Pointers \\(O(n)\\) Python 1","title":"DP"},{"location":"A.%20LeetCode/4.%20Problems/Top250/#two-pointers","text":"Deque is a special case of two pointers. Problem Notes 3. Longest Substring Without Repeating Characters Lastseen hashmap. Also DP. LC3. Longest Substring Without Repeating Characters (Medium) Info LC3. Longest Substring Without Repeating Characters (Medium) Algorithm: DP Time Complexity: \\(O(n)\\) Space Complexity: \\(O(1)\\) Solution DP or Two Pointers. DP \\(O(n)\\) Python 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 from collections import defaultdict class Solution : def lengthOfLongestSubstring ( self , s : str ) -> int : lastSeen = defaultdict ( int ) longestDist = 0 ans = 0 for i , ch in enumerate ( s ): longestDist += 1 if ch in lastSeen : longestDist = min ( longestDist , i - lastSeen [ ch ]) lastSeen [ ch ] = i ans = max ( ans , longestDist ) return ans Two Pointers \\(O(n)\\) Python 1","title":"Two Pointers"},{"location":"A.%20LeetCode/4.%20Problems/Top250/#range-query","text":"Pointer Query No Update: Array Point Update: Array Range Update: Range Query No Update: Presum Point Update: BIT\uff08Binary Index Tree\uff1b\u7528\u7ebf\u6bb5\u6811\u7406\u89e3\u6811\u72b6\u6570\u7ec4 \u2014\u2014 \u780d\u6389\u4e00\u534a\u7684\u7ebf\u6bb5\u6811\uff1b\u51e1\u662f\u6811\u72b6\u6570\u7ec4\u53ef\u4ee5\u89e3\u51b3\u7684\u95ee\u9898\uff0c\u7ebf\u6bb5\u6811\u90fd\u53ef\u4ee5\u89e3\u51b3\uff0c\u53cd\u8fc7\u6765\u4e0d\u4e00\u5b9a\uff09\u3002 Range Update: Difference Array Problem Notes 303. Range Sum Query - Immutable Range Query. Presum \\(O(n)\\) LC303. Range Sum Query - Immutable (Easy) Info LC303. Range Sum Query - Immutable (Easy) Algorithm: Presum Time Complexity: \\(O(n)\\) Space Complexity: \\(O(n)\\) Solution Presum. Presum \\(O(n)\\) Python 1 2 3 4 5 6 7 8 9 10 11 12 class NumArray : def __init__ ( self , nums : List [ int ]): self . nums = nums if nums : self . preSum = [ nums [ 0 ]] * len ( nums ) # add one more in front for i in range ( 1 , len ( nums )): self . preSum [ i ] = self . preSum [ i - 1 ] + nums [ i ] def sumRange ( self , i : int , j : int ) -> int : return self . preSum [ j ] - self . preSum [ i ] + self . nums [ i ]","title":"Range Query"},{"location":"A.%20LeetCode/4.%20Problems/Top250/#greedy","text":"Problem Notes 984. String Without AAA or BBB LC984. String Without AAA or BBB (Medium) Info LC984. String Without AAA or BBB (Medium) Algorithm: Greedy Time Complexity: \\(O(n)\\) Space Complexity: \\(O(1)\\) Solution Greedy. Greedy \\(O(n)\\) Python 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 class Solution : def strWithout3a3b ( self , a : int , b : int ) -> str : if a > b : ans = \"a\" a -= 1 else : ans = \"b\" b -= 1 while a > 0 or b > 0 : if a > b : if not ( len ( ans ) >= 2 and ans [ - 1 ] == ans [ - 2 ] == 'a' ): ans += 'a' a -= 1 else : ans += 'b' b -= 1 else : if not ( len ( ans ) >= 2 and ans [ - 1 ] == ans [ - 2 ] == 'b' ): ans += 'b' b -= 1 else : ans += 'a' a -= 1 return ans","title":"Greedy"},{"location":"A.%20LeetCode/4.%20Problems/Two%20Sum/","text":"Two Sum (7) Related Problems Problem Type LC1. Two Sum LC167. Two Sum II - Input array is sorted LC454. 4Sum II LC653. Two Sum IV - Input is a BST LC15. 3Sum LC16. 3Sum Closest LC18. 4Sum","title":"Two Sum (7)"},{"location":"A.%20LeetCode/4.%20Problems/Two%20Sum/#two-sum-7","text":"","title":"Two Sum (7)"},{"location":"A.%20LeetCode/4.%20Problems/Two%20Sum/#related-problems","text":"Problem Type LC1. Two Sum LC167. Two Sum II - Input array is sorted LC454. 4Sum II LC653. Two Sum IV - Input is a BST LC15. 3Sum LC16. 3Sum Closest LC18. 4Sum","title":"Related Problems"},{"location":"A.%20LeetCode/4.%20Problems/Array%20and%20String/Best%20Time%20to%20Buy%20and%20Sell%20Stock/","text":"Best Time to Buy and Sell Stock (5) Introduction Related Problems Problem Type LC121. Best Time to Buy and Sell Stock LC122. Best Time to Buy and Sell Stock II LC123. Best Time to Buy and Sell Stock III LC188. Best Time to Buy and Sell Stock IV LC309. Best Time to Buy and Sell Stock with Cooldown","title":"Best Time to Buy and Sell Stock (5)"},{"location":"A.%20LeetCode/4.%20Problems/Array%20and%20String/Best%20Time%20to%20Buy%20and%20Sell%20Stock/#best-time-to-buy-and-sell-stock-5","text":"","title":"Best Time to Buy and Sell Stock (5)"},{"location":"A.%20LeetCode/4.%20Problems/Array%20and%20String/Best%20Time%20to%20Buy%20and%20Sell%20Stock/#introduction","text":"","title":"Introduction"},{"location":"A.%20LeetCode/4.%20Problems/Array%20and%20String/Best%20Time%20to%20Buy%20and%20Sell%20Stock/#related-problems","text":"Problem Type LC121. Best Time to Buy and Sell Stock LC122. Best Time to Buy and Sell Stock II LC123. Best Time to Buy and Sell Stock III LC188. Best Time to Buy and Sell Stock IV LC309. Best Time to Buy and Sell Stock with Cooldown","title":"Related Problems"},{"location":"A.%20LeetCode/4.%20Problems/Array%20and%20String/Conversion/","text":"Conversion DP Problem Type Info Data Structure Algorithm LC1208. Get Equal Substrings Within Budget","title":"Conversion"},{"location":"A.%20LeetCode/4.%20Problems/Array%20and%20String/Conversion/#conversion","text":"DP Problem Type Info Data Structure Algorithm LC1208. Get Equal Substrings Within Budget","title":"Conversion"},{"location":"A.%20LeetCode/4.%20Problems/Array%20and%20String/Knapsack/","text":"Knapsack (7) Introduction Related Problems Problem Type LC322. Coin Change LC416. Partition Equal Subset Sum LC494. Target Sum LC377. Combination Sum IV LC518. Coin Change 2 LC1049. Last Stone Weight II LC1155. Number of Dice Rolls With Target Sum LC322. Coin Change (Medium) Info LC322. Coin Change (Medium) Algorithm: DP Time Complexity: \\(O(n)\\) Space Complexity: \\(O(1)\\) Solution DP. DP \\(O(n)\\) Python 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 class Solution : @cache def helper ( self , amount ) -> int : if amount == 0 : return 0 if amount in sortedCoins : return 1 if amount < sortedCoins [ - 1 ]: return 1e16 ans = 1e16 for c in sortedCoins : if amount - c <= 0 : # the coin is too much continue if amount // c >= ans : # the coin is too small, no better than the current best ans break ans = min ( ans , self . helper ( amount - c ) + 1 ) # Python 3.9+, functools.cache return ans def coinChange ( self , coins : List [ int ], amount : int ) -> int : global sortedCoins sortedCoins = sorted ( coins , reverse = True ) ans = self . helper ( amount ) return ans if ans < 1e16 else - 1","title":"Knapsack (7)"},{"location":"A.%20LeetCode/4.%20Problems/Array%20and%20String/Knapsack/#knapsack-7","text":"","title":"Knapsack (7)"},{"location":"A.%20LeetCode/4.%20Problems/Array%20and%20String/Knapsack/#introduction","text":"","title":"Introduction"},{"location":"A.%20LeetCode/4.%20Problems/Array%20and%20String/Knapsack/#related-problems","text":"Problem Type LC322. Coin Change LC416. Partition Equal Subset Sum LC494. Target Sum LC377. Combination Sum IV LC518. Coin Change 2 LC1049. Last Stone Weight II LC1155. Number of Dice Rolls With Target Sum LC322. Coin Change (Medium) Info LC322. Coin Change (Medium) Algorithm: DP Time Complexity: \\(O(n)\\) Space Complexity: \\(O(1)\\) Solution DP. DP \\(O(n)\\) Python 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 class Solution : @cache def helper ( self , amount ) -> int : if amount == 0 : return 0 if amount in sortedCoins : return 1 if amount < sortedCoins [ - 1 ]: return 1e16 ans = 1e16 for c in sortedCoins : if amount - c <= 0 : # the coin is too much continue if amount // c >= ans : # the coin is too small, no better than the current best ans break ans = min ( ans , self . helper ( amount - c ) + 1 ) # Python 3.9+, functools.cache return ans def coinChange ( self , coins : List [ int ], amount : int ) -> int : global sortedCoins sortedCoins = sorted ( coins , reverse = True ) ans = self . helper ( amount ) return ans if ans < 1e16 else - 1","title":"Related Problems"},{"location":"A.%20LeetCode/4.%20Problems/Array%20and%20String/Pattern%20Matching/","text":"","title":"Pattern Matching"},{"location":"A.%20LeetCode/4.%20Problems/Array%20and%20String/Presum%20and%20Difference%20Array/","text":"= PreSum \u57fa\u7840\u77e5\u8bc6\uff1a\u524d\u7f00\u548c\u672c\u8d28\u4e0a\u662f\u5728\u4e00\u4e2alist\u5f53\u4e2d\uff0c\u7528O\uff08N\uff09\u7684\u65f6\u95f4\u63d0\u524d\u7b97\u597d\u4ece\u7b2c0\u4e2a\u6570\u5b57\u5230\u7b2ci\u4e2a\u6570\u5b57\u4e4b\u548c\uff0c\u5728\u540e\u7eed\u4f7f\u7528\u4e2d\u53ef\u4ee5\u5728O\uff081\uff09\u65f6\u95f4\u5185\u8ba1\u7b97\u51fa\u7b2ci\u5230\u7b2cj\u4e2a\u6570\u5b57\u4e4b\u548c\uff0c\u4e00\u822c\u5f88\u5c11\u5355\u72ec\u4f5c\u4e3a\u4e00\u9053\u9898\u51fa\u73b0\uff0c\u800c\u662f\u5f88\u591a\u9898\u76ee\u4e2d\u7684\u7528\u5230\u7684\u4e00\u4e2a\u5c0f\u6280\u5de7 \u5e38\u89c1\u9898\u76ee\uff1a - Leetcode 53 Maximum Subarray - Leetcode 1423 Maximum Points You Can Obtain from Cards - Leetcode 1031 Maximum Sum of Two Non-Overlapping Subarrays - Leetcode 523 Continuous Subarray Sum","title":"Presum and Difference Array"},{"location":"A.%20LeetCode/4.%20Problems/Array%20and%20String/Shortest%20Subarray%20with%20Sum%20at%20Least%20K/","text":"Shortest Subarray with Sum at Least K Related Problems ID Title Difficulty LC209 Minimum Size Subarray Sum Medium LC1208 Get Equal Substrings Within Budget Medium JZ008 \u5251\u6307 Offer II 008. \u548c\u5927\u4e8e\u7b49\u4e8e target \u7684\u6700\u77ed\u5b50\u6570\u7ec4 Medium LC862 Shortest Subarray with Sum at Least K Hard LC209. Minimum Size Subarray Sum (Medium) Info 209. Minimum Size Subarray Sum (Medium) Algorithm: Two Pointers Time Complexity: \\(O(n)\\) Space Complexity: \\(O(1)\\) Solution Two Pointers. Two Pointers \\(O(n)\\) Python 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 class Solution : def minSubArrayLen ( self , target : int , nums : List [ int ]) -> int : L = len ( nums ) presum = [ 0 ] * ( L + 1 ) for i in range ( 1 , L + 1 ): presum [ i ] = presum [ i - 1 ] + nums [ i - 1 ] left , right = 0 , 1 ans = 1e16 while right <= L : if presum [ right ] - presum [ left ] >= target : ans = min ( ans , right - left ) left += 1 else : right += 1 return ans if ans < 1e16 else 0 1208. Get Equal Substrings Within Budget (Medium) Info 1208. Get Equal Substrings Within Budget (Medium) Algorithm: Two Pointers Time Complexity: \\(O(n)\\) Space Complexity: \\(O(1)\\) Solution Two Pointers. Two Pointers \\(O(n)\\) Python 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 class Solution : def equalSubstring ( self , s : str , t : str , maxCost : int ) -> int : L = len ( s ) preSum = [ 0 ] * ( L + 1 ) for i in range ( 1 , L + 1 ): preSum [ i ] += preSum [ i - 1 ] + abs ( ord ( s [ i - 1 ]) - ord ( t [ i - 1 ])) left , right = 0 , 1 ans = 0 while right <= L : if preSum [ right ] - preSum [ left ] <= maxCost : ans = max ( ans , right - left ) right += 1 else : left += 1 return ans JZ008. \u5251\u6307 Offer II 008. \u548c\u5927\u4e8e\u7b49\u4e8e target \u7684\u6700\u77ed\u5b50\u6570\u7ec4 (Medium) Info JZ008. \u5251\u6307 Offer II 008. \u548c\u5927\u4e8e\u7b49\u4e8e target \u7684\u6700\u77ed\u5b50\u6570\u7ec4 (Medium) Algorithm: Two Pointers Time Complexity: \\(O(n)\\) Space Complexity: \\(O(n)\\) Solution Two Pointers. Same as LC209. Two Pointers \\(O(n)\\) Python 1 class Solution: def minSubArrayLen(self, s: int, nums: List[int]) -> int: if(not nums): return 0 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 if(len(nums) == 1): return int(nums[0] == s) left, right, total, m = 0, 0, nums[0], 1e16 while(left <= right): if(total < s): if(right < len(nums) - 1): right += 1 total += nums[right] else: break else: m = min(m, right - left + 1) #print(total, left, right, right - left + 1) total -= nums[left] left += 1 return m if(m < 1e16) else 0 862. Shortest Subarray with Sum at Least K (Hard) Info 862. Shortest Subarray with Sum at Least K (Hard) Algorithm: Deque Time Complexity: \\(O(n)\\) Space Complexity: \\(O(1)\\) Solution Deque. Deque \\(O(n)\\) Python 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 class Solution : def shortestSubarray ( self , nums : List [ int ], k : int ) -> int : IDX , VAL = 0 , 1 ans = 1e16 preSum = 0 deque = collections . deque ([( - 1 , 0 )]) for i in range ( len ( nums )): preSum += nums [ i ] while deque and preSum - deque [ 0 ][ VAL ] >= k : ans = min ( ans , i - deque . popleft ()[ IDX ]) while deque and preSum <= deque [ - 1 ][ VAL ]: deque . pop () deque . append (( i , preSum )) return ans if ans < 1e16 else - 1","title":"Shortest Subarray with Sum at Least K"},{"location":"A.%20LeetCode/4.%20Problems/Array%20and%20String/Shortest%20Subarray%20with%20Sum%20at%20Least%20K/#shortest-subarray-with-sum-at-least-k","text":"","title":"Shortest Subarray with Sum at Least K"},{"location":"A.%20LeetCode/4.%20Problems/Array%20and%20String/Shortest%20Subarray%20with%20Sum%20at%20Least%20K/#related-problems","text":"ID Title Difficulty LC209 Minimum Size Subarray Sum Medium LC1208 Get Equal Substrings Within Budget Medium JZ008 \u5251\u6307 Offer II 008. \u548c\u5927\u4e8e\u7b49\u4e8e target \u7684\u6700\u77ed\u5b50\u6570\u7ec4 Medium LC862 Shortest Subarray with Sum at Least K Hard LC209. Minimum Size Subarray Sum (Medium) Info 209. Minimum Size Subarray Sum (Medium) Algorithm: Two Pointers Time Complexity: \\(O(n)\\) Space Complexity: \\(O(1)\\) Solution Two Pointers. Two Pointers \\(O(n)\\) Python 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 class Solution : def minSubArrayLen ( self , target : int , nums : List [ int ]) -> int : L = len ( nums ) presum = [ 0 ] * ( L + 1 ) for i in range ( 1 , L + 1 ): presum [ i ] = presum [ i - 1 ] + nums [ i - 1 ] left , right = 0 , 1 ans = 1e16 while right <= L : if presum [ right ] - presum [ left ] >= target : ans = min ( ans , right - left ) left += 1 else : right += 1 return ans if ans < 1e16 else 0 1208. Get Equal Substrings Within Budget (Medium) Info 1208. Get Equal Substrings Within Budget (Medium) Algorithm: Two Pointers Time Complexity: \\(O(n)\\) Space Complexity: \\(O(1)\\) Solution Two Pointers. Two Pointers \\(O(n)\\) Python 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 class Solution : def equalSubstring ( self , s : str , t : str , maxCost : int ) -> int : L = len ( s ) preSum = [ 0 ] * ( L + 1 ) for i in range ( 1 , L + 1 ): preSum [ i ] += preSum [ i - 1 ] + abs ( ord ( s [ i - 1 ]) - ord ( t [ i - 1 ])) left , right = 0 , 1 ans = 0 while right <= L : if preSum [ right ] - preSum [ left ] <= maxCost : ans = max ( ans , right - left ) right += 1 else : left += 1 return ans JZ008. \u5251\u6307 Offer II 008. \u548c\u5927\u4e8e\u7b49\u4e8e target \u7684\u6700\u77ed\u5b50\u6570\u7ec4 (Medium) Info JZ008. \u5251\u6307 Offer II 008. \u548c\u5927\u4e8e\u7b49\u4e8e target \u7684\u6700\u77ed\u5b50\u6570\u7ec4 (Medium) Algorithm: Two Pointers Time Complexity: \\(O(n)\\) Space Complexity: \\(O(n)\\) Solution Two Pointers. Same as LC209. Two Pointers \\(O(n)\\) Python 1 class Solution: def minSubArrayLen(self, s: int, nums: List[int]) -> int: if(not nums): return 0 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 if(len(nums) == 1): return int(nums[0] == s) left, right, total, m = 0, 0, nums[0], 1e16 while(left <= right): if(total < s): if(right < len(nums) - 1): right += 1 total += nums[right] else: break else: m = min(m, right - left + 1) #print(total, left, right, right - left + 1) total -= nums[left] left += 1 return m if(m < 1e16) else 0 862. Shortest Subarray with Sum at Least K (Hard) Info 862. Shortest Subarray with Sum at Least K (Hard) Algorithm: Deque Time Complexity: \\(O(n)\\) Space Complexity: \\(O(1)\\) Solution Deque. Deque \\(O(n)\\) Python 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 class Solution : def shortestSubarray ( self , nums : List [ int ], k : int ) -> int : IDX , VAL = 0 , 1 ans = 1e16 preSum = 0 deque = collections . deque ([( - 1 , 0 )]) for i in range ( len ( nums )): preSum += nums [ i ] while deque and preSum - deque [ 0 ][ VAL ] >= k : ans = min ( ans , i - deque . popleft ()[ IDX ]) while deque and preSum <= deque [ - 1 ][ VAL ]: deque . pop () deque . append (( i , preSum )) return ans if ans < 1e16 else - 1","title":"Related Problems"},{"location":"A.%20LeetCode/4.%20Problems/Array%20and%20String/Subarray/","text":"Subarray and Subsequence (6) It is oftentimes prohibitively costly to check all subarrays, which is of order \\(O(n^2)\\) , not to mention all subsequences, which is of order \\(O(2^n)\\) . Thus, the common algorithm for this type of problem is to use a structured DP scheme, that is, the problem is solved on-the-fly in a DP fashion, and the carry-on info is intentionally structured. NB: Subarrays are continuous while subsequences can be broken . Level I. Track a Single Number for DP[i-1] In LC53. Maximum Subarray (Easy) , the problem asks for the largest subarray sum . The trick for this type of problem is to keep the best info . Level II. Track a Hash Table for DP[i-1] In the previous example, we can keep just the best piece of information because the problem imposes a greedy constraint , meaning the solution of the current step must come from the solution of the previous step. However, some problems have multiple solutions at each step. For example, - LC560. Subarray Sum Equals K (Medium) asks us to find all subarrays that sum to \\(k\\) ; - LC523. Continuous Subarray Sum (Medium) asks us to find any subarray that sum to a multiple of \\(k\\) ; - LC974. Subarray Sums Divisible by K (Medium) asks us to find any subarray that whose sum is divisible by \\(k\\) . - LC1031. Maximum Sum of Two Non-Overlapping Subarrays (Medium) asks us to find the best pair of subarrays whose lengths are pre-specified . These problems are very similar if not identical, especially that all problems impose some equality constraint . The problem is no longer what one single piece of information we should keep, but how to keep and use the full spectrum of information efficiently. The trick for this type of problem is to keep a hash table of info . Level III. Track a Sorted Array for DP[0:i] each with a Single Number In the previous examples, we can track a hash table of information because the problem imposes an equality constraint , meaning the solution of the current step must come from one of the solutions from previous steps. However, as in LC713. Subarray Product Less Than K (Medium) , where we are asked to find all subarrays whose product is less than \\(k\\) , and in LC491. Increasing Subsequences (Medium) , where we are asked to find all non-decreasing subsequences . The trick for this type of problem is to keep a sorted array of info . Related Problems Problem Type Info Data Structure Algorithm LC53. Maximum Subarray 1D Structured FindAll No No DP LC918. Maximum Sum Circular Subarray 1D Structured FindAll No No DP LC560. Subarray Sum Equals K 1D Structured FindAll No No DP LC523. Subarray Sums Divisible by K 1D Structured FindAll No No DP LC974. Subarray Sums Divisible by K 1D Structured FindAll No No DP LC491. Increasing Subsequences 1D Structured FindAll No No DP LC1031. Maximum Sum of Two Non-Overlapping Subarrays 1D Structured FindAll No No DP","title":"Subarray and Subsequence (6)"},{"location":"A.%20LeetCode/4.%20Problems/Array%20and%20String/Subarray/#subarray-and-subsequence-6","text":"It is oftentimes prohibitively costly to check all subarrays, which is of order \\(O(n^2)\\) , not to mention all subsequences, which is of order \\(O(2^n)\\) . Thus, the common algorithm for this type of problem is to use a structured DP scheme, that is, the problem is solved on-the-fly in a DP fashion, and the carry-on info is intentionally structured. NB: Subarrays are continuous while subsequences can be broken .","title":"Subarray and Subsequence (6)"},{"location":"A.%20LeetCode/4.%20Problems/Array%20and%20String/Subarray/#level-i-track-a-single-number-for-dpi-1","text":"In LC53. Maximum Subarray (Easy) , the problem asks for the largest subarray sum . The trick for this type of problem is to keep the best info .","title":"Level I. Track a Single Number for DP[i-1]"},{"location":"A.%20LeetCode/4.%20Problems/Array%20and%20String/Subarray/#level-ii-track-a-hash-table-for-dpi-1","text":"In the previous example, we can keep just the best piece of information because the problem imposes a greedy constraint , meaning the solution of the current step must come from the solution of the previous step. However, some problems have multiple solutions at each step. For example, - LC560. Subarray Sum Equals K (Medium) asks us to find all subarrays that sum to \\(k\\) ; - LC523. Continuous Subarray Sum (Medium) asks us to find any subarray that sum to a multiple of \\(k\\) ; - LC974. Subarray Sums Divisible by K (Medium) asks us to find any subarray that whose sum is divisible by \\(k\\) . - LC1031. Maximum Sum of Two Non-Overlapping Subarrays (Medium) asks us to find the best pair of subarrays whose lengths are pre-specified . These problems are very similar if not identical, especially that all problems impose some equality constraint . The problem is no longer what one single piece of information we should keep, but how to keep and use the full spectrum of information efficiently. The trick for this type of problem is to keep a hash table of info .","title":"Level II. Track a Hash Table for DP[i-1]"},{"location":"A.%20LeetCode/4.%20Problems/Array%20and%20String/Subarray/#level-iii-track-a-sorted-array-for-dp0i-each-with-a-single-number","text":"In the previous examples, we can track a hash table of information because the problem imposes an equality constraint , meaning the solution of the current step must come from one of the solutions from previous steps. However, as in LC713. Subarray Product Less Than K (Medium) , where we are asked to find all subarrays whose product is less than \\(k\\) , and in LC491. Increasing Subsequences (Medium) , where we are asked to find all non-decreasing subsequences . The trick for this type of problem is to keep a sorted array of info .","title":"Level III. Track a Sorted Array for DP[0:i] each with a Single Number"},{"location":"A.%20LeetCode/4.%20Problems/Array%20and%20String/Subarray/#related-problems","text":"Problem Type Info Data Structure Algorithm LC53. Maximum Subarray 1D Structured FindAll No No DP LC918. Maximum Sum Circular Subarray 1D Structured FindAll No No DP LC560. Subarray Sum Equals K 1D Structured FindAll No No DP LC523. Subarray Sums Divisible by K 1D Structured FindAll No No DP LC974. Subarray Sums Divisible by K 1D Structured FindAll No No DP LC491. Increasing Subsequences 1D Structured FindAll No No DP LC1031. Maximum Sum of Two Non-Overlapping Subarrays 1D Structured FindAll No No DP","title":"Related Problems"},{"location":"B.%20Kaggle/","text":"Kaggle","title":"Index"},{"location":"C.%20Daphne/","text":"Kaggle","title":"Index"},{"location":"_About/","text":"This website serves as the companion of the book \"A Stroll Through the Brambles of Quantitative Finance\". Markdown Examples \\[ \\underbrace{\\A}_{=0} = 0 \\] OI Wiki Python 1 2 3 4 5 def bubble_sort ( items ): for i in range ( len ( items )): for j in range ( len ( items ) - 1 - i ): if items [ j ] > items [ j + 1 ]: items [ j ], items [ j + 1 ] = items [ j + 1 ], items [ j ] C++ 1 2 3 void f () { } Java 1 2 3 void f () { } The range () function is highlighted. Ex. 2.1 Suppose each of \\(K\\) -classes has associated target \\(t_k\\) , which is a vector of all zeros, except a one in the \\(k\\) -th position. Show that classifying to the largest of \\(\\hat y\\) amounts to choosing the closet target, \\(\\min_k\\|t_k-\\hat y\\|\\) , if the elements of \\(\\hat y\\) sum to one. Soln. 2.1 We need to prove: \\[\\begin{equation} \\underset{k}{\\operatorname{argmax}} \\hat y_k = \\underset{k}{\\operatorname{argmin}} \\|t_k-\\hat y\\|^2 \\label{eq:2-1a} \\end{equation}\\] By definition of \\(t_k\\) , we have \\[\\begin{align} \\|t_k-\\hat y\\|^2 &= (1-\\hat y_k)^2 + \\sum_{l \\neq k }(0 - \\hat y_l)^2\\nonumber\\\\ &= (1-\\hat y_k)^2 + \\sum_{l \\neq k }\\hat y_l^2 \\label{eq:2-1b} \\end{align}\\] Given \\(\\eqref{eq:2-1b}\\) , it's straightforward to see that \\(\\eqref{eq:2-1a}\\) indeed holds. Python 1 2 3 4 5 def bubble_sort ( items ): for i in range ( len ( items )): for j in range ( len ( items ) - 1 - i ): if items [ j ] > items [ j + 1 ]: items [ j ], items [ j + 1 ] = items [ j + 1 ], items [ j ] C++ 1 2 3 void f () { } The range () function is highlighted. Info The assumption \\(\\sum_{k=1}^K\\hat y_k=1\\) is actually not required. [CAPM]: Capital Asset Pricing Model asdfasdfasdfa asdfasd asdfasd adddasdfasdfasdfa asdfasd asdfasd adddasdfasdfasdfa asdfasd asdfasd addd asdfasdfasdfa asdfasd asdfasd addd asdfasdfasdfa asdfasd asdfasd addd Info The assumption \\(\\sum_{k=1}^K\\hat y_k=1\\) is actually not required. [CAPM]: Capital Asset Pricing Model Unordered list Sed sagittis eleifend rutrum Donec vitae suscipit est Nulla tempor lobortis orci Ordered list Sed sagittis eleifend rutrum Donec vitae suscipit est Nulla tempor lobortis orci Example Unordered List Example : 1 2 3 * Sed sagittis eleifend rutrum * Donec vitae suscipit est * Nulla tempor lobortis orci Result : Sed sagittis eleifend rutrum Donec vitae suscipit est Nulla tempor lobortis orci Ordered List Example : 1 2 3 1. Sed sagittis eleifend rutrum 2. Donec vitae suscipit est 3. Nulla tempor lobortis orci Result : Sed sagittis eleifend rutrum Donec vitae suscipit est Nulla tempor lobortis orci Method Description GET :material-check: Fetch resource PUT :material-check-all: Update resource DELETE :material-close: Delete resource Lorem ipsum 1 dolor sit amet, consectetur adipiscing elit. 2 Image caption My Favorite Introductory Reading List <<< Finance (Economics; Derivatives; Pricing Tools) -- Microeconomic Theory, by Andreu Mas-Colell, Michael D. Whinston, Jerry R. Green. -- Lectures on Macroeconomics, by Olivier Blanchard, Stanley Fischer. -- Options, Futures, and Other Derivatives, by John C Hull. -- Arbitrage Theory in Continuous Time, by Tomas Bjork. -- Stochastic Calculus for Finance I & II, by Steven Shreve. Mathematics (Analysis; Algebra; Geometry; Differential Equations) -- Calculus, by James Stewart. -- Principles of Mathematical Analysis, by Walter Rudin. -- Real Variables, by Alberto Torchinsky. -- Visual Complex Analysis, by Tristan Needham. -- Introductory Functional Analysis with Applications, by Erwin Kreyszig. -- Linear Algebra and Its Applications, by Gilbert Strang. -- Linear Algebra, by Kenneth M Hoffman, Ray Kunze. -- Algebra, by Michael Artin. -- Differential Geometry, by Erwin Kreyszig. -- Topology Without Tears, by Sidney A. Morris. -- Ordinary Differential Equations, by Morris Tenenbaum and Harry Pollard. -- Partial Differential Equations, by Lawrence C. Evans. Statistics (Random Variables; Stochastic Processes; Models; Theory; Machine Learning) -- A First Course in Probability, by Sheldon Ross. -- Stochastic Processes, by Sheldon Ross. -- Applied Linear Statistical Models, by Michael H. Kutner, John Neter, Christopher J. Nachtsheim, William Li. -- Generalized Linear Models, by P. McCullagh and John A. Nelder. -- Probability: Theory and Examples, by Rick Durrett -- Statistical Inference, by George Casella and Roger L. Berger. -- Pattern Recognition and Machine Learning, by Christopher Bishop. -- Machine Learing, by Kevin Murphy. Optimization (Linear; Nonlinear; Convex) -- Introduction to Linear Optimization, by Dimitris Bertsimas, John N. Tsitsiklis. -- Nonlinear Programming, by Dimitri Bertsekas. -- Linear and Nonlinear Optimization, by David G. Luenberger and Yinyu Ye. -- Numerical Optimization, by Jorge Nocedal, Stephen Wright. -- Introductory Lectures on Convex Optimization: A Basic Course, by Y. Nesterov. -- Convex Optimization, by Stephen Boyd, Lieven Vandenberghe. Computer Science (System, OS, Network; Algorithms; Coding) -- Computer Systems: A Programmer's Perspective, by Randal E. Bryant, David R. O'Hallaron. -- Operating System Concepts, by Abraham Silberschatz, Peter B. Galvin, Greg Gagne. -- Computer Networking: A Top-Down Approach, by James F. Kurose and Keith W. Ross. -- Introduction to Algorithms, by Thomas H. Cormen, Charles E. Leiserson, Ronald L. Rivest, Clifford Stein. -- C++ Primer, by Stanley B. Lippman, Jos\u00e9e Lajoie, Barbara E. Moo. -- Thinking in Java, by Bruce Eckel. Lorem ipsum dolor sit amet, consectetur adipiscing elit. \u21a9 Lorem ipsum dolor sit amet, consectetur adipiscing elit. Nulla et euismod nulla. Curabitur feugiat, tortor non consequat finibus, justo purus auctor massa, nec semper lorem quam in massa. \u21a9","title":"Index"},{"location":"_About/#markdown-examples","text":"\\[ \\underbrace{\\A}_{=0} = 0 \\] OI Wiki Python 1 2 3 4 5 def bubble_sort ( items ): for i in range ( len ( items )): for j in range ( len ( items ) - 1 - i ): if items [ j ] > items [ j + 1 ]: items [ j ], items [ j + 1 ] = items [ j + 1 ], items [ j ] C++ 1 2 3 void f () { } Java 1 2 3 void f () { } The range () function is highlighted. Ex. 2.1 Suppose each of \\(K\\) -classes has associated target \\(t_k\\) , which is a vector of all zeros, except a one in the \\(k\\) -th position. Show that classifying to the largest of \\(\\hat y\\) amounts to choosing the closet target, \\(\\min_k\\|t_k-\\hat y\\|\\) , if the elements of \\(\\hat y\\) sum to one. Soln. 2.1 We need to prove: \\[\\begin{equation} \\underset{k}{\\operatorname{argmax}} \\hat y_k = \\underset{k}{\\operatorname{argmin}} \\|t_k-\\hat y\\|^2 \\label{eq:2-1a} \\end{equation}\\] By definition of \\(t_k\\) , we have \\[\\begin{align} \\|t_k-\\hat y\\|^2 &= (1-\\hat y_k)^2 + \\sum_{l \\neq k }(0 - \\hat y_l)^2\\nonumber\\\\ &= (1-\\hat y_k)^2 + \\sum_{l \\neq k }\\hat y_l^2 \\label{eq:2-1b} \\end{align}\\] Given \\(\\eqref{eq:2-1b}\\) , it's straightforward to see that \\(\\eqref{eq:2-1a}\\) indeed holds. Python 1 2 3 4 5 def bubble_sort ( items ): for i in range ( len ( items )): for j in range ( len ( items ) - 1 - i ): if items [ j ] > items [ j + 1 ]: items [ j ], items [ j + 1 ] = items [ j + 1 ], items [ j ] C++ 1 2 3 void f () { } The range () function is highlighted. Info The assumption \\(\\sum_{k=1}^K\\hat y_k=1\\) is actually not required. [CAPM]: Capital Asset Pricing Model asdfasdfasdfa asdfasd asdfasd adddasdfasdfasdfa asdfasd asdfasd adddasdfasdfasdfa asdfasd asdfasd addd asdfasdfasdfa asdfasd asdfasd addd asdfasdfasdfa asdfasd asdfasd addd Info The assumption \\(\\sum_{k=1}^K\\hat y_k=1\\) is actually not required. [CAPM]: Capital Asset Pricing Model Unordered list Sed sagittis eleifend rutrum Donec vitae suscipit est Nulla tempor lobortis orci Ordered list Sed sagittis eleifend rutrum Donec vitae suscipit est Nulla tempor lobortis orci Example Unordered List Example : 1 2 3 * Sed sagittis eleifend rutrum * Donec vitae suscipit est * Nulla tempor lobortis orci Result : Sed sagittis eleifend rutrum Donec vitae suscipit est Nulla tempor lobortis orci Ordered List Example : 1 2 3 1. Sed sagittis eleifend rutrum 2. Donec vitae suscipit est 3. Nulla tempor lobortis orci Result : Sed sagittis eleifend rutrum Donec vitae suscipit est Nulla tempor lobortis orci Method Description GET :material-check: Fetch resource PUT :material-check-all: Update resource DELETE :material-close: Delete resource Lorem ipsum 1 dolor sit amet, consectetur adipiscing elit. 2 Image caption My Favorite Introductory Reading List <<< Finance (Economics; Derivatives; Pricing Tools) -- Microeconomic Theory, by Andreu Mas-Colell, Michael D. Whinston, Jerry R. Green. -- Lectures on Macroeconomics, by Olivier Blanchard, Stanley Fischer. -- Options, Futures, and Other Derivatives, by John C Hull. -- Arbitrage Theory in Continuous Time, by Tomas Bjork. -- Stochastic Calculus for Finance I & II, by Steven Shreve. Mathematics (Analysis; Algebra; Geometry; Differential Equations) -- Calculus, by James Stewart. -- Principles of Mathematical Analysis, by Walter Rudin. -- Real Variables, by Alberto Torchinsky. -- Visual Complex Analysis, by Tristan Needham. -- Introductory Functional Analysis with Applications, by Erwin Kreyszig. -- Linear Algebra and Its Applications, by Gilbert Strang. -- Linear Algebra, by Kenneth M Hoffman, Ray Kunze. -- Algebra, by Michael Artin. -- Differential Geometry, by Erwin Kreyszig. -- Topology Without Tears, by Sidney A. Morris. -- Ordinary Differential Equations, by Morris Tenenbaum and Harry Pollard. -- Partial Differential Equations, by Lawrence C. Evans. Statistics (Random Variables; Stochastic Processes; Models; Theory; Machine Learning) -- A First Course in Probability, by Sheldon Ross. -- Stochastic Processes, by Sheldon Ross. -- Applied Linear Statistical Models, by Michael H. Kutner, John Neter, Christopher J. Nachtsheim, William Li. -- Generalized Linear Models, by P. McCullagh and John A. Nelder. -- Probability: Theory and Examples, by Rick Durrett -- Statistical Inference, by George Casella and Roger L. Berger. -- Pattern Recognition and Machine Learning, by Christopher Bishop. -- Machine Learing, by Kevin Murphy. Optimization (Linear; Nonlinear; Convex) -- Introduction to Linear Optimization, by Dimitris Bertsimas, John N. Tsitsiklis. -- Nonlinear Programming, by Dimitri Bertsekas. -- Linear and Nonlinear Optimization, by David G. Luenberger and Yinyu Ye. -- Numerical Optimization, by Jorge Nocedal, Stephen Wright. -- Introductory Lectures on Convex Optimization: A Basic Course, by Y. Nesterov. -- Convex Optimization, by Stephen Boyd, Lieven Vandenberghe. Computer Science (System, OS, Network; Algorithms; Coding) -- Computer Systems: A Programmer's Perspective, by Randal E. Bryant, David R. O'Hallaron. -- Operating System Concepts, by Abraham Silberschatz, Peter B. Galvin, Greg Gagne. -- Computer Networking: A Top-Down Approach, by James F. Kurose and Keith W. Ross. -- Introduction to Algorithms, by Thomas H. Cormen, Charles E. Leiserson, Ronald L. Rivest, Clifford Stein. -- C++ Primer, by Stanley B. Lippman, Jos\u00e9e Lajoie, Barbara E. Moo. -- Thinking in Java, by Bruce Eckel. Lorem ipsum dolor sit amet, consectetur adipiscing elit. \u21a9 Lorem ipsum dolor sit amet, consectetur adipiscing elit. Nulla et euismod nulla. Curabitur feugiat, tortor non consequat finibus, justo purus auctor massa, nec semper lorem quam in massa. \u21a9","title":"Markdown Examples"}]}