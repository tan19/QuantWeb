{"config":{"lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"A stroll through the brambles of Quant Finance.","title":"Home"},{"location":"-Quant%20Interview%20Questions/","text":"A stroll through the brambles of Quant Finance.","title":"Index"},{"location":"-Quant%20Interview%20Questions/0.%20Basics/Basics/","text":"Basics","title":"Basics"},{"location":"-Quant%20Interview%20Questions/0.%20Basics/Basics/#basics","text":"","title":"Basics"},{"location":"-Quant%20Interview%20Questions/0.%20Basics/1.1%20Mental%20Games/","text":"Examples OI Wiki \u6d1b\u8c37 \u7a0b\u5e8f\u8bbe\u8ba1\u7ade\u8d5b\u8fdb\u9636\u8bad\u7ec3\u6307\u5357","title":"Examples"},{"location":"-Quant%20Interview%20Questions/0.%20Basics/1.1%20Mental%20Games/#examples","text":"OI Wiki \u6d1b\u8c37 \u7a0b\u5e8f\u8bbe\u8ba1\u7ade\u8d5b\u8fdb\u9636\u8bad\u7ec3\u6307\u5357","title":"Examples"},{"location":"-Quant%20Interview%20Questions/0.%20Basics/1.1%20Mental%20Games/Logic%20Brainteasers/","text":"Logic Brainteasers","title":"Logic Brainteasers"},{"location":"-Quant%20Interview%20Questions/0.%20Basics/1.1%20Mental%20Games/Logic%20Brainteasers/#logic-brainteasers","text":"","title":"Logic Brainteasers"},{"location":"-Quant%20Interview%20Questions/0.%20Basics/1.1%20Mental%20Games/Math%20Brainteasers/","text":"Math Brainteasers","title":"Math Brainteasers"},{"location":"-Quant%20Interview%20Questions/0.%20Basics/1.1%20Mental%20Games/Math%20Brainteasers/#math-brainteasers","text":"","title":"Math Brainteasers"},{"location":"-Quant%20Interview%20Questions/0.%20Basics/1.1%20Mental%20Games/Mental%20Math/","text":"Mental Math","title":"Mental Math"},{"location":"-Quant%20Interview%20Questions/0.%20Basics/1.1%20Mental%20Games/Mental%20Math/#mental-math","text":"","title":"Mental Math"},{"location":"-Quant%20Interview%20Questions/1.%20Quant%20Developer/Index/","text":"Quant Developer","title":"Quant Developer"},{"location":"-Quant%20Interview%20Questions/1.%20Quant%20Developer/Index/#quant-developer","text":"","title":"Quant Developer"},{"location":"-Quant%20Interview%20Questions/2.%20Quant%20Researcher%20%285%29/2.1%20Calculus/","text":"Calculus (5) Pre-calculus (1) Q: What is \\(\\sin(18^{\\circ})\\) ? (Medium) What is \\(\\sin(18^{\\circ})\\) ? A: What is \\(\\sin(18^{\\circ})\\) ? The answer is \\((\\sqrt{5} - 1)/4\\) . The geometry method is illustrated below (let CD = \\(x\\) ): \\[\\begin{align*} \\frac{2+x}{2} = \\frac{2}{x} \\implies x = \\sqrt{5} - 1 \\implies sin(18^{\\circ}) = \\frac{1}{2+x} = \\frac{\\sqrt{5}-1}{4} \\end{align*}\\] The algebraic method is: \\[\\begin{align*} \\theta = 18^{\\circ} &\\iff 5\\theta = 90^{\\circ}\\\\ \\sin(2\\theta) &= \\cos(3\\theta)\\\\ 2\\sin(\\theta)\\cos(\\theta) &= \\cos(2\\theta)\\cos(\\theta) - \\sin(2\\theta)\\sin(\\theta) \\\\ & = \\cos(2\\theta)\\cos(\\theta) - 2\\sin(\\theta)\\cos(\\theta)\\sin(\\theta)\\\\ 2\\sin(\\theta) &= \\cos(2\\theta) - 2\\sin(\\theta)\\sin(\\theta)\\\\ 2\\sin(\\theta) &= 1 - 2\\sin^2(\\theta) - 2\\sin(\\theta)\\sin(\\theta)\\\\ \\end{align*}\\] and finally, \\[\\begin{align*} 4\\sin^2(\\theta) + 2\\sin(\\theta) - 1 &= 0\\\\ \\sin(\\theta) = \\frac{\\sqrt{5} - 1}{4} \\end{align*}\\] Limits (3) Q: Square Root of 2 (Easy) Calculate \\(\\sqrt{2 + \\sqrt{2 + \\sqrt{2 + \\dots}}}\\) . A: Square Root of 2 (Easy) Trick If you are asked for something in a repetitive process such as computing an \"until event\" in coin tossing or a recursive pattern as in this problem, make it a variable and solve it . Let \\[ x \\equiv \\sqrt{2 + \\sqrt{2 + \\sqrt{2 + \\dots}}} \\] Then $$ x = \\sqrt{2 + x} $$ So \\(x = 2\\) . Note that the other root \\(x = -1\\) doesn't work. Q: Solve \\(x^{x^{x^{...}}} = 2\\) (Easy) Solve $Solve \\(x^{x^{x^{...}}} = 2\\) . A: Solve \\(x^{x^{x^{...}}} = 2\\) (Easy) Trick If you are asked for something in a repetitive process such as computing an \"until event\" in coin tossing or a recursive pattern as in this problem, make it a variable and solve it . \\(x^{x^{x^{...}}} = 2\\) is equivalent to \\(x^2 = 2\\) , so \\(x = \\sqrt{2}\\) . Q: Limit (Easy) Calculate \\[ \\lim_{x \\to 0}\\left[\\frac{a^x + b^x}{2}\\right]^{\\frac1x} \\] A: Limit (Easy) Trick Note that if \\(g(x)\\) is continuous and \\(\\lim_{x \\to x_0}f(x)\\) exists, then we have \\[ \\lim_{x \\to x_0} g(f(x)) = g(\\lim_{x \\to x_0} f(x)) \\] Since \\(g(x) \\equiv e^x\\) is continuous, so we have \\[\\begin{align*} &\\lim_{x \\to 0}\\frac1x \\ln \\left[\\frac{a^x + b^x}{2}\\right]\\\\ &= \\lim_{x \\to 0} \\frac{2}{a^x + b^x}\\frac{a^x\\ln a + b^x \\ln b}{2} = \\frac{\\ln ab}{2} \\end{align*}\\] Finally, \\(\\lim_{x \\to 0}\\left[\\frac{a^x + b^x}{2}\\right]^{\\frac1x} = \\sqrt{ab}\\) . Derivatives Integration Complex Numbers (1) Q: Is \\(\\sin(1^\\circ)\\) algebraic? Is \\(\\sin(1^\\circ)\\) algebraic? A: Is \\(\\sin(1^\\circ)\\) algebraic? Yes. Q: Square Root of \\(i\\) (Easy) What is \\(\\sqrt{i}\\) ? A: Square Root of \\(i\\) (Easy) Trick When you see \\(i\\) , usually start to re-write it in Euler's formula: \\[ e^{ix} = \\cos(x) + i\\sin(x) \\] By Euler's formula, we have \\[\\begin{align*} &i^{\\frac12} \\equiv e^{i (2k\\pi + \\frac{\\pi}{2}) \\frac12} \\\\ &= \\cos\\left(k\\pi + \\frac{\\pi}{4}\\right) + i \\sin\\left(k\\pi + \\frac{\\pi}{4}\\right)\\\\ &= \\pm\\left(\\frac{\\sqrt{2}}{2} + i \\frac{\\sqrt{2}}{2}\\right) \\end{align*}\\] Another method is to observe that: \\[ \\sqrt{i} \\equiv a + bi \\implies i = a^2 + 2abi - b^2 \\] and so \\[\\begin{align*} a^2 - b^2 &= 0\\\\ 2ab &= 1 \\end{align*}\\] which gives us the same results.","title":"Calculus (5)"},{"location":"-Quant%20Interview%20Questions/2.%20Quant%20Researcher%20%285%29/2.1%20Calculus/#calculus-5","text":"","title":"Calculus (5)"},{"location":"-Quant%20Interview%20Questions/2.%20Quant%20Researcher%20%285%29/2.1%20Calculus/#pre-calculus-1","text":"Q: What is \\(\\sin(18^{\\circ})\\) ? (Medium) What is \\(\\sin(18^{\\circ})\\) ? A: What is \\(\\sin(18^{\\circ})\\) ? The answer is \\((\\sqrt{5} - 1)/4\\) . The geometry method is illustrated below (let CD = \\(x\\) ): \\[\\begin{align*} \\frac{2+x}{2} = \\frac{2}{x} \\implies x = \\sqrt{5} - 1 \\implies sin(18^{\\circ}) = \\frac{1}{2+x} = \\frac{\\sqrt{5}-1}{4} \\end{align*}\\] The algebraic method is: \\[\\begin{align*} \\theta = 18^{\\circ} &\\iff 5\\theta = 90^{\\circ}\\\\ \\sin(2\\theta) &= \\cos(3\\theta)\\\\ 2\\sin(\\theta)\\cos(\\theta) &= \\cos(2\\theta)\\cos(\\theta) - \\sin(2\\theta)\\sin(\\theta) \\\\ & = \\cos(2\\theta)\\cos(\\theta) - 2\\sin(\\theta)\\cos(\\theta)\\sin(\\theta)\\\\ 2\\sin(\\theta) &= \\cos(2\\theta) - 2\\sin(\\theta)\\sin(\\theta)\\\\ 2\\sin(\\theta) &= 1 - 2\\sin^2(\\theta) - 2\\sin(\\theta)\\sin(\\theta)\\\\ \\end{align*}\\] and finally, \\[\\begin{align*} 4\\sin^2(\\theta) + 2\\sin(\\theta) - 1 &= 0\\\\ \\sin(\\theta) = \\frac{\\sqrt{5} - 1}{4} \\end{align*}\\]","title":"Pre-calculus (1)"},{"location":"-Quant%20Interview%20Questions/2.%20Quant%20Researcher%20%285%29/2.1%20Calculus/#limits-3","text":"Q: Square Root of 2 (Easy) Calculate \\(\\sqrt{2 + \\sqrt{2 + \\sqrt{2 + \\dots}}}\\) . A: Square Root of 2 (Easy) Trick If you are asked for something in a repetitive process such as computing an \"until event\" in coin tossing or a recursive pattern as in this problem, make it a variable and solve it . Let \\[ x \\equiv \\sqrt{2 + \\sqrt{2 + \\sqrt{2 + \\dots}}} \\] Then $$ x = \\sqrt{2 + x} $$ So \\(x = 2\\) . Note that the other root \\(x = -1\\) doesn't work. Q: Solve \\(x^{x^{x^{...}}} = 2\\) (Easy) Solve $Solve \\(x^{x^{x^{...}}} = 2\\) . A: Solve \\(x^{x^{x^{...}}} = 2\\) (Easy) Trick If you are asked for something in a repetitive process such as computing an \"until event\" in coin tossing or a recursive pattern as in this problem, make it a variable and solve it . \\(x^{x^{x^{...}}} = 2\\) is equivalent to \\(x^2 = 2\\) , so \\(x = \\sqrt{2}\\) . Q: Limit (Easy) Calculate \\[ \\lim_{x \\to 0}\\left[\\frac{a^x + b^x}{2}\\right]^{\\frac1x} \\] A: Limit (Easy) Trick Note that if \\(g(x)\\) is continuous and \\(\\lim_{x \\to x_0}f(x)\\) exists, then we have \\[ \\lim_{x \\to x_0} g(f(x)) = g(\\lim_{x \\to x_0} f(x)) \\] Since \\(g(x) \\equiv e^x\\) is continuous, so we have \\[\\begin{align*} &\\lim_{x \\to 0}\\frac1x \\ln \\left[\\frac{a^x + b^x}{2}\\right]\\\\ &= \\lim_{x \\to 0} \\frac{2}{a^x + b^x}\\frac{a^x\\ln a + b^x \\ln b}{2} = \\frac{\\ln ab}{2} \\end{align*}\\] Finally, \\(\\lim_{x \\to 0}\\left[\\frac{a^x + b^x}{2}\\right]^{\\frac1x} = \\sqrt{ab}\\) .","title":"Limits (3)"},{"location":"-Quant%20Interview%20Questions/2.%20Quant%20Researcher%20%285%29/2.1%20Calculus/#derivatives","text":"","title":"Derivatives"},{"location":"-Quant%20Interview%20Questions/2.%20Quant%20Researcher%20%285%29/2.1%20Calculus/#integration","text":"","title":"Integration"},{"location":"-Quant%20Interview%20Questions/2.%20Quant%20Researcher%20%285%29/2.1%20Calculus/#complex-numbers-1","text":"Q: Is \\(\\sin(1^\\circ)\\) algebraic? Is \\(\\sin(1^\\circ)\\) algebraic? A: Is \\(\\sin(1^\\circ)\\) algebraic? Yes. Q: Square Root of \\(i\\) (Easy) What is \\(\\sqrt{i}\\) ? A: Square Root of \\(i\\) (Easy) Trick When you see \\(i\\) , usually start to re-write it in Euler's formula: \\[ e^{ix} = \\cos(x) + i\\sin(x) \\] By Euler's formula, we have \\[\\begin{align*} &i^{\\frac12} \\equiv e^{i (2k\\pi + \\frac{\\pi}{2}) \\frac12} \\\\ &= \\cos\\left(k\\pi + \\frac{\\pi}{4}\\right) + i \\sin\\left(k\\pi + \\frac{\\pi}{4}\\right)\\\\ &= \\pm\\left(\\frac{\\sqrt{2}}{2} + i \\frac{\\sqrt{2}}{2}\\right) \\end{align*}\\] Another method is to observe that: \\[ \\sqrt{i} \\equiv a + bi \\implies i = a^2 + 2abi - b^2 \\] and so \\[\\begin{align*} a^2 - b^2 &= 0\\\\ 2ab &= 1 \\end{align*}\\] which gives us the same results.","title":"Complex Numbers (1)"},{"location":"-Quant%20Interview%20Questions/2.%20Quant%20Researcher%20%285%29/2.2%20Linear%20Algebra/","text":"Linear Algebra Quant Interview Questions","title":"Linear Algebra"},{"location":"-Quant%20Interview%20Questions/2.%20Quant%20Researcher%20%285%29/2.2%20Linear%20Algebra/#linear-algebra","text":"Quant Interview Questions","title":"Linear Algebra"},{"location":"-Quant%20Interview%20Questions/2.%20Quant%20Researcher%20%285%29/2.3%20Probability/","text":"Probability Quant Interview Questions","title":"Probability"},{"location":"-Quant%20Interview%20Questions/2.%20Quant%20Researcher%20%285%29/2.3%20Probability/#probability","text":"Quant Interview Questions","title":"Probability"},{"location":"-Quant%20Interview%20Questions/2.%20Quant%20Researcher%20%285%29/2.4%20Statistics%20%26%20Machine%20Learning/","text":"Statistics & Machine Learning Q: Why K-Means has to use Euclidean distance? Why K-Means has to use Euclidean distance? A: Why K-Means has to use Euclidean distance? The way k-means is constructed is not based on distances. StackOverflow Bias-Variance Tradeoff A model can be thought of as a statistic (i.e., a function of samples), hence it has a sampling distribution with its mean and variance. The error between the mean (i.e., average model prediction) and the ground truth is called bias , while the average variability in the model prediction is called variance , which tells you how much the model changes as the data are sampled repeatedly. Mathematically, \\[\\begin{align} \\mbox{Bias} &= \\EEE[\\hat{f}(x)] - f(x)\\\\ \\mbox{Variance} &= \\mbox{Var}[\\hat{f}(x)] \\end{align}\\] The mean square error can then be decomposed into three terms: \\[\\begin{align} \\mbox{Error} &\\equiv \\EEE[(\\hat{f}(x) - f(x))^2] \\\\ \\nonumber &= (\\EEE[\\hat{f}(x)-f(x)])^2 + \\mbox{Var}[\\hat{f}(x) - f(x)]\\\\ \\nonumber &= (\\EEE[\\hat{f}(x)-f(x)])^2 + \\mbox{Var}[\\hat{f}(x)] + \\mbox{Var}[f(x)] \\\\ \\nonumber &= \\mbox{Bias}^2 + \\mbox{Variance} + \\mbox{Ground Truth Error} \\end{align}\\] The immediate consequences of the above are that: Increased data size does not help the bias term. But it does help the variance term. The ground truth error, which comes from the population, is irreducible. One way to resolve this issue is to use mixture models and/or ensemble methods (read Section \\ref{sec:Ensemble_Methods} for more details). See Questions (e.g., \\ref{q:Bias-Variance Tradeoff}) for the topic of this section.","title":"Statistics & Machine Learning"},{"location":"-Quant%20Interview%20Questions/2.%20Quant%20Researcher%20%285%29/2.4%20Statistics%20%26%20Machine%20Learning/#statistics-machine-learning","text":"Q: Why K-Means has to use Euclidean distance? Why K-Means has to use Euclidean distance? A: Why K-Means has to use Euclidean distance? The way k-means is constructed is not based on distances. StackOverflow","title":"Statistics &amp; Machine Learning"},{"location":"-Quant%20Interview%20Questions/2.%20Quant%20Researcher%20%285%29/2.4%20Statistics%20%26%20Machine%20Learning/#bias-variance-tradeoff","text":"A model can be thought of as a statistic (i.e., a function of samples), hence it has a sampling distribution with its mean and variance. The error between the mean (i.e., average model prediction) and the ground truth is called bias , while the average variability in the model prediction is called variance , which tells you how much the model changes as the data are sampled repeatedly. Mathematically, \\[\\begin{align} \\mbox{Bias} &= \\EEE[\\hat{f}(x)] - f(x)\\\\ \\mbox{Variance} &= \\mbox{Var}[\\hat{f}(x)] \\end{align}\\] The mean square error can then be decomposed into three terms: \\[\\begin{align} \\mbox{Error} &\\equiv \\EEE[(\\hat{f}(x) - f(x))^2] \\\\ \\nonumber &= (\\EEE[\\hat{f}(x)-f(x)])^2 + \\mbox{Var}[\\hat{f}(x) - f(x)]\\\\ \\nonumber &= (\\EEE[\\hat{f}(x)-f(x)])^2 + \\mbox{Var}[\\hat{f}(x)] + \\mbox{Var}[f(x)] \\\\ \\nonumber &= \\mbox{Bias}^2 + \\mbox{Variance} + \\mbox{Ground Truth Error} \\end{align}\\] The immediate consequences of the above are that: Increased data size does not help the bias term. But it does help the variance term. The ground truth error, which comes from the population, is irreducible. One way to resolve this issue is to use mixture models and/or ensemble methods (read Section \\ref{sec:Ensemble_Methods} for more details). See Questions (e.g., \\ref{q:Bias-Variance Tradeoff}) for the topic of this section.","title":"Bias-Variance Tradeoff"},{"location":"-Quant%20Interview%20Questions/2.%20Quant%20Researcher%20%285%29/2.5%20Numerical%20Methods%20and%20Optimization/","text":"Numerical Methods & Optimization","title":"Numerical Methods & Optimization"},{"location":"-Quant%20Interview%20Questions/2.%20Quant%20Researcher%20%285%29/2.5%20Numerical%20Methods%20and%20Optimization/#numerical-methods-optimization","text":"","title":"Numerical Methods &amp; Optimization"},{"location":"-Quant%20Interview%20Questions/3.%20Quant%20Trader%20%282%29/BM/","text":"Brownian Motion and Related Concepts (2) Brownian Motion (1) Q: Brownian Motion Hitting Time Probability Suppose \\(dX_t = rdt + dW_t\\) , what is the probability that \\(X_t\\) hits 3 before hitting -5? A: Brownian Motion Hitting Time Probability Notice that the exponential martingale is defined as: \\[\\begin{align} e^{-\\frac{\\sigma^2}{2}t + \\sigma W_t} \\end{align}\\] Plug in \\(W_t = X_t - rt\\) , we have \\[\\begin{align} e^{-\\frac{\\sigma^2}{2}t + \\sigma (X_t - rt)} \\end{align}\\] Let \\(\\sigma = -2r\\) , we have \\[\\begin{align} e^{-\\frac{\\sigma^2}{2}t + \\sigma (X_t - rt)} = e^{-\\frac{(-2r)^2}{2}t - 2r (X_t - rt)} = e^{-2rX_t} \\end{align}\\] and \\(e^{-2rX_t}\\) is a martingale. Now, \\[\\begin{align} 1 = E[e^{-2rX_t}] = P_3 e^{-2r(3)} + (1-P_3) e^{-2r(-5)} \\implies P_3 = \\frac{e^{10r} - 1}{e^{10r} - e^{-6r}} \\end{align}\\] Brownian Bridge (1) Q: Brownian Bridge What is a Brownian bridge? What is the distribution of a Brownian Bridge? Why and how do we use it? A: Brownian Bridge In a Brownian motion the state variable, i.e. the stock price, FX rate, interest rate, is stochastic and evolves over a period of time in a random manner. The randomness is tied to the volatility of the asset and the drift is deterministic. In the short run, the volatility dominates the process and the asset price path is truly stochastic, i.e. random. However, over the long period of time the drift will dominate the volatility and therefore, if there are small errors in estimation of the drift it will lead to large fluctuations in the future price distribution. This is one of the drawbacks of a Brownian motion (as applied to the pricing of financial assets). Over longer horizons the drift of the stochastic process (Brownian motion) becomes a complicating factor. Therefore, a Brownian motion may not be very suitable for modelling an asset which has a longer maturity period, say, 5 years, 10 years, etc. and where the final state of the asset is known. Like a discount bond (Treasury bonds). A government bond can have maturities of 5 years, 10 years, 30 years and the final value of the bond is known, i.e. the par (face) value. And, a bond will always redeem at par. Besides Treasury and discount bonds, Brownian Bridges are also used to model Barrier options and other exotic options where the terminal value is known in advance. Monte Carlo pricing of continuous barrier options with Heston . Martingale","title":"Brownian Motion and Related Concepts (2)"},{"location":"-Quant%20Interview%20Questions/3.%20Quant%20Trader%20%282%29/BM/#brownian-motion-and-related-concepts-2","text":"","title":"Brownian Motion and Related Concepts (2)"},{"location":"-Quant%20Interview%20Questions/3.%20Quant%20Trader%20%282%29/BM/#brownian-motion-1","text":"Q: Brownian Motion Hitting Time Probability Suppose \\(dX_t = rdt + dW_t\\) , what is the probability that \\(X_t\\) hits 3 before hitting -5? A: Brownian Motion Hitting Time Probability Notice that the exponential martingale is defined as: \\[\\begin{align} e^{-\\frac{\\sigma^2}{2}t + \\sigma W_t} \\end{align}\\] Plug in \\(W_t = X_t - rt\\) , we have \\[\\begin{align} e^{-\\frac{\\sigma^2}{2}t + \\sigma (X_t - rt)} \\end{align}\\] Let \\(\\sigma = -2r\\) , we have \\[\\begin{align} e^{-\\frac{\\sigma^2}{2}t + \\sigma (X_t - rt)} = e^{-\\frac{(-2r)^2}{2}t - 2r (X_t - rt)} = e^{-2rX_t} \\end{align}\\] and \\(e^{-2rX_t}\\) is a martingale. Now, \\[\\begin{align} 1 = E[e^{-2rX_t}] = P_3 e^{-2r(3)} + (1-P_3) e^{-2r(-5)} \\implies P_3 = \\frac{e^{10r} - 1}{e^{10r} - e^{-6r}} \\end{align}\\]","title":"Brownian Motion (1)"},{"location":"-Quant%20Interview%20Questions/3.%20Quant%20Trader%20%282%29/BM/#brownian-bridge-1","text":"Q: Brownian Bridge What is a Brownian bridge? What is the distribution of a Brownian Bridge? Why and how do we use it? A: Brownian Bridge In a Brownian motion the state variable, i.e. the stock price, FX rate, interest rate, is stochastic and evolves over a period of time in a random manner. The randomness is tied to the volatility of the asset and the drift is deterministic. In the short run, the volatility dominates the process and the asset price path is truly stochastic, i.e. random. However, over the long period of time the drift will dominate the volatility and therefore, if there are small errors in estimation of the drift it will lead to large fluctuations in the future price distribution. This is one of the drawbacks of a Brownian motion (as applied to the pricing of financial assets). Over longer horizons the drift of the stochastic process (Brownian motion) becomes a complicating factor. Therefore, a Brownian motion may not be very suitable for modelling an asset which has a longer maturity period, say, 5 years, 10 years, etc. and where the final state of the asset is known. Like a discount bond (Treasury bonds). A government bond can have maturities of 5 years, 10 years, 30 years and the final value of the bond is known, i.e. the par (face) value. And, a bond will always redeem at par. Besides Treasury and discount bonds, Brownian Bridges are also used to model Barrier options and other exotic options where the terminal value is known in advance. Monte Carlo pricing of continuous barrier options with Heston .","title":"Brownian Bridge (1)"},{"location":"-Quant%20Interview%20Questions/3.%20Quant%20Trader%20%282%29/BM/#martingale","text":"","title":"Martingale"},{"location":"-Quant%20Interview%20Questions/3.%20Quant%20Trader%20%282%29/BS/","text":"Black Scholes and Vanilla Options","title":"Black Scholes and Vanilla Options"},{"location":"-Quant%20Interview%20Questions/3.%20Quant%20Trader%20%282%29/BS/#black-scholes-and-vanilla-options","text":"","title":"Black Scholes and Vanilla Options"},{"location":"-Quant%20Interview%20Questions/3.%20Quant%20Trader%20%282%29/4.2%20Trading%20Strategies/","text":"Index","title":"Index"},{"location":"-Quant%20Interview%20Questions/3.%20Quant%20Trader%20%282%29/4.2%20Trading%20Strategies/#index","text":"","title":"Index"},{"location":"-Quant%20Interview%20Questions/3.%20Quant%20Trader%20%282%29/4.3%20Markets%20and%20Execution/","text":"Market IEX is the new exchange for fairer market. Q: What is today's 10-year yield? What is today's 10-year yield? A: What is today's 10-year yield? Q: What is a currency pair cross? What is a currency pair cross? A: What is a currency pair cross? A cross currency refers to a currency pair or transaction that does not involve the U.S. dollar. For example, EUR/GBP. Q: Why you can't have time-in-force stop-loss orders? What you can't have time-in-force stop-loss orders? A: What is a currency pair cross?","title":"Market"},{"location":"-Quant%20Interview%20Questions/3.%20Quant%20Trader%20%282%29/4.3%20Markets%20and%20Execution/#market","text":"IEX is the new exchange for fairer market. Q: What is today's 10-year yield? What is today's 10-year yield? A: What is today's 10-year yield? Q: What is a currency pair cross? What is a currency pair cross? A: What is a currency pair cross? A cross currency refers to a currency pair or transaction that does not involve the U.S. dollar. For example, EUR/GBP. Q: Why you can't have time-in-force stop-loss orders? What you can't have time-in-force stop-loss orders? A: What is a currency pair cross?","title":"Market"},{"location":"-Quant%20Interview%20Questions/3.%20Quant%20Trader%20%282%29/5.1%20Portfolio%20Optimization/","text":"Index","title":"Index"},{"location":"-Quant%20Interview%20Questions/3.%20Quant%20Trader%20%282%29/5.1%20Portfolio%20Optimization/#index","text":"","title":"Index"},{"location":"0.%20Basics/Calculus/","text":"Calculus Vector Calculus Definition: Vector Field A vector field is a vector function \\(\\FF : \\RRR^n \\to \\RRR^n\\) . Vector fields can usefully be thought of as representing the velocity of a moving flow in space, and this physical intuition leads to notions such as the divergence (which represents the rate of change of volume of a flow) and curl (which represents the rotation of a flow). Line integral is the tool to use in the context of vector fields.","title":"Calculus"},{"location":"0.%20Basics/Calculus/#calculus","text":"","title":"Calculus"},{"location":"0.%20Basics/Calculus/#vector-calculus","text":"Definition: Vector Field A vector field is a vector function \\(\\FF : \\RRR^n \\to \\RRR^n\\) . Vector fields can usefully be thought of as representing the velocity of a moving flow in space, and this physical intuition leads to notions such as the divergence (which represents the rate of change of volume of a flow) and curl (which represents the rotation of a flow). Line integral is the tool to use in the context of vector fields.","title":"Vector Calculus"},{"location":"0.%20Basics/PDEs/","text":"PDEs The Heat Equation The heat equation is the following PDE to model the temperature of a 1-D bar \\([0,x]\\) , \\[\\begin{align*} c(x)\\rho(x)\\frac{\\partial u}{\\partial t} = -\\frac{\\partial \\phi}{\\partial x} + Q(x,t) \\end{align*}\\] where \\(u(x,t)\\) : Temperature at any point \\(x\\) and any time \\(t\\) . \\(c(x) > 0\\) : Specific heat capacity at \\(x\\) , which is the amount of heat energy that takes to raise one unit of mass of the material by one unit of temperature. \\(\\rho(x)\\) : Mass density. \\(\\phi(x,t)\\) : Heat flux. If \\(\\phi > 0\\) then heat energy is flowing to the right; otherwise, it flows to the left. \\(Q(x,t)\\) : heat energy into or out from the system at \\(x\\) and \\(t\\) . By Fourier's law \\[\\begin{align*} \\phi(x,t) = -K_0(x)\\frac{\\partial u}{\\partial x} \\end{align*}\\] where \\(K_0(x)\\) is the thermal conductivity. Now the heat equation becomes: \\[\\begin{align*} c(x)\\rho(x)\\frac{\\partial u}{\\partial t} = -\\frac{\\partial}{\\partial x}\\left(K_0(x) \\frac{\\partial u}{\\partial x}\\right) + Q(x,t) \\end{align*}\\] Let's further assume the bar is uniform and define the thermal diffusivity as \\[\\begin{align*} k = \\frac{K_0}{c\\rho} \\end{align*}\\] The heat equation is then, \\[\\begin{align*} \\frac{\\partial u}{\\partial t} = k\\frac{\\partial^2 u}{\\partial x^2} + \\frac{Q(x,t)}{c\\rho} \\end{align*}\\]","title":"PDEs"},{"location":"0.%20Basics/PDEs/#pdes","text":"","title":"PDEs"},{"location":"0.%20Basics/PDEs/#the-heat-equation","text":"The heat equation is the following PDE to model the temperature of a 1-D bar \\([0,x]\\) , \\[\\begin{align*} c(x)\\rho(x)\\frac{\\partial u}{\\partial t} = -\\frac{\\partial \\phi}{\\partial x} + Q(x,t) \\end{align*}\\] where \\(u(x,t)\\) : Temperature at any point \\(x\\) and any time \\(t\\) . \\(c(x) > 0\\) : Specific heat capacity at \\(x\\) , which is the amount of heat energy that takes to raise one unit of mass of the material by one unit of temperature. \\(\\rho(x)\\) : Mass density. \\(\\phi(x,t)\\) : Heat flux. If \\(\\phi > 0\\) then heat energy is flowing to the right; otherwise, it flows to the left. \\(Q(x,t)\\) : heat energy into or out from the system at \\(x\\) and \\(t\\) . By Fourier's law \\[\\begin{align*} \\phi(x,t) = -K_0(x)\\frac{\\partial u}{\\partial x} \\end{align*}\\] where \\(K_0(x)\\) is the thermal conductivity. Now the heat equation becomes: \\[\\begin{align*} c(x)\\rho(x)\\frac{\\partial u}{\\partial t} = -\\frac{\\partial}{\\partial x}\\left(K_0(x) \\frac{\\partial u}{\\partial x}\\right) + Q(x,t) \\end{align*}\\] Let's further assume the bar is uniform and define the thermal diffusivity as \\[\\begin{align*} k = \\frac{K_0}{c\\rho} \\end{align*}\\] The heat equation is then, \\[\\begin{align*} \\frac{\\partial u}{\\partial t} = k\\frac{\\partial^2 u}{\\partial x^2} + \\frac{Q(x,t)}{c\\rho} \\end{align*}\\]","title":"The Heat Equation"},{"location":"1.%20Quant%20Developer/","text":"SOLID First introduced by Robert C. Martin in 2000, SOLID stands for: Single-responsibility principle: Every class should have only one responsibility. Open-closed principle: \"Software entitles should be open for extension, but closed for modification.\" Liskov substitution principle: \"Functions that use pointers or references to base classes must be able to use objects of derived classes without knowing it.\" Interface segregation principle: \"Many client-specific interfaces are better than one general-purpose interface.\" Dependency inversion principle: \"Depend upon abstractions, [not] concretions.\"","title":"SOLID"},{"location":"1.%20Quant%20Developer/#solid","text":"First introduced by Robert C. Martin in 2000, SOLID stands for: Single-responsibility principle: Every class should have only one responsibility. Open-closed principle: \"Software entitles should be open for extension, but closed for modification.\" Liskov substitution principle: \"Functions that use pointers or references to base classes must be able to use objects of derived classes without knowing it.\" Interface segregation principle: \"Many client-specific interfaces are better than one general-purpose interface.\" Dependency inversion principle: \"Depend upon abstractions, [not] concretions.\"","title":"SOLID"},{"location":"1.%20Quant%20Developer/1.%20Objects%20and%20Classes/1.%20Objects%20and%20Classes/","text":"Objects and Classes","title":"Objects and Classes"},{"location":"1.%20Quant%20Developer/1.%20Objects%20and%20Classes/1.%20Objects%20and%20Classes/#objects-and-classes","text":"","title":"Objects and Classes"},{"location":"1.%20Quant%20Developer/2.%20Inheritance/2.%20Inheritance/","text":"Objects and Classes","title":"Objects and Classes"},{"location":"1.%20Quant%20Developer/2.%20Inheritance/2.%20Inheritance/#objects-and-classes","text":"","title":"Objects and Classes"},{"location":"1.%20Quant%20Developer/3.%20Interfaces%2C%20Lambda%20Expressions%2C%20and%20Inner%20Classes/3.%20Interfaces%2C%20Lambda%20Expressions%2C%20and%20Inner%20Classes/","text":"Chapter 6. Interfaces, Lambda Expressions, and Inner Classes Anonymous Inner Class If you want to make only a single object of this class, you don't even need to give the class a name. Such a class is called an anonymous inner class . Anonymous classes cannot have a constructor (in C++ and Java) but can have a destructor (this is for C++; there's no destructor in Java, instead we have Garbage Collector in Java). Anonymous Inner Class Java 1 2 3 4 5 6 var obj = new SuperType ( construction parameters ) { // even though an anonymous class cannot have constructors, // you can provide an object initialization block { initialization } ... } The SuperType can be an interface, then the inner class implements that interface. It can also be a class, then the inner class extends that class. C++ There is no equivalent such a concept in C++, although the concept of anonymous class exists. To declare an anonymous class and its variables, just ignore the class name, as in: 1 2 3 4 5 6 class { public : void f () { std :: cout << \"I am an object of an anonymous class.\" << std :: endl ; } } obj1 , obj2 ; The closest equivalent to Java anonymous inner classes in C++ is to use a private class which implements the corresponding interface (but if the interface is a functional interface, then the closest equivalent is to replace the functional interface with a function pointer and the anonymous inner class with a lambda). See more here . Python In Python, you can use the type(name, bases, dict) builtin function to crate on the fly. For example: 1 2 3 4 5 class ParentClass : pass op = type ( \"ChildClass\" , ( ParentClass , object ), { \"foo\" : lambda self : print ( \"foo\" )}) op () . foo ()","title":"Chapter 6. Interfaces, Lambda Expressions, and Inner Classes"},{"location":"1.%20Quant%20Developer/3.%20Interfaces%2C%20Lambda%20Expressions%2C%20and%20Inner%20Classes/3.%20Interfaces%2C%20Lambda%20Expressions%2C%20and%20Inner%20Classes/#chapter-6-interfaces-lambda-expressions-and-inner-classes","text":"","title":"Chapter 6. Interfaces, Lambda Expressions, and Inner Classes"},{"location":"1.%20Quant%20Developer/3.%20Interfaces%2C%20Lambda%20Expressions%2C%20and%20Inner%20Classes/3.%20Interfaces%2C%20Lambda%20Expressions%2C%20and%20Inner%20Classes/#anonymous-inner-class","text":"If you want to make only a single object of this class, you don't even need to give the class a name. Such a class is called an anonymous inner class . Anonymous classes cannot have a constructor (in C++ and Java) but can have a destructor (this is for C++; there's no destructor in Java, instead we have Garbage Collector in Java). Anonymous Inner Class Java 1 2 3 4 5 6 var obj = new SuperType ( construction parameters ) { // even though an anonymous class cannot have constructors, // you can provide an object initialization block { initialization } ... } The SuperType can be an interface, then the inner class implements that interface. It can also be a class, then the inner class extends that class. C++ There is no equivalent such a concept in C++, although the concept of anonymous class exists. To declare an anonymous class and its variables, just ignore the class name, as in: 1 2 3 4 5 6 class { public : void f () { std :: cout << \"I am an object of an anonymous class.\" << std :: endl ; } } obj1 , obj2 ; The closest equivalent to Java anonymous inner classes in C++ is to use a private class which implements the corresponding interface (but if the interface is a functional interface, then the closest equivalent is to replace the functional interface with a function pointer and the anonymous inner class with a lambda). See more here . Python In Python, you can use the type(name, bases, dict) builtin function to crate on the fly. For example: 1 2 3 4 5 class ParentClass : pass op = type ( \"ChildClass\" , ( ParentClass , object ), { \"foo\" : lambda self : print ( \"foo\" )}) op () . foo ()","title":"Anonymous Inner Class"},{"location":"1.%20Quant%20Developer/4.%20Exceptions%2C%20Assertions%2C%20and%20Logging/4.%20Exceptions%2C%20Assertions%2C%20and%20Logging/","text":"Chapter 6. Interfaces, Lambda Expressions, and Inner Classes Anonymous Inner Class If you want to make only a single object of this class, you don't even need to give the class a name. Such a class is called an anonymous inner class . Anonymous classes cannot have a constructor (in C++ and Java) but can have a destructor (this is for C++; there's no destructor in Java, instead we have Garbage Collector in Java). Anonymous Inner Class Java 1 2 3 4 5 6 var obj = new SuperType ( construction parameters ) { // even though an anonymous class cannot have constructors, // you can provide an object initialization block { initialization } ... } The SuperType can be an interface, then the inner class implements that interface. It can also be a class, then the inner class extends that class. C++ There is no equivalent such a concept in C++, although the concept of anonymous class exists. To declare an anonymous class and its variables, just ignore the class name, as in: 1 2 3 4 5 6 class { public : void f () { std :: cout << \"I am an object of an anonymous class.\" << std :: endl ; } } obj1 , obj2 ; The closest equivalent to Java anonymous inner classes in C++ is to use a private class which implements the corresponding interface (but if the interface is a functional interface, then the closest equivalent is to replace the functional interface with a function pointer and the anonymous inner class with a lambda). See more here . Python In Python, you can use the type(name, bases, dict) builtin function to crate on the fly. For example: 1 2 3 4 5 class ParentClass : pass op = type ( \"ChildClass\" , ( ParentClass , object ), { \"foo\" : lambda self : print ( \"foo\" )}) op () . foo ()","title":"Chapter 6. Interfaces, Lambda Expressions, and Inner Classes"},{"location":"1.%20Quant%20Developer/4.%20Exceptions%2C%20Assertions%2C%20and%20Logging/4.%20Exceptions%2C%20Assertions%2C%20and%20Logging/#chapter-6-interfaces-lambda-expressions-and-inner-classes","text":"","title":"Chapter 6. Interfaces, Lambda Expressions, and Inner Classes"},{"location":"1.%20Quant%20Developer/4.%20Exceptions%2C%20Assertions%2C%20and%20Logging/4.%20Exceptions%2C%20Assertions%2C%20and%20Logging/#anonymous-inner-class","text":"If you want to make only a single object of this class, you don't even need to give the class a name. Such a class is called an anonymous inner class . Anonymous classes cannot have a constructor (in C++ and Java) but can have a destructor (this is for C++; there's no destructor in Java, instead we have Garbage Collector in Java). Anonymous Inner Class Java 1 2 3 4 5 6 var obj = new SuperType ( construction parameters ) { // even though an anonymous class cannot have constructors, // you can provide an object initialization block { initialization } ... } The SuperType can be an interface, then the inner class implements that interface. It can also be a class, then the inner class extends that class. C++ There is no equivalent such a concept in C++, although the concept of anonymous class exists. To declare an anonymous class and its variables, just ignore the class name, as in: 1 2 3 4 5 6 class { public : void f () { std :: cout << \"I am an object of an anonymous class.\" << std :: endl ; } } obj1 , obj2 ; The closest equivalent to Java anonymous inner classes in C++ is to use a private class which implements the corresponding interface (but if the interface is a functional interface, then the closest equivalent is to replace the functional interface with a function pointer and the anonymous inner class with a lambda). See more here . Python In Python, you can use the type(name, bases, dict) builtin function to crate on the fly. For example: 1 2 3 4 5 class ParentClass : pass op = type ( \"ChildClass\" , ( ParentClass , object ), { \"foo\" : lambda self : print ( \"foo\" )}) op () . foo ()","title":"Anonymous Inner Class"},{"location":"1.%20Quant%20Developer/5.%20Genereic%20Programming/5.%20Genereic%20Programming/","text":"Chapter 6. Interfaces, Lambda Expressions, and Inner Classes Anonymous Inner Class If you want to make only a single object of this class, you don't even need to give the class a name. Such a class is called an anonymous inner class . Anonymous classes cannot have a constructor (in C++ and Java) but can have a destructor (this is for C++; there's no destructor in Java, instead we have Garbage Collector in Java). Anonymous Inner Class Java 1 2 3 4 5 6 var obj = new SuperType ( construction parameters ) { // even though an anonymous class cannot have constructors, // you can provide an object initialization block { initialization } ... } The SuperType can be an interface, then the inner class implements that interface. It can also be a class, then the inner class extends that class. C++ There is no equivalent such a concept in C++, although the concept of anonymous class exists. To declare an anonymous class and its variables, just ignore the class name, as in: 1 2 3 4 5 6 class { public : void f () { std :: cout << \"I am an object of an anonymous class.\" << std :: endl ; } } obj1 , obj2 ; The closest equivalent to Java anonymous inner classes in C++ is to use a private class which implements the corresponding interface (but if the interface is a functional interface, then the closest equivalent is to replace the functional interface with a function pointer and the anonymous inner class with a lambda). See more here . Python In Python, you can use the type(name, bases, dict) builtin function to crate on the fly. For example: 1 2 3 4 5 class ParentClass : pass op = type ( \"ChildClass\" , ( ParentClass , object ), { \"foo\" : lambda self : print ( \"foo\" )}) op () . foo ()","title":"Chapter 6. Interfaces, Lambda Expressions, and Inner Classes"},{"location":"1.%20Quant%20Developer/5.%20Genereic%20Programming/5.%20Genereic%20Programming/#chapter-6-interfaces-lambda-expressions-and-inner-classes","text":"","title":"Chapter 6. Interfaces, Lambda Expressions, and Inner Classes"},{"location":"1.%20Quant%20Developer/5.%20Genereic%20Programming/5.%20Genereic%20Programming/#anonymous-inner-class","text":"If you want to make only a single object of this class, you don't even need to give the class a name. Such a class is called an anonymous inner class . Anonymous classes cannot have a constructor (in C++ and Java) but can have a destructor (this is for C++; there's no destructor in Java, instead we have Garbage Collector in Java). Anonymous Inner Class Java 1 2 3 4 5 6 var obj = new SuperType ( construction parameters ) { // even though an anonymous class cannot have constructors, // you can provide an object initialization block { initialization } ... } The SuperType can be an interface, then the inner class implements that interface. It can also be a class, then the inner class extends that class. C++ There is no equivalent such a concept in C++, although the concept of anonymous class exists. To declare an anonymous class and its variables, just ignore the class name, as in: 1 2 3 4 5 6 class { public : void f () { std :: cout << \"I am an object of an anonymous class.\" << std :: endl ; } } obj1 , obj2 ; The closest equivalent to Java anonymous inner classes in C++ is to use a private class which implements the corresponding interface (but if the interface is a functional interface, then the closest equivalent is to replace the functional interface with a function pointer and the anonymous inner class with a lambda). See more here . Python In Python, you can use the type(name, bases, dict) builtin function to crate on the fly. For example: 1 2 3 4 5 class ParentClass : pass op = type ( \"ChildClass\" , ( ParentClass , object ), { \"foo\" : lambda self : print ( \"foo\" )}) op () . foo ()","title":"Anonymous Inner Class"},{"location":"1.%20Quant%20Developer/6.%20Collections/6.%20Collections/","text":"Chapter 6. Interfaces, Lambda Expressions, and Inner Classes Anonymous Inner Class If you want to make only a single object of this class, you don't even need to give the class a name. Such a class is called an anonymous inner class . Anonymous classes cannot have a constructor (in C++ and Java) but can have a destructor (this is for C++; there's no destructor in Java, instead we have Garbage Collector in Java). Anonymous Inner Class Java 1 2 3 4 5 6 var obj = new SuperType ( construction parameters ) { // even though an anonymous class cannot have constructors, // you can provide an object initialization block { initialization } ... } The SuperType can be an interface, then the inner class implements that interface. It can also be a class, then the inner class extends that class. C++ There is no equivalent such a concept in C++, although the concept of anonymous class exists. To declare an anonymous class and its variables, just ignore the class name, as in: 1 2 3 4 5 6 class { public : void f () { std :: cout << \"I am an object of an anonymous class.\" << std :: endl ; } } obj1 , obj2 ; The closest equivalent to Java anonymous inner classes in C++ is to use a private class which implements the corresponding interface (but if the interface is a functional interface, then the closest equivalent is to replace the functional interface with a function pointer and the anonymous inner class with a lambda). See more here . Python In Python, you can use the type(name, bases, dict) builtin function to crate on the fly. For example: 1 2 3 4 5 class ParentClass : pass op = type ( \"ChildClass\" , ( ParentClass , object ), { \"foo\" : lambda self : print ( \"foo\" )}) op () . foo ()","title":"Chapter 6. Interfaces, Lambda Expressions, and Inner Classes"},{"location":"1.%20Quant%20Developer/6.%20Collections/6.%20Collections/#chapter-6-interfaces-lambda-expressions-and-inner-classes","text":"","title":"Chapter 6. Interfaces, Lambda Expressions, and Inner Classes"},{"location":"1.%20Quant%20Developer/6.%20Collections/6.%20Collections/#anonymous-inner-class","text":"If you want to make only a single object of this class, you don't even need to give the class a name. Such a class is called an anonymous inner class . Anonymous classes cannot have a constructor (in C++ and Java) but can have a destructor (this is for C++; there's no destructor in Java, instead we have Garbage Collector in Java). Anonymous Inner Class Java 1 2 3 4 5 6 var obj = new SuperType ( construction parameters ) { // even though an anonymous class cannot have constructors, // you can provide an object initialization block { initialization } ... } The SuperType can be an interface, then the inner class implements that interface. It can also be a class, then the inner class extends that class. C++ There is no equivalent such a concept in C++, although the concept of anonymous class exists. To declare an anonymous class and its variables, just ignore the class name, as in: 1 2 3 4 5 6 class { public : void f () { std :: cout << \"I am an object of an anonymous class.\" << std :: endl ; } } obj1 , obj2 ; The closest equivalent to Java anonymous inner classes in C++ is to use a private class which implements the corresponding interface (but if the interface is a functional interface, then the closest equivalent is to replace the functional interface with a function pointer and the anonymous inner class with a lambda). See more here . Python In Python, you can use the type(name, bases, dict) builtin function to crate on the fly. For example: 1 2 3 4 5 class ParentClass : pass op = type ( \"ChildClass\" , ( ParentClass , object ), { \"foo\" : lambda self : print ( \"foo\" )}) op () . foo ()","title":"Anonymous Inner Class"},{"location":"1.%20Quant%20Developer/7.%20Concurrency/7.%20Concurrency/","text":"Chapter 6. Interfaces, Lambda Expressions, and Inner Classes Anonymous Inner Class If you want to make only a single object of this class, you don't even need to give the class a name. Such a class is called an anonymous inner class . Anonymous classes cannot have a constructor (in C++ and Java) but can have a destructor (this is for C++; there's no destructor in Java, instead we have Garbage Collector in Java). Anonymous Inner Class Java 1 2 3 4 5 6 var obj = new SuperType ( construction parameters ) { // even though an anonymous class cannot have constructors, // you can provide an object initialization block { initialization } ... } The SuperType can be an interface, then the inner class implements that interface. It can also be a class, then the inner class extends that class. C++ There is no equivalent such a concept in C++, although the concept of anonymous class exists. To declare an anonymous class and its variables, just ignore the class name, as in: 1 2 3 4 5 6 class { public : void f () { std :: cout << \"I am an object of an anonymous class.\" << std :: endl ; } } obj1 , obj2 ; The closest equivalent to Java anonymous inner classes in C++ is to use a private class which implements the corresponding interface (but if the interface is a functional interface, then the closest equivalent is to replace the functional interface with a function pointer and the anonymous inner class with a lambda). See more here . Python In Python, you can use the type(name, bases, dict) builtin function to crate on the fly. For example: 1 2 3 4 5 class ParentClass : pass op = type ( \"ChildClass\" , ( ParentClass , object ), { \"foo\" : lambda self : print ( \"foo\" )}) op () . foo ()","title":"Chapter 6. Interfaces, Lambda Expressions, and Inner Classes"},{"location":"1.%20Quant%20Developer/7.%20Concurrency/7.%20Concurrency/#chapter-6-interfaces-lambda-expressions-and-inner-classes","text":"","title":"Chapter 6. Interfaces, Lambda Expressions, and Inner Classes"},{"location":"1.%20Quant%20Developer/7.%20Concurrency/7.%20Concurrency/#anonymous-inner-class","text":"If you want to make only a single object of this class, you don't even need to give the class a name. Such a class is called an anonymous inner class . Anonymous classes cannot have a constructor (in C++ and Java) but can have a destructor (this is for C++; there's no destructor in Java, instead we have Garbage Collector in Java). Anonymous Inner Class Java 1 2 3 4 5 6 var obj = new SuperType ( construction parameters ) { // even though an anonymous class cannot have constructors, // you can provide an object initialization block { initialization } ... } The SuperType can be an interface, then the inner class implements that interface. It can also be a class, then the inner class extends that class. C++ There is no equivalent such a concept in C++, although the concept of anonymous class exists. To declare an anonymous class and its variables, just ignore the class name, as in: 1 2 3 4 5 6 class { public : void f () { std :: cout << \"I am an object of an anonymous class.\" << std :: endl ; } } obj1 , obj2 ; The closest equivalent to Java anonymous inner classes in C++ is to use a private class which implements the corresponding interface (but if the interface is a functional interface, then the closest equivalent is to replace the functional interface with a function pointer and the anonymous inner class with a lambda). See more here . Python In Python, you can use the type(name, bases, dict) builtin function to crate on the fly. For example: 1 2 3 4 5 class ParentClass : pass op = type ( \"ChildClass\" , ( ParentClass , object ), { \"foo\" : lambda self : print ( \"foo\" )}) op () . foo ()","title":"Anonymous Inner Class"},{"location":"1.%20Quant%20Developer/8.%20Meta%20Programming/8.%20Meta%20Programming/","text":"Python Meta Programming There are five main meta programming techniques in Python: At load-time: - Operator overloading - Decorator - Metaclass - Descriptor and Property - Import hook At run-time: - compile - Monkey Patch and Hot Patch Import Hooks Whenever you use an import statement, it is equivalent to: 1 os = __import__ ( \"os\" ) First, it check sys.modules , a dict containing already-loaded modules, just in case we've already imported the requested module. Next, if sys.meta_path list is not empty, then every meta importer hook in it will be queried. Finally, it checks sys.path , a list containing filesystem paths for Python to search for potential modules. It is at the second step that we will be able to intercept. To do this, we'll need to crate a meta path finder , which has a single public method find_spec , and add it to sys.meta_path . 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 import importlib.abc import importlib.machinery class DependencyInjectorFinder ( importlib . abc . MetaPathFinder ): def __init__ ( self , loader ): # we'll write the loader in a minute, hang tight self . _loader = loader def find_spec ( self , fullname , path , target = None ): \"\"\"Attempt to locate the requested module fullname is the fully-qualified name of the module, path is set to __path__ for sub-modules/packages, or None otherwise. target can be a module object, but is unused in this example. \"\"\" if self . _loader . provides ( fullname ): return self . _gen_spec ( fullname ) def _gen_spec ( self , fullname ): spec = importlib . machinery . ModuleSpec ( fullname , self . _loader ) return spec # we'll also add it to sys.meta_path later If a meta path finder provides the requested module, then it should return an instance of the importlib.machinery.ModuleSpec class, which is a fairly simple affair with a small handful of attributes that lets Python's import machinery know what it needs to know to take the next steps in importing the module the user requested. For our purposes, we're interested in two attributes (the only required ones): ModuleSpec.name, which is the name of the requested module, and ModuleSpec.loader, which is the loader object that Python should use to actually load the module - you'll notice the self._loader lines above that reference a loader object, as well. A loader object is a very simple class with two required methods in Python: create_module , which takes a ModuleSpec as its sole argument and returns an object that Python will consider to be the new module, and exec_module , which takes the new module as its sole argument and executes it. 1 2 3 4 5 class Loader ( importlib . abc . Loader ): def create_module ( self , spec ): raise NotImplementedError def exec_module ( self , module ): raise NotImplementedError","title":"Python Meta Programming"},{"location":"1.%20Quant%20Developer/8.%20Meta%20Programming/8.%20Meta%20Programming/#python-meta-programming","text":"There are five main meta programming techniques in Python: At load-time: - Operator overloading - Decorator - Metaclass - Descriptor and Property - Import hook At run-time: - compile - Monkey Patch and Hot Patch","title":"Python Meta Programming"},{"location":"1.%20Quant%20Developer/8.%20Meta%20Programming/8.%20Meta%20Programming/#import-hooks","text":"Whenever you use an import statement, it is equivalent to: 1 os = __import__ ( \"os\" ) First, it check sys.modules , a dict containing already-loaded modules, just in case we've already imported the requested module. Next, if sys.meta_path list is not empty, then every meta importer hook in it will be queried. Finally, it checks sys.path , a list containing filesystem paths for Python to search for potential modules. It is at the second step that we will be able to intercept. To do this, we'll need to crate a meta path finder , which has a single public method find_spec , and add it to sys.meta_path . 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 import importlib.abc import importlib.machinery class DependencyInjectorFinder ( importlib . abc . MetaPathFinder ): def __init__ ( self , loader ): # we'll write the loader in a minute, hang tight self . _loader = loader def find_spec ( self , fullname , path , target = None ): \"\"\"Attempt to locate the requested module fullname is the fully-qualified name of the module, path is set to __path__ for sub-modules/packages, or None otherwise. target can be a module object, but is unused in this example. \"\"\" if self . _loader . provides ( fullname ): return self . _gen_spec ( fullname ) def _gen_spec ( self , fullname ): spec = importlib . machinery . ModuleSpec ( fullname , self . _loader ) return spec # we'll also add it to sys.meta_path later If a meta path finder provides the requested module, then it should return an instance of the importlib.machinery.ModuleSpec class, which is a fairly simple affair with a small handful of attributes that lets Python's import machinery know what it needs to know to take the next steps in importing the module the user requested. For our purposes, we're interested in two attributes (the only required ones): ModuleSpec.name, which is the name of the requested module, and ModuleSpec.loader, which is the loader object that Python should use to actually load the module - you'll notice the self._loader lines above that reference a loader object, as well. A loader object is a very simple class with two required methods in Python: create_module , which takes a ModuleSpec as its sole argument and returns an object that Python will consider to be the new module, and exec_module , which takes the new module as its sole argument and executes it. 1 2 3 4 5 class Loader ( importlib . abc . Loader ): def create_module ( self , spec ): raise NotImplementedError def exec_module ( self , module ): raise NotImplementedError","title":"Import Hooks"},{"location":"1.%20Quant%20Developer/Design%20Patterns/","text":"Design Patterns Interceptor 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 from functools import wraps def iterceptor ( func ): print ( 'this is executed at function definition time (def my_func)' ) @wraps ( func ) def wrapper ( * args , ** kwargs ): print ( 'this is executed before function call' ) result = func ( * args , ** kwargs ) print ( 'this is executed after function call' ) return result return wrapper @iterceptor def my_func ( n ): print ( 'this is my_func' ) print ( 'n =' , n ) my_func ( 4 ) Facade","title":"Design Patterns"},{"location":"1.%20Quant%20Developer/Design%20Patterns/#design-patterns","text":"","title":"Design Patterns"},{"location":"1.%20Quant%20Developer/Design%20Patterns/#interceptor","text":"1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 from functools import wraps def iterceptor ( func ): print ( 'this is executed at function definition time (def my_func)' ) @wraps ( func ) def wrapper ( * args , ** kwargs ): print ( 'this is executed before function call' ) result = func ( * args , ** kwargs ) print ( 'this is executed after function call' ) return result return wrapper @iterceptor def my_func ( n ): print ( 'this is my_func' ) print ( 'n =' , n ) my_func ( 4 )","title":"Interceptor"},{"location":"1.%20Quant%20Developer/Design%20Patterns/#facade","text":"","title":"Facade"},{"location":"2.%20Quant%20Researcher/Index/","text":"Kaggle","title":"Kaggle"},{"location":"2.%20Quant%20Researcher/Index/#kaggle","text":"","title":"Kaggle"},{"location":"2.%20Quant%20Researcher/Optimization/","text":"Introduction Software Engineering","title":"Introduction"},{"location":"2.%20Quant%20Researcher/Optimization/#introduction","text":"Software Engineering","title":"Introduction"},{"location":"3.%20Quant%20Trader/","text":"Introduction Option P&L Attributions Consider at time 0 that, the bank sells an option \\(P\\) and at the same time long \\(\\Delta\\) shares of the underlying stock \\(S\\) to setup a delta-hedged position: \\[\\begin{align} \\Pi = -P + \\Delta S \\end{align}\\] Important In a complete market where arbitrage is impossible, the following accounting equation should hold in its expectation at any time \\(t\\) : \\[\\begin{align} \\underbrace{\\Delta_t S_t}_{\\mbox{Asset}} = \\underbrace{0}_{\\mbox{Equity}} + \\underbrace{\\underbrace{P_t}_{\\mbox{liability to counter-party}} + \\underbrace{(-P_t + \\Delta_t S_t)}_{\\mbox{liability to money market}}}_{\\mbox{Liability}} \\end{align}\\] At time \\(0\\) all terms are zero. During the time period \\([t, t + dt]\\) the P&L of this portfolio, i.e., the bank's equity , becomes: \\[\\begin{align*} \\small{ \\underbrace{\\left(\\underbrace{qdt\\Delta S}_{\\mbox{proceeds from stock}} + \\underbrace{\\Delta dS}_{\\mbox{P&L of stock}}\\right)}_{\\mbox{Asset P&L}} - \\underbrace{\\left(\\underbrace{dP}_{\\mbox{P&L of option}} + \\underbrace{rdt(-P+\\Delta S)}_{\\mbox{interest paid}} \\right)}_{\\mbox{Liability P&L}} } \\end{align*}\\] where we have assumed that the risk-free rate in the money market is \\(r\\) . By assuming the option price only depends on time \\(t\\) and the stock price \\(S_t\\) and by Ito's lemma, we have \\[\\begin{align} dP = \\frac{\\partial P}{\\partial t}dt + \\frac{\\partial P}{\\partial S}dS + \\frac12 \\frac{\\partial^2 P}{\\partial S^2} (dS)^2 \\label{eq:dP} \\end{align}\\] Note Note that we have not specified the dynamics of \\(dS\\) . Plug in Equation \\(\\ref{eq:dP}\\) and delta hedge the position by setting dynamically \\[ \\Delta \\equiv \\frac{\\partial P}{\\partial S} \\] we obtain \\[ P\\&L = -\\left[\\frac{\\partial P}{\\partial t} -rP + (r - q) S\\frac{\\partial P}{\\partial S}\\right]dt - \\frac12 S^2\\frac{\\partial^2 P}{\\partial S^2} \\left(\\frac{dS}{S}\\right)^2 \\] Note The term \\(\\frac{dS}{S}\\) is called dollar gamma , because it has the same unit as the underlying stock. We know that at time \\(t\\) , all quantities of the above are observable, except for the term \\(\\left(\\frac{dS}{S}\\right)\\) ; and we know that in a complete market, the expectation of the P&L has to be zero. Thus, if we denote \\[ \\hat{\\sigma}^2 dt \\equiv \\EEE\\left[\\left(\\frac{dS}{S}\\right)^2\\right] \\] where the latent variable \\(\\hat{\\sigma}\\) measures the volatility of \\(S\\) during time interval \\([t, t + dt]\\) , we obtain, \\[ \\EEE[P\\&L] = -\\left[\\frac{\\partial S}{\\partial t} -rP + (r-q)S\\frac{\\partial P}{\\partial S} \\right]dt - \\frac12 S^2\\frac{\\partial^2 P}{\\partial S^2} \\hat{\\sigma}^2 dt \\equiv 0 \\] which implies \\[ \\frac{\\partial S}{\\partial t} -rP + (r-q)S\\frac{\\partial P}{\\partial S} = - \\frac12 S^2\\frac{\\partial^2 C}{\\partial S^2} \\hat{\\sigma}^2 \\] and finally, Important \\[\\begin{align} P\\&L = \\frac12 S^2\\frac{\\partial^2 P}{\\partial S^2} \\left[\\hat{\\sigma}^2 dt - \\left(\\frac{dS}{S}\\right)^2\\right] \\end{align}\\] The P&L of the delta-hedged position comes from the difference between the implied variance and the realized variance, weighted by the dollar gamma.","title":"Introduction"},{"location":"3.%20Quant%20Trader/#introduction","text":"","title":"Introduction"},{"location":"3.%20Quant%20Trader/#option-pl-attributions","text":"Consider at time 0 that, the bank sells an option \\(P\\) and at the same time long \\(\\Delta\\) shares of the underlying stock \\(S\\) to setup a delta-hedged position: \\[\\begin{align} \\Pi = -P + \\Delta S \\end{align}\\] Important In a complete market where arbitrage is impossible, the following accounting equation should hold in its expectation at any time \\(t\\) : \\[\\begin{align} \\underbrace{\\Delta_t S_t}_{\\mbox{Asset}} = \\underbrace{0}_{\\mbox{Equity}} + \\underbrace{\\underbrace{P_t}_{\\mbox{liability to counter-party}} + \\underbrace{(-P_t + \\Delta_t S_t)}_{\\mbox{liability to money market}}}_{\\mbox{Liability}} \\end{align}\\] At time \\(0\\) all terms are zero. During the time period \\([t, t + dt]\\) the P&L of this portfolio, i.e., the bank's equity , becomes: \\[\\begin{align*} \\small{ \\underbrace{\\left(\\underbrace{qdt\\Delta S}_{\\mbox{proceeds from stock}} + \\underbrace{\\Delta dS}_{\\mbox{P&L of stock}}\\right)}_{\\mbox{Asset P&L}} - \\underbrace{\\left(\\underbrace{dP}_{\\mbox{P&L of option}} + \\underbrace{rdt(-P+\\Delta S)}_{\\mbox{interest paid}} \\right)}_{\\mbox{Liability P&L}} } \\end{align*}\\] where we have assumed that the risk-free rate in the money market is \\(r\\) . By assuming the option price only depends on time \\(t\\) and the stock price \\(S_t\\) and by Ito's lemma, we have \\[\\begin{align} dP = \\frac{\\partial P}{\\partial t}dt + \\frac{\\partial P}{\\partial S}dS + \\frac12 \\frac{\\partial^2 P}{\\partial S^2} (dS)^2 \\label{eq:dP} \\end{align}\\] Note Note that we have not specified the dynamics of \\(dS\\) . Plug in Equation \\(\\ref{eq:dP}\\) and delta hedge the position by setting dynamically \\[ \\Delta \\equiv \\frac{\\partial P}{\\partial S} \\] we obtain \\[ P\\&L = -\\left[\\frac{\\partial P}{\\partial t} -rP + (r - q) S\\frac{\\partial P}{\\partial S}\\right]dt - \\frac12 S^2\\frac{\\partial^2 P}{\\partial S^2} \\left(\\frac{dS}{S}\\right)^2 \\] Note The term \\(\\frac{dS}{S}\\) is called dollar gamma , because it has the same unit as the underlying stock. We know that at time \\(t\\) , all quantities of the above are observable, except for the term \\(\\left(\\frac{dS}{S}\\right)\\) ; and we know that in a complete market, the expectation of the P&L has to be zero. Thus, if we denote \\[ \\hat{\\sigma}^2 dt \\equiv \\EEE\\left[\\left(\\frac{dS}{S}\\right)^2\\right] \\] where the latent variable \\(\\hat{\\sigma}\\) measures the volatility of \\(S\\) during time interval \\([t, t + dt]\\) , we obtain, \\[ \\EEE[P\\&L] = -\\left[\\frac{\\partial S}{\\partial t} -rP + (r-q)S\\frac{\\partial P}{\\partial S} \\right]dt - \\frac12 S^2\\frac{\\partial^2 P}{\\partial S^2} \\hat{\\sigma}^2 dt \\equiv 0 \\] which implies \\[ \\frac{\\partial S}{\\partial t} -rP + (r-q)S\\frac{\\partial P}{\\partial S} = - \\frac12 S^2\\frac{\\partial^2 C}{\\partial S^2} \\hat{\\sigma}^2 \\] and finally, Important \\[\\begin{align} P\\&L = \\frac12 S^2\\frac{\\partial^2 P}{\\partial S^2} \\left[\\hat{\\sigma}^2 dt - \\left(\\frac{dS}{S}\\right)^2\\right] \\end{align}\\] The P&L of the delta-hedged position comes from the difference between the implied variance and the realized variance, weighted by the dollar gamma.","title":"Option P&amp;L Attributions"},{"location":"LeetCode%20%26%20Kaggle/0.%20Index/","text":"Introduction Google C++ Style Guide OI Wiki \u6d1b\u8c37 \u7a0b\u5e8f\u8bbe\u8ba1\u7ade\u8d5b\u8fdb\u9636\u8bad\u7ec3\u6307\u5357 labuladong\u7b97\u6cd5\u5c0f\u6284","title":"Introduction"},{"location":"LeetCode%20%26%20Kaggle/0.%20Index/#introduction","text":"Google C++ Style Guide OI Wiki \u6d1b\u8c37 \u7a0b\u5e8f\u8bbe\u8ba1\u7ade\u8d5b\u8fdb\u9636\u8bad\u7ec3\u6307\u5357 labuladong\u7b97\u6cd5\u5c0f\u6284","title":"Introduction"},{"location":"LeetCode%20%26%20Kaggle/LeetCode/Adhoc/","text":"Adhoc (1) Introduction Adhoc problems. Problems (0, 1, 0) LC73. Set Matrix Zeroes (Medium) LC73. Set Matrix Zeroes (Medium) Info LC73. Set Matrix Zeroes (Medium) Algorithm: Adhoc Time Complexity: \\(O(n^2)\\) Space Complexity: \\(O(1)\\) Solution This is an Adhoc problem. Adhoc \\(O(n^2)\\) Python 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 class Solution : def setZeroes ( self , matrix : List [ List [ int ]]) -> None : \"\"\" Do not return anything, modify matrix in-place instead. \"\"\" # pre-processing to check the first row and the first column firstRowHasZero = any ([ matrix [ 0 ][ j ] == 0 for j in range ( len ( matrix [ 0 ]))]) firstColHasZero = any ([ matrix [ i ][ 0 ] == 0 for i in range ( len ( matrix ))]) # KEY: check each element and record the results in the first row and the first column for i in range ( len ( matrix )): for j in range ( len ( matrix [ 0 ])): if matrix [ i ][ j ] == 0 : matrix [ i ][ 0 ] = matrix [ 0 ][ j ] = 0 # sweep for i in range ( 1 , len ( matrix )): # starts from 1, not 0 if matrix [ i ][ 0 ] == 0 : for j in range ( len ( matrix [ 0 ])): matrix [ i ][ j ] = 0 for j in range ( 1 , len ( matrix [ 0 ])): # starts from 1, not 0 if matrix [ 0 ][ j ] == 0 : for i in range ( len ( matrix )): matrix [ i ][ j ] = 0 # post-processing if firstColHasZero : for i in range ( len ( matrix )): matrix [ i ][ 0 ] = 0 if firstRowHasZero : for j in range ( len ( matrix [ 0 ])): matrix [ 0 ][ j ] = 0","title":"Adhoc (1)"},{"location":"LeetCode%20%26%20Kaggle/LeetCode/Adhoc/#adhoc-1","text":"","title":"Adhoc (1)"},{"location":"LeetCode%20%26%20Kaggle/LeetCode/Adhoc/#introduction","text":"Adhoc problems.","title":"Introduction"},{"location":"LeetCode%20%26%20Kaggle/LeetCode/Adhoc/#problems-0-1-0","text":"","title":"Problems (0, 1, 0)"},{"location":"LeetCode%20%26%20Kaggle/LeetCode/Adhoc/#lc73-set-matrix-zeroes-medium","text":"LC73. Set Matrix Zeroes (Medium) Info LC73. Set Matrix Zeroes (Medium) Algorithm: Adhoc Time Complexity: \\(O(n^2)\\) Space Complexity: \\(O(1)\\) Solution This is an Adhoc problem. Adhoc \\(O(n^2)\\) Python 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 class Solution : def setZeroes ( self , matrix : List [ List [ int ]]) -> None : \"\"\" Do not return anything, modify matrix in-place instead. \"\"\" # pre-processing to check the first row and the first column firstRowHasZero = any ([ matrix [ 0 ][ j ] == 0 for j in range ( len ( matrix [ 0 ]))]) firstColHasZero = any ([ matrix [ i ][ 0 ] == 0 for i in range ( len ( matrix ))]) # KEY: check each element and record the results in the first row and the first column for i in range ( len ( matrix )): for j in range ( len ( matrix [ 0 ])): if matrix [ i ][ j ] == 0 : matrix [ i ][ 0 ] = matrix [ 0 ][ j ] = 0 # sweep for i in range ( 1 , len ( matrix )): # starts from 1, not 0 if matrix [ i ][ 0 ] == 0 : for j in range ( len ( matrix [ 0 ])): matrix [ i ][ j ] = 0 for j in range ( 1 , len ( matrix [ 0 ])): # starts from 1, not 0 if matrix [ 0 ][ j ] == 0 : for i in range ( len ( matrix )): matrix [ i ][ j ] = 0 # post-processing if firstColHasZero : for i in range ( len ( matrix )): matrix [ i ][ 0 ] = 0 if firstRowHasZero : for j in range ( len ( matrix [ 0 ])): matrix [ 0 ][ j ] = 0","title":"LC73. Set Matrix Zeroes (Medium)"},{"location":"LeetCode%20%26%20Kaggle/LeetCode/Binary%20Search/","text":"Binary Search (3) Introduction Binary search is an algorithm that finds a target number in a sorted array in \\(O(\\log n)\\) time. Python 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 def binarySearch ( arr , target ): left , right = 0 , len ( arr ) - 1 while left <= right : mid = ( left + right ) // 2 if target == arr [ mid ]: return mid elif target < arr [ mid ]: right = mid - 1 else : left = mid + 1 return - 1 arr = [ 1 , 2 , 3 , 4 , 5 ] for n in range ( 0 , 7 ): print ( f ' { n } : { binarySearch ( arr , n ) } ' ) C++ 1 2 3 int binarySearch () { } Java 1 Problems (0, 3, 0) LC704. Binary Search (Easy) LC704. Binary Search (Easy) Info LC704. Binary Search (Easy) Algorithm: Binary Search Time Complexity: \\(O(\\log n)\\) Space Complexity: \\(O(1)\\) Solution This is a standard binary search problem. Binary Search O(n) Python 1 2 3 4 5 6 7 8 9 10 11 12 13 class Solution : def search ( self , nums : List [ int ], target : int ) -> int : left , right = 0 , len ( nums ) - 1 while left <= right : mid = ( left + right ) // 2 if target == nums [ mid ]: return mid elif target < nums [ mid ]: right = mid - 1 else : left = mid + 1 return - 1 LC1011. Capacity To Ship Packages Within D Days (Medium) LC1011. Capacity To Ship Packages Within D Days (Medium) Info LC1011. Capacity To Ship Packages Within D Days (Medium) Algorithm: Binary Search Time Complexity: \\(O(n\\log(S))\\) , where \\(S\\) is the sum of all weights. Space Complexity: \\(O(1)\\) Solution Binary search for the \\(\\mbox{capacity} \\in [max(weights), sum(weights)]\\) . For each of these \\(O(\\log n)\\) capacity, it costs \\(O(n)\\) to check if the plan can be delivered. Total cost is thus \\(O(n \\log n)\\) . Binary Search \\(O(n\\log(S))\\) Python 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 class Solution : def canDeliver ( self , weights , capacity , days ) -> bool : i = 0 for d in range ( days ): load = 0 while load <= capacity and i < len ( weights ): load += weights [ i ] i += 1 if load > capacity : load -= weights [ i - 1 ] i -= 1 elif i >= len ( weights ): return True return False def shipWithinDays ( self , weights : List [ int ], days : int ) -> int : minCap , maxCap = max ( weights ), sum ( weights ) while minCap <= maxCap : capacity = ( minCap + maxCap ) // 2 if self . canDeliver ( weights , capacity , days ): maxCap = capacity - 1 else : minCap = capacity + 1 return minCap LC1642. Furthest Building You Can Reach (Medium) LC1642. Furthest Building You Can Reach (Medium) Info 1642. Furthest Building You Can Reach (Medium) Algorithm: Binary Search Time Complexity: \\(O(n\\log n)\\) Space Complexity: \\(O(1)\\) Solution Binary search to propose the furthest building you try to reach, which costs \\(O(\\log n)\\) . Within each proposal, it takes \\(O(n)\\) to check if you are indeed able to finish. Total cost is thus \\(O(n \\log n)\\) . Binary Search \\(O(n\\log n)\\) Python 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 class Solution : def canFinish ( self , heights , bricks , ladders ) -> bool : steps = sorted ([ heights [ i ] - heights [ i - 1 ] for i in range ( 1 , len ( heights )) if heights [ i ] - heights [ i - 1 ] > 0 ]) if not steps : return True if ladders == 0 : return bricks >= sum ( steps ) return bricks >= sum ( steps [: - ladders ]) def furthestBuilding ( self , heights : List [ int ], bricks : int , ladders : int ) -> int : left , right = 0 , len ( heights ) - 1 while left <= right : mid = ( left + right ) // 2 if self . canFinish ( heights [: mid + 1 ], bricks , ladders ): left = mid + 1 else : right = mid - 1 return max ( 0 , right ) LC34. Find First and Last Position of Element in Sorted Array (Medium) LC34. Find First and Last Position of Element in Sorted Array (Medium) Info LC34. Find First and Last Position of Element in Sorted Array (Medium) Algorithm: Binary Search Time Complexity: \\(O(\\log n)\\) Space Complexity: \\(O(1)\\) Solution Main Method O(n) Python 1","title":"Binary Search (3)"},{"location":"LeetCode%20%26%20Kaggle/LeetCode/Binary%20Search/#binary-search-3","text":"","title":"Binary Search (3)"},{"location":"LeetCode%20%26%20Kaggle/LeetCode/Binary%20Search/#introduction","text":"Binary search is an algorithm that finds a target number in a sorted array in \\(O(\\log n)\\) time. Python 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 def binarySearch ( arr , target ): left , right = 0 , len ( arr ) - 1 while left <= right : mid = ( left + right ) // 2 if target == arr [ mid ]: return mid elif target < arr [ mid ]: right = mid - 1 else : left = mid + 1 return - 1 arr = [ 1 , 2 , 3 , 4 , 5 ] for n in range ( 0 , 7 ): print ( f ' { n } : { binarySearch ( arr , n ) } ' ) C++ 1 2 3 int binarySearch () { } Java 1","title":"Introduction"},{"location":"LeetCode%20%26%20Kaggle/LeetCode/Binary%20Search/#problems-0-3-0","text":"","title":"Problems (0, 3, 0)"},{"location":"LeetCode%20%26%20Kaggle/LeetCode/Binary%20Search/#lc704-binary-search-easy","text":"LC704. Binary Search (Easy) Info LC704. Binary Search (Easy) Algorithm: Binary Search Time Complexity: \\(O(\\log n)\\) Space Complexity: \\(O(1)\\) Solution This is a standard binary search problem. Binary Search O(n) Python 1 2 3 4 5 6 7 8 9 10 11 12 13 class Solution : def search ( self , nums : List [ int ], target : int ) -> int : left , right = 0 , len ( nums ) - 1 while left <= right : mid = ( left + right ) // 2 if target == nums [ mid ]: return mid elif target < nums [ mid ]: right = mid - 1 else : left = mid + 1 return - 1","title":"LC704. Binary Search (Easy)"},{"location":"LeetCode%20%26%20Kaggle/LeetCode/Binary%20Search/#lc1011-capacity-to-ship-packages-within-d-days-medium","text":"LC1011. Capacity To Ship Packages Within D Days (Medium) Info LC1011. Capacity To Ship Packages Within D Days (Medium) Algorithm: Binary Search Time Complexity: \\(O(n\\log(S))\\) , where \\(S\\) is the sum of all weights. Space Complexity: \\(O(1)\\) Solution Binary search for the \\(\\mbox{capacity} \\in [max(weights), sum(weights)]\\) . For each of these \\(O(\\log n)\\) capacity, it costs \\(O(n)\\) to check if the plan can be delivered. Total cost is thus \\(O(n \\log n)\\) . Binary Search \\(O(n\\log(S))\\) Python 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 class Solution : def canDeliver ( self , weights , capacity , days ) -> bool : i = 0 for d in range ( days ): load = 0 while load <= capacity and i < len ( weights ): load += weights [ i ] i += 1 if load > capacity : load -= weights [ i - 1 ] i -= 1 elif i >= len ( weights ): return True return False def shipWithinDays ( self , weights : List [ int ], days : int ) -> int : minCap , maxCap = max ( weights ), sum ( weights ) while minCap <= maxCap : capacity = ( minCap + maxCap ) // 2 if self . canDeliver ( weights , capacity , days ): maxCap = capacity - 1 else : minCap = capacity + 1 return minCap","title":"LC1011. Capacity To Ship Packages Within D Days (Medium)"},{"location":"LeetCode%20%26%20Kaggle/LeetCode/Binary%20Search/#lc1642-furthest-building-you-can-reach-medium","text":"LC1642. Furthest Building You Can Reach (Medium) Info 1642. Furthest Building You Can Reach (Medium) Algorithm: Binary Search Time Complexity: \\(O(n\\log n)\\) Space Complexity: \\(O(1)\\) Solution Binary search to propose the furthest building you try to reach, which costs \\(O(\\log n)\\) . Within each proposal, it takes \\(O(n)\\) to check if you are indeed able to finish. Total cost is thus \\(O(n \\log n)\\) . Binary Search \\(O(n\\log n)\\) Python 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 class Solution : def canFinish ( self , heights , bricks , ladders ) -> bool : steps = sorted ([ heights [ i ] - heights [ i - 1 ] for i in range ( 1 , len ( heights )) if heights [ i ] - heights [ i - 1 ] > 0 ]) if not steps : return True if ladders == 0 : return bricks >= sum ( steps ) return bricks >= sum ( steps [: - ladders ]) def furthestBuilding ( self , heights : List [ int ], bricks : int , ladders : int ) -> int : left , right = 0 , len ( heights ) - 1 while left <= right : mid = ( left + right ) // 2 if self . canFinish ( heights [: mid + 1 ], bricks , ladders ): left = mid + 1 else : right = mid - 1 return max ( 0 , right )","title":"LC1642. Furthest Building You Can Reach (Medium)"},{"location":"LeetCode%20%26%20Kaggle/LeetCode/Binary%20Search/#lc34-find-first-and-last-position-of-element-in-sorted-array-medium","text":"LC34. Find First and Last Position of Element in Sorted Array (Medium) Info LC34. Find First and Last Position of Element in Sorted Array (Medium) Algorithm: Binary Search Time Complexity: \\(O(\\log n)\\) Space Complexity: \\(O(1)\\) Solution Main Method O(n) Python 1","title":"LC34. Find First and Last Position of Element in Sorted Array (Medium)"},{"location":"LeetCode%20%26%20Kaggle/LeetCode/Heap/","text":"Heap (1) Introduction Heap. Problems (0, 1, 0) LC659. Split Array into Consecutive Subsequences (Medium) LC659. Split Array into Consecutive Subsequences (Medium) Info LC659. Split Array into Consecutive Subsequences (Medium) Algorithm: Heap Time Complexity: Space Complexity: Solution Adhoc \\(O(n^2)\\) Python 1","title":"Heap (1)"},{"location":"LeetCode%20%26%20Kaggle/LeetCode/Heap/#heap-1","text":"","title":"Heap (1)"},{"location":"LeetCode%20%26%20Kaggle/LeetCode/Heap/#introduction","text":"Heap.","title":"Introduction"},{"location":"LeetCode%20%26%20Kaggle/LeetCode/Heap/#problems-0-1-0","text":"","title":"Problems (0, 1, 0)"},{"location":"LeetCode%20%26%20Kaggle/LeetCode/Heap/#lc659-split-array-into-consecutive-subsequences-medium","text":"LC659. Split Array into Consecutive Subsequences (Medium) Info LC659. Split Array into Consecutive Subsequences (Medium) Algorithm: Heap Time Complexity: Space Complexity: Solution Adhoc \\(O(n^2)\\) Python 1","title":"LC659. Split Array into Consecutive Subsequences (Medium)"},{"location":"LeetCode%20%26%20Kaggle/LeetCode/Monotonic%20Stack/","text":"Monotonic Stack (0) Introduction Monotonic stack is a data structure that is able to find the nearest event (not the furthest ) for each of the \\(n\\) elements in an array of size \\(n\\) in \\(O(n)\\) time and \\(O(1)\\) space. Python 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 # # Monotonic stack to find the next bigger number. # def monotonicStack ( arr ): firstHigherValue = [ '#' ] * len ( arr ) stack = [] for i , n in enumerate ( arr ): while stack and n > stack [ - 1 ][ 1 ]: idx , value = stack . pop () # do something with (idx, value) firstHigherValue [ idx ] = n stack . append (( i , n )) return firstHigherValue arr = [ 1 , 3 , 4 , 6 , 2 , 1 , 4 , 5 ] print ( monotonicStack ( arr )) C++ 1 2 3 int binarySearch () { } Java 1 Problems (0, 0, 0)","title":"Monotonic Stack (0)"},{"location":"LeetCode%20%26%20Kaggle/LeetCode/Monotonic%20Stack/#monotonic-stack-0","text":"","title":"Monotonic Stack (0)"},{"location":"LeetCode%20%26%20Kaggle/LeetCode/Monotonic%20Stack/#introduction","text":"Monotonic stack is a data structure that is able to find the nearest event (not the furthest ) for each of the \\(n\\) elements in an array of size \\(n\\) in \\(O(n)\\) time and \\(O(1)\\) space. Python 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 # # Monotonic stack to find the next bigger number. # def monotonicStack ( arr ): firstHigherValue = [ '#' ] * len ( arr ) stack = [] for i , n in enumerate ( arr ): while stack and n > stack [ - 1 ][ 1 ]: idx , value = stack . pop () # do something with (idx, value) firstHigherValue [ idx ] = n stack . append (( i , n )) return firstHigherValue arr = [ 1 , 3 , 4 , 6 , 2 , 1 , 4 , 5 ] print ( monotonicStack ( arr )) C++ 1 2 3 int binarySearch () { } Java 1","title":"Introduction"},{"location":"LeetCode%20%26%20Kaggle/LeetCode/Monotonic%20Stack/#problems-0-0-0","text":"","title":"Problems (0, 0, 0)"},{"location":"LeetCode%20%26%20Kaggle/LeetCode/Tree/","text":"Tree (2) Introduction Problems (0, 2, 0) LC654. Maximum Binary Tree (Medium) LC654. Maximum Binary Tree (Medium) Info LC654. Maximum Binary Tree (Medium) Algorithm: DFS (Recursion) Time Complexity: \\(O(n)\\) Space Complexity: \\(O(1)\\) Solution This is a standard DFS (Recursion) problem. DFS O(n) Python 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 class Solution : def constructMaximumBinaryTree ( self , nums : List [ int ]) -> TreeNode : if not len ( nums ): return None maxIdx , maxN = 0 , nums [ 0 ] for i , n in enumerate ( nums ): if n > maxN : maxIdx = i maxN = n left = self . constructMaximumBinaryTree ( nums [: maxIdx ]) right = self . constructMaximumBinaryTree ( nums [ maxIdx + 1 :]) return TreeNode ( maxN , left , right ) LC1519. Number of Nodes in the Sub-Tree With the Same Label (Medium) LC1519. Number of Nodes in the Sub-Tree With the Same Label (Medium) Info LC1519. Number of Nodes in the Sub-Tree With the Same Label (Medium) Algorithm: Time Complexity: Space Complexity: Solution DFS O(n) Python 1","title":"Tree (2)"},{"location":"LeetCode%20%26%20Kaggle/LeetCode/Tree/#tree-2","text":"","title":"Tree (2)"},{"location":"LeetCode%20%26%20Kaggle/LeetCode/Tree/#introduction","text":"","title":"Introduction"},{"location":"LeetCode%20%26%20Kaggle/LeetCode/Tree/#problems-0-2-0","text":"","title":"Problems (0, 2, 0)"},{"location":"LeetCode%20%26%20Kaggle/LeetCode/Tree/#lc654-maximum-binary-tree-medium","text":"LC654. Maximum Binary Tree (Medium) Info LC654. Maximum Binary Tree (Medium) Algorithm: DFS (Recursion) Time Complexity: \\(O(n)\\) Space Complexity: \\(O(1)\\) Solution This is a standard DFS (Recursion) problem. DFS O(n) Python 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 class Solution : def constructMaximumBinaryTree ( self , nums : List [ int ]) -> TreeNode : if not len ( nums ): return None maxIdx , maxN = 0 , nums [ 0 ] for i , n in enumerate ( nums ): if n > maxN : maxIdx = i maxN = n left = self . constructMaximumBinaryTree ( nums [: maxIdx ]) right = self . constructMaximumBinaryTree ( nums [ maxIdx + 1 :]) return TreeNode ( maxN , left , right )","title":"LC654. Maximum Binary Tree (Medium)"},{"location":"LeetCode%20%26%20Kaggle/LeetCode/Tree/#lc1519-number-of-nodes-in-the-sub-tree-with-the-same-label-medium","text":"LC1519. Number of Nodes in the Sub-Tree With the Same Label (Medium) Info LC1519. Number of Nodes in the Sub-Tree With the Same Label (Medium) Algorithm: Time Complexity: Space Complexity: Solution DFS O(n) Python 1","title":"LC1519. Number of Nodes in the Sub-Tree With the Same Label (Medium)"},{"location":"Trading%20Strategies/Algorithmic%20Trading/","text":"Algorithmic Trading The IEX Signal The Evolution of the Crumbling Quote Signal In 1971, the Financial Industry Regulatory Authority (FINRA), created a revolutionary exchange called the National Association of Securities Dealers Automated Quotations (NASDAQ), which was the world's first electronic stock market. Today, algorithmic trading represents over two thirds of all market transactions. There are two main strategies in algorithmic trading: statistical arbitrage and latency arbitrage . Statistical arbitrage derives its advantage from the strength of its models while latency arbitrage derives its advantage from its speed . Statistical arbitrage is generally justified to be able to correct market mispricings and make the market more efficient. On the contrary, latency arbitrage is ethically questionable and debateable as it essentially is to forerun other market participants. For example, there are three well-known malicious strategies: Predatory Trading Predatory trading is the HFT equivalent of the illegal practice of front-running. For example, if a broker receives an order from a client to buy 100,000 shares of security S at $20.00, he may 1) buy security S at $20.00 and keep it in his personal account, 2) execute his client's order, and 3) sell the shares in his personal account after the price has been driven up. This is unethical because, first, the trader is trading using non-public information; and secondly, he is negatively impacting his client's order via slippage. For example, there are four nearby exchanges in New York: BATS, Diret Edge, NASDAQ, and the NYSE. The difference between arriving at the first exchange, BATS, and the last exchange, NYSE, is about 2 milliseconds. However, HFT firms can travel among all these exchanges in as little as 476 microseconds. Thus, the HFT firm can buy all the shares in the market and sell it at a higher price to the buyer. Stop-Loss Tripping Suppose the HFT firm pays its broker to have access to their order books. In particular, if we know that there are stop loss orders at $40.00, $37.50, and $36.00. We can short the stock to trigger $40, can pressure the stock to a flash-crash, then we cover our short positions possibly at $36.00 and take the profit. Order Spoofing This strategy involves submitting disingenuous orders to trick other traders. The HFT firm places a large amount of overpriced buying orders, and at the same time has had bullish option positions. When other slower participants have created illustrations for themselves that the stock prices are going up and followed by placing large amounts of reasonablely higher buying orders, the HFT firm would withdraw their buying orders and gain profit through the bullish option positions. In September 2016, a new exchange called Investors Exchange (IEX) received approval from the SEC and will be the first transparent exchange where malicious latency arbitrage strategies are no longer possible.","title":"Algorithmic Trading"},{"location":"Trading%20Strategies/Algorithmic%20Trading/#algorithmic-trading","text":"The IEX Signal The Evolution of the Crumbling Quote Signal In 1971, the Financial Industry Regulatory Authority (FINRA), created a revolutionary exchange called the National Association of Securities Dealers Automated Quotations (NASDAQ), which was the world's first electronic stock market. Today, algorithmic trading represents over two thirds of all market transactions. There are two main strategies in algorithmic trading: statistical arbitrage and latency arbitrage . Statistical arbitrage derives its advantage from the strength of its models while latency arbitrage derives its advantage from its speed . Statistical arbitrage is generally justified to be able to correct market mispricings and make the market more efficient. On the contrary, latency arbitrage is ethically questionable and debateable as it essentially is to forerun other market participants. For example, there are three well-known malicious strategies:","title":"Algorithmic Trading"},{"location":"Trading%20Strategies/Algorithmic%20Trading/#predatory-trading","text":"Predatory trading is the HFT equivalent of the illegal practice of front-running. For example, if a broker receives an order from a client to buy 100,000 shares of security S at $20.00, he may 1) buy security S at $20.00 and keep it in his personal account, 2) execute his client's order, and 3) sell the shares in his personal account after the price has been driven up. This is unethical because, first, the trader is trading using non-public information; and secondly, he is negatively impacting his client's order via slippage. For example, there are four nearby exchanges in New York: BATS, Diret Edge, NASDAQ, and the NYSE. The difference between arriving at the first exchange, BATS, and the last exchange, NYSE, is about 2 milliseconds. However, HFT firms can travel among all these exchanges in as little as 476 microseconds. Thus, the HFT firm can buy all the shares in the market and sell it at a higher price to the buyer.","title":"Predatory Trading"},{"location":"Trading%20Strategies/Algorithmic%20Trading/#stop-loss-tripping","text":"Suppose the HFT firm pays its broker to have access to their order books. In particular, if we know that there are stop loss orders at $40.00, $37.50, and $36.00. We can short the stock to trigger $40, can pressure the stock to a flash-crash, then we cover our short positions possibly at $36.00 and take the profit.","title":"Stop-Loss Tripping"},{"location":"Trading%20Strategies/Algorithmic%20Trading/#order-spoofing","text":"This strategy involves submitting disingenuous orders to trick other traders. The HFT firm places a large amount of overpriced buying orders, and at the same time has had bullish option positions. When other slower participants have created illustrations for themselves that the stock prices are going up and followed by placing large amounts of reasonablely higher buying orders, the HFT firm would withdraw their buying orders and gain profit through the bullish option positions. In September 2016, a new exchange called Investors Exchange (IEX) received approval from the SEC and will be the first transparent exchange where malicious latency arbitrage strategies are no longer possible.","title":"Order Spoofing"},{"location":"_About/","text":"Markdown Examples \\[ \\underbrace{\\bA}_{=0} = 0 \\] OI Wiki Python 1 2 3 4 5 def bubble_sort ( items ): for i in range ( len ( items )): for j in range ( len ( items ) - 1 - i ): if items [ j ] > items [ j + 1 ]: items [ j ], items [ j + 1 ] = items [ j + 1 ], items [ j ] C++ 1 2 3 void f () { } The range () function is highlighted. Ex. 2.1 Suppose each of \\(K\\) -classes has associated target \\(t_k\\) , which is a vector of all zeros, except a one in the \\(k\\) -th position. Show that classifying to the largest of \\(\\hat y\\) amounts to choosing the closet target, \\(\\min_k\\|t_k-\\hat y\\|\\) , if the elements of \\(\\hat y\\) sum to one. Soln. 2.1 We need to prove: \\[\\begin{equation} \\underset{k}{\\operatorname{argmax}} \\hat y_k = \\underset{k}{\\operatorname{argmin}} \\|t_k-\\hat y\\|^2 \\label{eq:2-1a} \\end{equation}\\] By definition of \\(t_k\\) , we have \\[\\begin{align} \\|t_k-\\hat y\\|^2 &= (1-\\hat y_k)^2 + \\sum_{l \\neq k }(0 - \\hat y_l)^2\\nonumber\\\\ &= (1-\\hat y_k)^2 + \\sum_{l \\neq k }\\hat y_l^2 \\label{eq:2-1b} \\end{align}\\] Given \\(\\eqref{eq:2-1b}\\) , it's straightforward to see that \\(\\eqref{eq:2-1a}\\) indeed holds. Python 1 2 3 4 5 def bubble_sort ( items ): for i in range ( len ( items )): for j in range ( len ( items ) - 1 - i ): if items [ j ] > items [ j + 1 ]: items [ j ], items [ j + 1 ] = items [ j + 1 ], items [ j ] C++ 1 2 3 void f () { } The range () function is highlighted. Info The assumption \\(\\sum_{k=1}^K\\hat y_k=1\\) is actually not required. [ CAPM ]: Capital Asset Pricing Model asdfasdfasdfa asdfasd asdfasd adddasdfasdfasdfa asdfasd asdfasd adddasdfasdfasdfa asdfasd asdfasd addd asdfasdfasdfa asdfasd asdfasd addd asdfasdfasdfa asdfasd asdfasd addd Info The assumption \\(\\sum_{k=1}^K\\hat y_k=1\\) is actually not required. [ CAPM ]: Capital Asset Pricing Model Unordered list Sed sagittis eleifend rutrum Donec vitae suscipit est Nulla tempor lobortis orci Ordered list Sed sagittis eleifend rutrum Donec vitae suscipit est Nulla tempor lobortis orci Example Unordered List Example : 1 2 3 * Sed sagittis eleifend rutrum * Donec vitae suscipit est * Nulla tempor lobortis orci Result : Sed sagittis eleifend rutrum Donec vitae suscipit est Nulla tempor lobortis orci Ordered List Example : 1 2 3 1. Sed sagittis eleifend rutrum 2. Donec vitae suscipit est 3. Nulla tempor lobortis orci Result : Sed sagittis eleifend rutrum Donec vitae suscipit est Nulla tempor lobortis orci Method Description GET :material-check: Fetch resource PUT :material-check-all: Update resource DELETE :material-close: Delete resource Lorem ipsum 1 dolor sit amet, consectetur adipiscing elit. 2 Image caption Lorem ipsum dolor sit amet, consectetur adipiscing elit. \u21a9 Lorem ipsum dolor sit amet, consectetur adipiscing elit. Nulla et euismod nulla. Curabitur feugiat, tortor non consequat finibus, justo purus auctor massa, nec semper lorem quam in massa. \u21a9","title":"Markdown Examples"},{"location":"_About/#markdown-examples","text":"\\[ \\underbrace{\\bA}_{=0} = 0 \\] OI Wiki Python 1 2 3 4 5 def bubble_sort ( items ): for i in range ( len ( items )): for j in range ( len ( items ) - 1 - i ): if items [ j ] > items [ j + 1 ]: items [ j ], items [ j + 1 ] = items [ j + 1 ], items [ j ] C++ 1 2 3 void f () { } The range () function is highlighted. Ex. 2.1 Suppose each of \\(K\\) -classes has associated target \\(t_k\\) , which is a vector of all zeros, except a one in the \\(k\\) -th position. Show that classifying to the largest of \\(\\hat y\\) amounts to choosing the closet target, \\(\\min_k\\|t_k-\\hat y\\|\\) , if the elements of \\(\\hat y\\) sum to one. Soln. 2.1 We need to prove: \\[\\begin{equation} \\underset{k}{\\operatorname{argmax}} \\hat y_k = \\underset{k}{\\operatorname{argmin}} \\|t_k-\\hat y\\|^2 \\label{eq:2-1a} \\end{equation}\\] By definition of \\(t_k\\) , we have \\[\\begin{align} \\|t_k-\\hat y\\|^2 &= (1-\\hat y_k)^2 + \\sum_{l \\neq k }(0 - \\hat y_l)^2\\nonumber\\\\ &= (1-\\hat y_k)^2 + \\sum_{l \\neq k }\\hat y_l^2 \\label{eq:2-1b} \\end{align}\\] Given \\(\\eqref{eq:2-1b}\\) , it's straightforward to see that \\(\\eqref{eq:2-1a}\\) indeed holds. Python 1 2 3 4 5 def bubble_sort ( items ): for i in range ( len ( items )): for j in range ( len ( items ) - 1 - i ): if items [ j ] > items [ j + 1 ]: items [ j ], items [ j + 1 ] = items [ j + 1 ], items [ j ] C++ 1 2 3 void f () { } The range () function is highlighted. Info The assumption \\(\\sum_{k=1}^K\\hat y_k=1\\) is actually not required. [ CAPM ]: Capital Asset Pricing Model asdfasdfasdfa asdfasd asdfasd adddasdfasdfasdfa asdfasd asdfasd adddasdfasdfasdfa asdfasd asdfasd addd asdfasdfasdfa asdfasd asdfasd addd asdfasdfasdfa asdfasd asdfasd addd Info The assumption \\(\\sum_{k=1}^K\\hat y_k=1\\) is actually not required. [ CAPM ]: Capital Asset Pricing Model Unordered list Sed sagittis eleifend rutrum Donec vitae suscipit est Nulla tempor lobortis orci Ordered list Sed sagittis eleifend rutrum Donec vitae suscipit est Nulla tempor lobortis orci Example Unordered List Example : 1 2 3 * Sed sagittis eleifend rutrum * Donec vitae suscipit est * Nulla tempor lobortis orci Result : Sed sagittis eleifend rutrum Donec vitae suscipit est Nulla tempor lobortis orci Ordered List Example : 1 2 3 1. Sed sagittis eleifend rutrum 2. Donec vitae suscipit est 3. Nulla tempor lobortis orci Result : Sed sagittis eleifend rutrum Donec vitae suscipit est Nulla tempor lobortis orci Method Description GET :material-check: Fetch resource PUT :material-check-all: Update resource DELETE :material-close: Delete resource Lorem ipsum 1 dolor sit amet, consectetur adipiscing elit. 2 Image caption Lorem ipsum dolor sit amet, consectetur adipiscing elit. \u21a9 Lorem ipsum dolor sit amet, consectetur adipiscing elit. Nulla et euismod nulla. Curabitur feugiat, tortor non consequat finibus, justo purus auctor massa, nec semper lorem quam in massa. \u21a9","title":"Markdown Examples"}]}